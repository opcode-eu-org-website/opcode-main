% Copyright (c) 2018-2019 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\ifdefined\inputOnlyContent\else
\documentclass{pdfBooklets}

\title{Narzdzia deweloperskie: git, make i cmake, pip i virtualenv}
\author{%
	%Projekt ,,Matematyka dla Ciekawych wiata'',\\
	Robert Ryszard Paciorek\\\normalsize\ttfamily <rrp@opcode.eu.org>
}
\date  {2020-07-13}

\makeatletter\hypersetup{
	pdftitle = {\@title}, pdfauthor = {\@author}
}\makeatother


\begin{document}

\maketitle
\fi

\section{Systemem kontroli wersji}

Podstawowym zadaniem system贸w kontroli wersji jest przechowywanie historii zmian w plikach (np. 藕r贸dach jakiego projektu, plikach konfiguracyjnych, itp) oraz umo偶liwianie ledzenia tych zmian (por贸wnywanie wersji, uzyskiwanie informacji o autorach i datach zmian, itd).

W systemach rozproszonych wszystkie kopie repozytori贸w s r贸wnoprawne (zawieraj pen histori, do ka偶dego z nich mog by commitowane zmiany, itd), w systemach scentralizowanych wystpuje pojedynczy serwer do kt贸rego commitowane s zmiany i z kt贸rego s one pobierane (tak偶e operacje zwizane z histori odwouj si do serwera, a nie lokalnej kopii).

Najpopularniejszymi systemami kontroli wersji s: systemy rozproszone Git (polecenie \Verb{git}), Mercurial (polecenie \Verb{hg}) i Bazaar (polecenie \Verb{bzr}) oraz scentralizowany system kontroli wersji Subversion (polecenie \Verb{svn}). Nadal mo偶na spotka u偶ywane repozytoria \Verb{cvs}.

\subsection{Git}

\subsubsection{Inicjalizacja repozytorium}

Mamy dwie podstawowe metody utworzenia repozytorium na kt贸rym bdziemy pracowali:
\begin{itemize}
	\item utworzenie nowego, pustego repozytorium: \Verb{git init}
	\item pobranie repozytorium z zewntrznego 藕r贸da \Verb{git clone adres}
\end{itemize}
Adres repozytorium mo偶e by m.in. postaci: \Verb{https://[login@]serwer/sciezka/} lub\\ \Verb{ssh://login@serwer/sciezka/}.

\subsubsection{Kopia robocza i poczekalnia}

\begin{itemize}
	\item aktualizacja kopii roboczej: \Verb{git checkout [opcje] [sciezka]}\\
		szczeg贸lnie przydatne jest wywoanie \Verb{git checkout -f .} umo偶liwiajca odrzucenie
		istniejcych zmian w kopii roboczej (reset kopii roboczej do stanu repozytorium)
	
	\vspace{6pt}
	
	\item dodawanie plik贸w/zmian (do poczekalni): \Verb{git add sciezka}
	\item usuwanie zmian (z poczekalni): \Verb{git reset HEAD sciezka}
	\item usuwanie pliku: \Verb{git rm sciezka}\\
		(jest to r贸wnowa偶ne z \Verb{rm sciezka && git add sciezka})
	\item zmiana nazwy (poo偶enia) pliku: \Verb{git mv staraSciezka nowaSciezka}\\
		(jest to r贸wnowa偶ne z \Verb{git rm staraSciezka; git add nowaSciezka})
	
	\vspace{6pt}
	
	\item podgld zmian kopii roboczej i poczekalni: \Verb{git status}\\
		(aby ignorowa jakie niedodane do repozytorium pliki katalogi nale偶y skorzysta z pliku \Verb{.gitignore})
	\item r贸偶nica kopii roboczej do poczekalni: \Verb{git diff [sciezka]}
	\item r贸偶nica kopii roboczej do wskazanej rewizji: \Verb{git diff rewizja [sciezka]}
	\item r贸偶nica poczekalni do ostatniej / wskazanej rewizji: \Verb{git diff [rewizja] --cached [sciezka]}
	
	\vspace{6pt}
	
	\item zatwierdzanie zmian z poczekalni (tworzenie rewizji): \Verb{git commit [opcje] [sciezka]}, przydatne opcje:\\
		\Verb{-a} powoduje automatyczne dodanie zmian w ledzonych plikach\\
		\Verb{-m "OPIS"} pozwala na podanie opisu zmian z linii polece\\
		\Verb{--amend} pozwala na poprawienie ostatniego commitu
\end{itemize}

\subsubsection{Historia zmian}

\begin{itemize}
	\item przegldanie historii zmian: \Verb{git log [opcje] [sciezka]}, przydatne opcje:\\
		\Verb{-p} pokazuje w logu zmian diff pomidzy rewizjami\\
		\Verb{--name-status} pokazuje nazwy i status (dodanie, usunicie, modyfikacja) zmienianych plik贸w\\
		\Verb{--graph} pokazuje wykres gazi
	\item listowanie pliku z danej rewizji: \Verb{git show rewizja:sciezka}
	\item listowanie struktury repozytorium z danej rewizji: \Verb{git ls-tree rewizja}
\end{itemize}

\subsubsection{Gazie}

\begin{itemize}
	\item tworzenie nowej gazi: \Verb{git branch nazwa}
	\item scalanie wskazanej gazi do aktualnej:\Verb{git merge [zasob_zdalny] nazwa}
	
	\vspace{6pt}
	
	\item utworzenie gazi po stronie zdalnej: \Verb{git push --set-upstream origin nazwa}
	\item pobranie / aktualizacja informacji (m.in.) o zdalnych gaziach: \Verb{git fetch}
	\item listowanie gazi: \Verb{git branch -av}
	
	\vspace{6pt}
	
	\item przeczanie si pomidzy gaziami (zmiany w kopii roboczej nie zostan utracone, w przypadku konfliktu przed przeczeniem bdzie konieczno ich zaakceptowania lub odrzucenia):\\ \Verb{git checkout nazwa}
\end{itemize}

\subsubsection{Zasoby zdalne}

\begin{itemize}
	\item listowanie zasob贸w zdalnych: \Verb{git remote -v}
	\item dodawanie nowego zasobu zdalnego: \Verb{git remote add nazwa URL}
	
	\vspace{6pt}
	
	\item wysyanie zmian do (wskazanego) zasobu zdalnego: \Verb{git push [nazwa]}
	\item pobieranie zmian z (wskazanego) zasobu zdalnego: \Verb{git pull [nazwa]}
\end{itemize}

\subsection{Zadania}

\begin{Zadanie}{}{git_init}
\begin{enumerate}
\item utw贸rz katalog \Verb#repo1# zawierajcy dwa pliki tekstowe z dowoln zawartoci (r贸偶n)
\item utw贸rz w tym katalogu repozytorium git i sprawd藕 jego stan (status)
\item dodaj do niego wszystkie pliki z tego katalogu i sprawd藕 stan repozytorium
\item zakomituj zmiany i sprawd藕 stan repozytorium
\end{enumerate}
\end{Zadanie}

\begin{Zadanie}{}{git_modyfikacja}
Dziaajc w \Verb#repo1# utworzonym w zadaniu \ref{git_init}
\begin{enumerate}
\item zmodyfikuj zawarto jednego z plik贸w
\item sprawd藕 stan repozytorium
\item zmodyfikuj zawarto drugiego z plik贸w
% \item wywietl r贸偶nic pomidzy zawartoi kopii roboczej a zawartoci repozytorium
\item wywietl t r贸偶nic tylko dla jednego z plik贸w
\item zakomituj zmiany
\item wywietl histori zmian w repozytorium
\end{enumerate}
\end{Zadanie}

\begin{Zadanie}{}{git_clone}
Sklonuj repozytorium \Verb#repo1# jako \Verb#repo2#
\end{Zadanie}

\begin{Zadanie}{}{git_rm}
Dziaajc w \Verb#repo2# utworzonym w zadaniu \ref{git_clone}
\begin{enumerate}
\item usu z repozytorium jeden z plik贸w tekstowych
\item zmie nazw drugiego z plik贸w tekstowych
\item sprawd藕 stan repozytorium
\item zakomituj zmiany
\item wywietl histori zmian w repozytorium, z pokazaniem informacji o nazwach zmienianych plik贸w
\end{enumerate}
\end{Zadanie}

\begin{Zadanie}{}{git_pull1}
Zaktualizuj stan \Verb#repo1#, tak aby odzwierciedla zmiany dokonane w \Verb#repo2#
\end{Zadanie}

\begin{Zadanie}{}{git_merge}
\begin{enumerate}
\item zmodyfikuj plik tekstowy zar贸wno w \Verb#repo1#, jak i w \Verb#repo2# (w r贸偶ny - sprzeczny spos贸b)
\item zakomituj zmiany w \Verb#repo1# i w \Verb#repo1#
\item spr贸buj zaktualizowa stan \Verb#repo1#, tak aby odzwierciedla zmiany dokonane w \Verb#repo2#
\item sprawd藕 stan repozytorium
\item rozwi偶 konflikt
\item sprawd藕 stan repozytorium
\item wywietl histori zmian pokazujc wykres gazi w kt贸rych byy dokonywane zmiany
\item spr贸buj zaktualizowa stan \Verb#repo2#, tak aby odzwierciedla zmiany dokonane w \Verb#repo1#
\end{enumerate}
\end{Zadanie}

\begin{Zadanie}{}{git_checkout}
\begin{enumerate}
\item przywr贸ci stan kopii roboczej do stanu repozytorium z przed zadania \ref{git_merge}
\item sprawd藕 stan repozytorium
\item wywietl zawarto pliku modyfikowanego w zadaniu \ref{git_merge}
\item powr贸 do normalnego stanu repozytorium
\item sprawd藕 stan repozytorium
\end{enumerate}
\end{Zadanie}

\begin{Zadanie}{}{git_show}
Wywietl zawarto pliku modyfikowanego w \ref{git_merge} przed dokonaniem tych modyfikacji bez przeczania kopii roboczej na 贸wczesny stan repozytorium.
\end{Zadanie}

\begin{Zadanie}{}{git_diff}
Wywietl r贸偶nic stanu obecnego pliku modyfikowanego w \ref{git_merge} i stanu przed dokonaniem tych modyfikacji
\end{Zadanie}

\begin{Zadanie}{}{git_branch}
\begin{enumerate}
\item utw贸rz nowy branch w \Verb#repo1# o nazwie \Verb#test# i przecz si na niego
\item zmodyfikuj plik tekstowy w ramach tego brancha i zakomituj zmiany
\item wywietl informacje na temat branchy
\item wr贸 do domylnej gazi "master" i wywietl zawarto modyfikowanego pliku oraz stan repozytorium
\end{enumerate}
\end{Zadanie}

\begin{Zadanie}{}{git_pull2}
\begin{enumerate}
\item zacignij zmiany dokonane w zadaniu \ref{git_branch} z \Verb#repo1# do \Verb#repo2# tak aby znalazy si one w brachu o nazwie test
\item wywietl stan repozytorium, informacje na temat branchy oraz dwa najnowsze wpisy z historii repozytorium
\end{enumerate}
\end{Zadanie}

\section{make}

Make jest narzdziem su偶cym do automatyzowania kompilacji. Jego zadaniem jest ustalenie kt贸re pliki potrzebuj kompilacji po zmianach w projekcie na podstawie czasu modyfikacji plik贸w 藕r贸dowych, wynikowych oraz regu zapisanych w pliku \Verb{Makefile}.

\subsection{Wywoanie polecenia make}

Wywoanie polecenia make ma posta \Verb{make [opcje] [akcja]}.

Wr贸d opcji warto zwr贸ci uwag na:\\
\Verb{-j} pozwalajc okreli liczb r贸wnolegle uruchamianych proces贸w\\
\Verb{-i} powodujc ignorowanie bd贸w (normalnie make przerywa prac gdy kt贸re z zada nie powiodo si)\\
\Verb{-d} wypisywanie informacji dla debugowania.

Akcja okrela regu z pliku \Verb{Makefile} kt贸ra ma zosta wykonana.


\subsection{Plik Makefile}

Plik skada si z regu nastpujcej postaci:
\begin{CodeFrame*}[make]{}
nazwa: zaleznosci
	polecenia
\end{CodeFrame*}

Pierwsza linia okrela i偶 plik wynikowy (lub akcja) \Verb{nazwa} zale偶y od podanych po dwukropku plik贸w.
Druga linia (i ewentualnie kolejne) zawieraj polecenia su偶ce do wygenerowania pliku \Verb{nazwa} lub realizacji tej akcji. Linie te musz zaczyna si od znaku tabulacji.

\subsubsection{Proste przykady}

\begin{CodeFrame}[make]{.5\textwidth}
all:
	echo "Hello world"
\end{CodeFrame}
\begin{minipage}[t]{.45\textwidth}
\vspace{6pt}\noindent Ka偶de uruchomienie \Verb{make} lub \Verb{make all} spowoduje wypisanie "Hello world".
\end{minipage}

\begin{CodeFrame}[make]{.5\textwidth}
all: witaj.txt

co.txt:
	echo cosiu > co.txt

witaj.txt: co.txt
	echo -n "Witaj " > witaj.txt
	cat co.txt >> witaj.txt
\end{CodeFrame}
\begin{minipage}[t]{.45\textwidth}
\vspace{12pt}\noindent Uruchomienie \Verb{make} spowoduje nadpisanie zawartoci pliku \Verb{witaj.txt} je偶eli plik \Verb{co.txt} jest od niego nowszy. W przypadku braku pliku \Verb{co.txt} zostanie on utworzony.
\end{minipage}

\subsubsection{Bardziej zaawansowane pliki Makefile}

Poni偶szy przykad ilustruje kilka rozwiza stosowanych w plikach Makefile (dla GNU Make), takich jak ustawianie i korzystanie ze zmiennych, iterowanie po plikach, reguy generyczne:
\begin{CodeFrame*}[make]{}
# ustawiamy zmienn CONFDIR
CONFDIR=$(HOME)/.xyz/lib

# sprawdzamy czy podany plik/katalog istniej
ifeq ($(wildcard $(CONFDIR)),)
    # a je偶eli nie to zmieniamy warto zmiennej CONFDIR
    CONFDIR=$(HOME)/.xyz-lib
endif

# ustawienie zmiennej w oparciu o standardowe wyjcie innego programu
DATE=$(shell date --iso)

# warto tej zmiennej mo偶e by nadpisana przez wywoanie:
# make CONFDIR=prawdziwa/sciezka

# target installConfig kopiuje wszystkie katalogi src-conf/* do $(CONFDIR)
# zauwa偶 odwonie do zmiennej makefile'owej CONFDIR vs bashowej inDir w ptli
installConfig:
    @ for inDir in src-conf/*; do \
        install -m 644 -Dt $(CONFDIR)/`basename $$inDir` $$inDir/*" ; \
    done

# target installGSym odnajduje cie偶k z kt贸rej bdziemy kopiowa i kopiuje ...
installGSym:
    # pobieramy output komendy do zmiennej makefilowej w ramach konkretnego targetu
    $(eval GEDASYSDIR := $(shell gschem -c '(display geda-data-path)(gschem-exit)'))
    # modyfikujemy zmienn, a je偶eli jest pusta to ustawiamy warto domyln
    $(eval GEDASYMDIR := $(if $(GEDASYSDIR), "$(GEDASYSDIR)/sym", "extra/sym"))
    install -m 644 -Dt $(CONFDIR)/sym $(GEDASYMDIR)/*"

# uzyskanie pliku xyz.o wymaga pliku xyz.c i wykonania komendy:
#   $(CC) -c -o xyz.o xyz.c $(CFLAGS)
# dla dowolnego xyz ...
%.o: %.c %.h
    $(CC) -c -o $@ $< $(CFLAGS)
# % po lewej stronie : zastpuje dowolny cig znak贸w
#   (podobnie jak * w shellu, ale objemuje te偶 ciezki z katalogami)
# % po prawej stronie : oznacza podstawienie cigu dopasowanego do 
#   znaku % po lewej stronie :
# pod $@ podstawiane jest to co zostao dopasowane do
#   caoci napisu po lewj stronie :
# pod $< podstawiany jest pierwszy element z listy zaleznoci
#   (tego co po prawej stronie :)
# pod $^ podstawiana jest cao prawej strony od :
#   (co jest przydatne np. przy linkowaniu)
# standardowo $(CC) zawiera cie偶k do komilatora C,
#   a $(CFLAGS) zawiera flagi kompilacji
\end{CodeFrame*}

\subsection{Zadania}

\begin{Zadanie}{}{makefile1}
Poni偶sze polecenia utworz prosty program w C:
\begin{Verbatim}
echo 'void wypisz();' > wypisz.h
echo '#include <stdio.h>' > wypisz.c
echo '#include "wypisz.h"' >> wypisz.c
echo 'void wypisz() { printf("Hello world!\n"); }' >> wypisz.c
echo '#include "wypisz.h"' > main.c
echo 'int main() { wypisz(); return 0; }' >> main.c
\end{Verbatim}

Mo偶e on zosta skompilowany przy pomocy polece:
\begin{Verbatim}
gcc -o wypisz.o -c wypisz.c
gcc -o main.o -c main.c
gcc -o hello main.o wypisz.o
\end{Verbatim}

Napisz plik \Verb#Makefile#, kt贸ry zautomatyzuje kompilacj tego projektu. Plik powinien uwzgldnia zale偶noci pomidzy elementami projektu (plik hello wymaga dw贸ch plik贸w .o, pliki .o wymagaj odpowiednich plik贸w .c i .h). Plik powinien pozawala na okrelenie u偶ywanego kompilatora przy pomocy zmiennej rodowiskowej.
\end{Zadanie}

\begin{Zadanie}{}{makefile2}
Dodaj do pliku \Verb#Makefile# z zadania \ref{makefile1} regu \Verb#clean#, kt贸ra usunie wszystkie utworzone w wyniku kompilacji pliku. Regua powinna dziaa nawet je偶eli w katalogu znajdzie si plik o nazwie \Verb#clean#.
\end{Zadanie}

\section{Generatory plik贸w Makefile}

W przypadku wikszych projekt贸w czsto stosowane s narzdzia su偶ce do automatycznego generowania plik贸w Makefile (a czsto tak偶e plik贸w nag贸wkowych, itp) w oparciu o dostpne biblioteki i automatyczn detekcj zale偶noci pomidzy plikami. 

Wywoanie komendy \Verb{make} czsto musi zosta poprzedzane wywoaniem skryptu \Verb{./configure}. Niekiedy tak偶e ten skrypt musi zosta poprzedzony wywoaniem polecenia \Verb{autoreconf} (z pakietu autoconf/automake).

Aktualnie wiele projekt贸w korzysta do konfiguracji kompilacji (i utworzenia plik贸w Makefile) z \Verb{cmake}.

\subsection{cmake}

Cmake jest narzdziem do zarzdzania procesem kompilacji. Jest on niezale偶ny od u偶ywanej platformy, kompilatora a tak偶e narzdzia automatyzacji kompilacji (opr贸cz omawianego wczeniej \Verb{make} wspiera tak偶e kilka innych tego typu narzdzi).

G贸wnym plikiem konfiguracyjnym programu \Verb{cmake} zawierajcym reguy budowania danego oprogramowania jest \Verb{CMakeLists.txt}.

\subsubsection{Wywoanie polecenia cmake}

Wywoanie polecenia cmake ma posta \Verb{cmake [opcje] sciezka}, gdzie \Verb{cmake sciezka} wskazuje katalog zawierajcy plik \Verb{CMakeLists.txt} (typowo g贸wny katalog ze 藕r贸dami projektu).

Konstrukcja taka pozwala na atwe budowanie projektu w innym katalogu ni偶 ten zawierajcy 藕r贸da\footnote{ pozwala to unikn mieszania 藕r贸de z plikami .o, generowanymi plikami Makefile, itp} np.:
\begin{Verbatim}
cd sciezka/do/projektu
mkdir build
cd build
cmake ..
\end{Verbatim}

Wr贸d opcji nale偶y zwr贸ci szczeg贸ln uwag na opcj \Verb{-D} pozwalajc na ustawianie flag budowania i kompilacji. Warto tak偶e zr贸ci uwag na program \Verb{ccmake} pozwalajcy na przegldanie i modyfikowanie ustawie kompilacji.

\subsubsection{Plik CMakeLists.txt}

W pliku tym umieszczane s m.in komendy:
\begin{itemize}
	\item ustawiajce zmienne cmake'owe, kt贸re mog by u偶yte np. do generowania \Verb{#define} w plikach nag贸wkowych czy te偶 if'owania fragment贸w pliku CMakeLists.txt (np. w celu wymagania lub nie danych bibliotek) -- \Verb{set()} i polecenia \Verb{option()}
	\item operujce na listach (np. plik贸w) i plikach -- \Verb{list()} i \Verb{file()}
	\vspace{6pt}
	\item ustawiajce opcje kompilacji -- \Verb{add_compile_options()}
	\item dodajce katalogi z plikami nag贸wkowymi -- \Verb{include_directories()}
	\item dodajce linkowane biblioteki -- \Verb{link_libraries()}
	\vspace{6pt}
	\item dodajce cele budowania (akcje w Makefile) zwizane z kompilacj i linkowaniem -- \Verb{add_executable()}, \Verb{add_library()}
	\item dodajce cele budowania (akcje w Makefile) -- \Verb{add_custom_command()} \Verb{add_custom_target()}
	\item dodajce biblioteki linkowane tylko z wskazanym celem budowania -- \Verb{target_link_libraries()}
	\item ustalajce zale偶noci pomidzy celami -- polecenia \Verb{add_dependencies()}
	\vspace{6pt}
	\item realizujce ptle, sprawdzajce warunki, definiujce funkcje czy te偶 wypisujce komunikaty -- polecenia takie jak , \Verb{foreach()}, \Verb{if()}, \Verb{macro()}, \Verb{message()}
\end{itemize}

\noindent Przykad:
\begin{CodeFrame*}[cmake]{}
# wymagamy minimalnej wersji cmake
cmake_minimum_required (VERSION 3.0)

# okrelamy nazw naszego projektu i jzyk/kompilator
project("PoznajemyCMAKE" CXX)

option(USE_XLIB "Use X11 (if possible ...)" ON)

# ustawiamy flagi kompilatora
add_compile_options("-Wall")

# je偶eli dziaamy na platformie unix'owej ...
if(UNIX)
    # dodajemy opcj linkowania z bibliotek matematyczn
    # bdzie ona dodana do wszystkich wywoa linkera
    link_libraries(m)
    
    # wyszukujemy bibliotek X11
    if(${USE_XLIB})
        find_package(X11)
        
        # je偶eli nie ma to przeczamy USE_XLIB na OFF
        if(NOT ${X11_FOUND})
            set(USE_XLIB OFF)
        # a je偶eli jest to dodajemy do listy Libraries
        else()
            list(APPEND Libraries ${X11_X11_LIB})
        endif()
    endif()
endif(UNIX)

# tworzymy config.h w oparciu o szablon
# wpis #cmakedefine USE_XLIB zostanie zamieniony na #define USE_XLIB
# je偶eli USE_XLIB jest ustawione
configure_file (
    "${PROJECT_SOURCE_DIR}/config.h.in"
    "${PROJECT_BINARY_DIR}/config.h"
)

# wyszukujemy rekurencyjnie pliki z rozszerzeniem .cpp
# w pod katalogu src katalogu 藕r贸dowego projektu
file(GLOB_RECURSE Sources "${PROJECT_SOURCE_DIR}/src/*.cpp")

# wypisujemy co znale藕limy - debug output ;-)
message(STATUS "Sources:")
foreach(ff ${Sources})
    message(STATUS "  ${ff}")
endforeach()

# ustawiamy 偶e katalogiem bazowm dla plik贸w nag贸wkowych
# (podawnym w opcji -I gcc/clang) bdzie podkatalog src naszego projektu
include_directories("${PROJECT_SOURCE_DIR}/src")
# typowo robimy to tak偶e dla znalezionych nag贸wk贸w bibliotek ...

# dodajemy target w postaci tworzenia pliku wykonywalnego o nazwie Run
# powstaego z kompilacji i linkowania 藕r贸d z listy Sources
add_executable(Run ${Sources})

# ustawiamy dodatkowe biblioteki z kt贸rymi bdzie linkowany plik
# wykonywalny Run w oparciu o list Libraries
target_link_libraries(Run ${Libraries})
\end{CodeFrame*}


\subsection{SCons}

SCons jest alternatywnym rozwizaniem wobec zestawu \Verb{cmake} + \Verb{make},
pozwalajcym na tworzenie plik贸w zarzdzajcych procesem budowania w postaci skrypt贸w Pythona. 


\section{Narzdzia pythonowe}

\subsection{PIP}

Pip jest narzdziem su偶cym do instalowania modu贸w pythonowych z dedykowanego repozytorium (managerem/instalatorem pakiet贸w pythonowych). W przypadku Pythona w wersji 3 nale偶y wywoywa go poleceniem \Verb{pip3}.
Po nazwie polecenia podaje si komend okrelajc dziaania kt贸re ma wykona manager, do najistotniejszych nale偶y zaliczy:\\
\begin{itemize}
	\item \texttt{install \textit{nazwa}} instaluje podany pakiet
	\item \texttt{install -U \textit{nazwa}} aktualizuje podany pakiet
	\item \texttt{uninstall \textit{nazwa}} usuwa podany pakiet
	\item \texttt{search \textit{sowo}} wyszukuje pakiety w oparciu o podane sowo kluczowe
	\item \texttt{list -v} wypisuje zainstalowane pakiety wraz z informacj o katalogu w kt贸rym zostay zainstalowane oraz czy pakiet by instalowany przy pomocy pip, czy w inny spos贸b (np. przez systemowego menagera pakiet贸w)
\end{itemize}

Pip automatycznie instaluje zale偶noci pakietu, w niekt贸rych przypadkach mo偶e to wymaga zainstalowanych narzdzi i odpowiednich bibliotek C i/lub C++.

\begin{Zadanie}{}{}
Zainstaluj (lub zaktualizuj je偶eli jest obecnie zainstalowany) przy pomocy pip pakiet virtualenv
\end{Zadanie}

\subsection{Virtualenv}

Virtualenv jest narzdziem pozwalajcym na tworzenie rodowisk pythonowych udostpniajcych r贸偶ne wersje modu贸w. W celu utworzenia nowego rodowiska wywouje si go poleceniem \Verb{virtualenv cie偶ka}, gdzie \Verb{cie偶ka} wskazuje na miejsce w kt贸rym ma zosta utworzone rodowisko. Po utworzeniu rodowiska mo偶na doinstalowa wewntrz niego wymagane wersje bibliotek przy pomocy komendy pip dostpnej w pod-katalogu \Verb{bin} katalogu utworzonego rodowiska. Do wywoania program贸w pythonowych z u偶yciem danego rodowiska nale偶y korzysta z pliku wykonywalnego python3 w pod-katalogu \Verb{bin} danego rodowiska. Mo偶na tak偶e skorzysta z pliku \Verb{bin/activate} w katalogu utworzonego rodowiska, poprzez wczytanie go w bierzcej powoce basha (\Verb{. scizeka_do_enva/bin/activate}) celem uzyskania powoki w kt贸rej domylnym interpreterem pythona bdzie ten z utworzonego rodowiska ,,virtualenv''. Zmiany w rodowisku wprowadzone w wyniku wczytania pliku \Verb{bin/activate} obowizuj tylko w bierzcej powoce, mo偶na je tak偶e odwr贸ci przy pomocy polecenia \Verb{deactivate}.

\begin{CodeFrame*}[bash]{}
# tworzenie nowego rodowiska
virtualenv /tmp/py1
# u偶ycie pip wewntrz rodowiska
/tmp/py1/bin/pip3 list
# wywoanie pytana wewntrz rodowiska
/tmp/py1/bin/python3

# "przeczenie" na pythona z rodowiska
. /tmp/py1/bin/activate
# teraz aby u偶y pip lub wewntrz rodowiska wystarczy uruchomi
pip3 list
python3
\end{CodeFrame*}

\begin{ProTip}{Informacja {\Symbola }}
Virtualenv nie jest chroot'em - Python z tak utworzonego rodowiska ,,widzi'' reszt systemu, a tak偶e ,,wie'' w jakiej cie偶ce jest zainstalowany (zobacz zawarto zmiennej \Verb{sys.path}).
\end{ProTip}

\begin{Zadanie}{}{}
Utw贸rz rodowisko pythonowe typu ,,virtualenv'' w katalogu ytdl i zainstaluj wewntrz niego pakiet pythonowy youtube-dl.
\end{Zadanie}

\ifdefined\inputOnlyContent\else
\rozwiazania

\copyrightFooter{
	漏 Robert Paciorek, 2015-2020.\\
	Kopiowanie, modyfikowanie i redystrybucja dozwolone pod warunkiem zachowania informacji o autorach.
}
\end{document}
\fi

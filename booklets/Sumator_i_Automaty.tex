% Copyright (c) 2019 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\ifdefined\inputOnlyContent\else
\documentclass{pdfBooklets}

\title{Laboratorium programistyczne:\\ Sumator i zastosowania automat√≥w}
\author{%
	Projekt ,,Matematyka dla Ciekawych ≈öwiata'',\\
	Robert Ryszard Paciorek\\\normalsize\ttfamily <rrp@opcode.eu.org>
}
\date  {2019-05-09}

\makeatletter\hypersetup{
	pdftitle = {\@title}, pdfauthor = {\@author}
}\makeatother


\usepackage{tikz}
\usetikzlibrary{positioning} % for positionig nodes with `right = of X`
\usetikzlibrary{automata} % for initial and accepting nodes in tikzpicture graphs
\usetikzlibrary{arrows.meta, decorations.markings} % for arrows formating in tikzpicture
\usetikzlibrary{shapes} % for elipse nodes

\tikzset{
  arrowOuter/.style args={#1 colored by #2}{
    line width=#1, #2,
    decoration = {markings, mark=at position -0.01pt with \arrow{Kite[length=(#1),width=5*(#1)/2,inset=0,#2]}},
    preaction = {decorate}, % put arrow via decoration to prevent move due to shorten
    shorten >= {3*(#1)/4},  % use shorten to cut line inside arrow
  },
  arrowInner/.style args={#1 colored by #2 and scale by #3}{
    line width=#1-4*#3/3, #2,
    decoration = {markings, mark=at position -7*#3/8 with \arrow{Kite[length=(#1-3*#3/2),width=5*(#1-3*#3/2)/2,inset=0,#2]}},
    preaction = {decorate}, % put arrow via decoration to prevent move due to shorten
    shorten >= {3*(#1)/4 - #3/4},  % use shorten to cut line inside arrow
  },
  arrowDouble/.style args={#1 colored by #2}{
    double, line width=#1/6, double distance=2*#1/3, #2,
    decoration = {markings, mark=at position -0.01pt with \arrow{Kite[length=(#1),width=5*(#1)/2,inset=0,line width=11*#1/60,open,#2]}},
    preaction = {decorate}, % put arrow via decoration to prevent move due to shorten
    shorten >= {49*#1/60 - 0.015pt},  % use shorten to cut line inside arrow
    %postaction = {draw, line width=2*#1/3, green, shorten >= {3*(#1)/4}}
  },
  invisibleNode/.style={inner sep=0, outer sep = 0pt, minimum size=0},
}

\definecolor{xgreen}{rgb}{0.0,0.55,0.0}
\definecolor{xgray}{rgb}{0.45,0.45,0.45}

\begin{document}

\maketitle
\fi

%  BEGIN: Systemy liczbowe 01
\section{Systemy liczbowe}

Liczby mogƒÖ byƒá zapisywane w r√≥≈ºny spos√≥b. IstniejƒÖ systemy addytywne (np. rzymski), w kt√≥rych istotna jest ilo≈õƒá powt√≥rze≈Ñ danego elementu oraz systemy pozycyjne o r√≥≈ºnych podstawach (np. system dziesiƒôtny), w kt√≥rych istotne jest miejsce w kt√≥rym znajduje siƒô dany element.

W ≈ºyciu codziennym najczƒô≈õciej spotykamy siƒô z zapisem dziesiƒôtnym, funkcjonujƒÖcym nastƒôpujƒÖco: $5731 = 10^0 \cdot 1 + 10^1 \cdot 3 + 10^2 \cdot 7 + 10^3 \cdot 5$.

\subsection{System dw√≥jkowy}

Ze wzglƒôdu na spos√≥b budowy elektroniki cyfrowej i komputer√≥w w informatyce du≈ºo czƒô≈õciej spotykamy siƒô z systemem dw√≥jkowym (oraz systemami ≈Çatwo rozk≈ÇadajƒÖcymi siƒô na dw√≥jkowy, np. szesnastkowym).

PojedynczƒÖ cyfrƒô systemu dw√≥jkowego (przybierajƒÖcƒÖ warto≈õƒá 0 albo 1) okre≈õla siƒô mianem \emph{bit}u, liczby reprezentowane sƒÖ jako ciƒÖgi takich cyfr. Terminem \emph{bajt} okre≈õla siƒô zazwyczaj ciƒÖg o d≈Çugo≈õci 8 bit√≥w (ale w niekt√≥rych systemach ciƒÖg o innej d≈Çugo≈õci).

Podstawowym sposobem zapisy liczb ca≈Çkowitych nie ujemnych w systemie dw√≥jkowym jest \emph{naturalny kod binarny} (\emph{NKB}), w kt√≥rym np. 4 bitowy ciƒÖg {\tt a\textsubscript{3}a\textsubscript{2}a\textsubscript{1}a\textsubscript{0}} reprezentuje liczbƒô $2^0 \cdot a_0 + 2^1 \cdot a_1 + 2^2 \cdot a_2 + 2^3 \cdot a_3$. Zwr√≥ƒá uwagƒô na podobie≈Ñstwo do systemu dziesiƒôtnego.

Podstawowym sposobem zapisy liczb ca≈Çkowitych (ze znakiem) jest \emph{kod uzupe≈Çnie≈Ñ do dw√≥ch} (\emph{U2}) w kt√≥rym n-bitowa liczba reprezentowana przez ciƒÖg {\tt a\textsubscript{n-1}...a\textsubscript{3}a\textsubscript{2}a\textsubscript{1}a\textsubscript{0}} bƒôdzie mia≈Ça warto≈õƒá $2^0 \cdot a_0 + 2^1 \cdot a_1 + 2^2 \cdot a_2 + ... + 2^{n-2} \cdot a_{n-2} - 2^{n-1} \cdot a_{n-1}$. Jako ≈ºe najstarszy bit wchodzi z ujemnƒÖ wagƒÖ, jego ustawienie na 1 oznacza liczbƒô ujemnƒÖ (ale nie jest to kod znaku). Warto zauwa≈ºyƒá kompatybilno≈õƒá z NKB.

Liczby zapisywane w tych kodowaniach systemu dw√≥jkowego oznacza siƒô czƒôsto przy pomocy prefiksu "0b" albo sufiksu "b" (w Pythonie mo≈ºemy stosowaƒá jedynie  zapis z prefiksem), np. {\tt 0b101 = 101b} reprezentuje liczbƒô 5 w systemie dziesiƒôtnym ($2^0 \cdot 1 + 2^1 \cdot 0 + 2^2 \cdot 1 = 5$).

%Opr√≥cz podanych istnieje jeszcze kilka stosowanych sposob√≥w zapisu liczb binarnych takich jak (dla liczb bez znaku): kod "1 z n", kod Graya, kod Johnsona, (dla liczb ze znakiem): kod znak-modu≈Ç, kod uzupe≈Çnie≈Ñ do jedno≈õci (U1). Odmiennym zagadnieniem jest kodowanie liczb zmiennoprzecinkowych. Nie bƒôdziemy ich jednak omawiaƒá na tych zajƒôciach.
%  END: Systemy liczbowe 01

%  BEGIN: Sumator
\section{Sumator}

Cyfrowe uk≈Çady elektroniczne (tak≈ºe te sk≈ÇadajƒÖce siƒô na nasze komputery) ka≈ºdƒÖ liczbƒô traktujƒÖ jako ciƒÖg logicznych jedynek i zer (warto≈õci True i False).
Spr√≥bujemy zasymulowaƒá takie dzia≈Çanie w Pythonie i zastanowiƒá siƒô nad tym jak mo≈ºna zrealizowaƒá dodawanie takich liczb.

Je≈ºeli znamy i pamiƒôtamy jeszcze metodƒô dodawania ,,w s≈Çupku'' (,,pod kreskƒÖ'') to wiemy, ≈ºe dodawanie dw√≥ch n cyfrowych liczb mo≈ºemy potraktowaƒá jako ciƒÖg n dodawa≈Ñ dw√≥ch liczb jednocyfrowych z obs≈ÇugƒÖ przeniesienia.
Podobnie mo≈ºna postƒÖpiƒá przy sumowaniu liczb binarnych. Potrzebujemy zatem elementu, kt√≥ry bƒôdzie sumowa≈Ç 3 warto≈õci logiczne (dwie pochodzƒÖce z sumowanych liczb, jedna z przeniesienia z poprzedniego elementu)
i generowa≈Ç wynik sumy oraz warto≈õƒá przeniesienia dla nastƒôpnego elementu.

\begin{Zadanie}{}{}
Zastan√≥w siƒô w jaki spos√≥b, korzystajƒÖ z poznanych funkcji logicznych (and, or, xor, not) mo≈ºna obliczyƒá warto≈õƒá sumy dw√≥ch cyfr binarnych a i b oraz warto≈õƒá przeniesienia.

\emph{Wskaz√≥wka: zapisz tablicƒô prawdy dla tej operacji}

\begin{teacherOnly}
ZapisujƒÖc tablicƒô prawdy dla takiej operacji:

\begin{tabular}{c|c||c|c}
a & b  &  suma & przeniesienie\\
\hline
0 & 0  &  0 & 0\\
1 & 0  &  1 & 0\\
0 & 1  &  1 & 0\\
1 & 1  &  0 & 1\\
\end{tabular}

mo≈ºemy zauwa≈ºyƒá ≈ºe suma to a XOR b, natomiast przeniesienie to a AND b.
\end{teacherOnly}
\end{Zadanie}

\begin{Zadanie}{}{}
Spr√≥buj rozszerzyƒá poprzednie rozwiƒÖzanie, tak aby uwzglƒôdniaƒá w sumowaniu przeniesienie z poprzedniego elementu.

\emph{Wskaz√≥wka: rozszerz tablicƒô prawdy o jednƒÖ kolumnƒô wej≈õciowƒÖ}

\begin{teacherOnly}

\begin{tabular}{c|c|c||c|c}
p & a & b  &  suma & przeniesienie\\
\hline
0 & 0 & 0  &  0 & 0\\
0 & 1 & 0  &  1 & 0\\
0 & 0 & 1  &  1 & 0\\
0 & 1 & 1  &  0 & 1\\
%
1 & 0 & 0  &  1 & 0\\
1 & 1 & 0  &  0 & 1\\
1 & 0 & 1  &  0 & 1\\
1 & 1 & 1  &  1 & 1\\
\end{tabular}

\vspace{6pt} Teraz jest to trudniej zauwa≈ºyƒá, ale:
\begin{itemize}
\item suma to (a XOR b) XOR p
\item przeniesienie to (a AND b) OR (p AND (a OR b)), co jest r√≥wnowa≈ºne (a AND b) OR (p AND (a XOR b)),\\
      gdy≈º XOR od OR r√≥≈ºni siƒô tylko dla a == b == 1, a ten przypadek za≈Çatwia i tak OR z (a AND b)
\end{itemize}

Mo≈ºna te≈º pokazaƒá i om√≥wiƒá animacjƒô z Wikipedii: \url{https://commons.wikimedia.org/wiki/File:Fulladder.gif}
\end{teacherOnly}
\end{Zadanie}

\begin{teacherOnly}
\vspace{8pt}\noindent\strong{Napisaƒá na tablicy wzory na sumator:}\\
s = (a XOR b) XOR p\\
p = (a AND b) OR (p AND (a XOR b))\\
\end{teacherOnly}

\begin{Zadanie}{}{zadanie_FullAdder}
Napisz funkcjƒô realizujƒÖcƒÖ sumator. Funkcja powinna przyjmowaƒá 3 argumenty logiczne (warto≈õci dw√≥ch bit√≥w do zsumowania oraz warto≈õƒá przeniesienia) i zwracaƒá warto≈õƒá sumy i przeniesienia do nastƒôpnego elementu.

\emph{Wskaz√≥wka: zwracanie dw√≥ch element√≥w z funkcji najpro≈õciej zrealizowaƒá poprzez zwracanie dwu elementowej listy.}
\end{Zadanie}

Liczba 6 posiada zapis binarny 0b110. Czyli je≈ºeli chcieliby≈õmy przedstawiƒá jƒÖ w postaci listy warto≈õci logicznych by≈Çoby to [0, 1, 1]. Zwr√≥ƒá uwagƒô na zmianƒô kolejno≈õƒá bit√≥w: wynika ona z tego ≈ºe w zapisie list element o indeksie zero podajemy jako pierwszy a w zapisie binarnym liczby bit zerowy (wchodzƒÖcy z wagƒÖ $2^0$) jest jako ostatni. Dziƒôki takiemu zapisaniu liczb mo≈ºemy u≈ºyƒá naszego sumatora do dodania wielo-bitowych liczb.

\begin{Zadanie}{\domowe{3}}{zadanie_sumator_list}
Napisz funkcjƒô wykorzystujƒÖcƒÖ sumator stworzony w zadaniu \ref{zadanie_FullAdder} do obliczania sumy dw√≥ch liczb reprezentowanych jako listy warto≈õci logicznych.
Na przyk≈Çad dla argument√≥w \Verb{[True, False, True]}, \Verb{[False, True, True]} (odpowiadajƒÖcych liczbom 5 i 6) wynikiem powinna byƒá lista \Verb{[True, True, False, True]} (odpowiadajƒÖca liczbie 11).

RozwiƒÖzanie powinno dzia≈Çaƒá poprawnie dla liczb o dowolnej ilo≈õci bit√≥w, tak≈ºe w przypadku gdy liczba bit√≥w poszczeg√≥lnych liczb jest r√≥≈ºna.
RozwiƒÖzania dzia≈ÇajƒÖce tylko dla liczb o r√≥wnej lub ustalonej liczbie bit√≥w mogƒÖ otrzymaƒá maksymalnie 2pkt.

\emph{Wskaz√≥wka: dodawanie elementu na koniec listy mo≈ºliwe jest z u≈ºyciem metody \Verb{append}, mo≈ºna te≈º zedefiniowaƒá listƒô o zadanej ilo≈õci element√≥w np. \Verb{5 * [False]} i tylko modyfikowaƒá wybrane elementy.}
\end{Zadanie}
%  END: Sumator


\section{Automaty sko≈Ñczone}

Ju≈º najprostszy z poznanych typ√≥w automat√≥w, czyli automat sko≈Ñczony, znajduje szerokie zastosowania praktyczne m.in. w informatyce i elektronice. Model automatu u≈ºywany jest m.in. do opisu dzia≈Çania niekt√≥rych protoko≈Ç√≥w komunikacyjnych, czy te≈º algorytm√≥w postƒôpowania, a tak≈ºe do opisu i realizacji elektronicznych uk≈Çad√≥w logicznych.

\subsection{opisy algorytm√≥w}
W zastosowaniach informatycznych najczƒô≈õciej:
\begin{itemize}
\item przej≈õcia zwiƒÖzane sƒÖ z reakcjƒÖ na dzia≈Çania u≈ºytkownika lub klienta
\item wykonaniu przej≈õcia do nowego stanu towarzyszy te≈º wykonanie jakiej≈õ akcji (np. wys≈Çanie odpowiedzi do klienta, zapamiƒôtanie jaki≈õ dodatkowych informacji)
\item stan automatu zwiƒÖzany jest z stanem wewnƒôtrznym realizowanego algorytmu
\end{itemize}

\subsubsection{Typowe sposoby implementacji automat√≥w}


Najbardziej klasycznym przyk≈Çadem implementacji algorytmu w postaci automatu jest (zazwyczaj niesko≈Ñczona) pƒôtla w ramach kt√≥rej:

\noindent\begin{minipage}[t]{0.61\textwidth}
\begin{itemize}
\item wczytujemy kolejne porcje danych odpowiedzialne za wywo≈Çywanie kolejnych przej≈õƒá pomiƒôdzy stanami automatu,
\item z u≈ºyciem instrukcji warunkowej {\tt if / else} (lub nie wystƒôpujƒÖcej w Pythonie instrukcji wyboru {\tt switch / case}) w oparciu o aktualny stan automatu wybieramy stosowne postƒôpowanie,
\item w wyniku wykonanych operacji ustalamy nowy stan automatu.
\end{itemize}
\end{minipage}\hfill\begin{minipage}[t]{0.35\textwidth}
\vspace{-8pt}
\begin{minted}{python}
while True:
    x = pobierzDane()
    if stan == "A":
        stan = dzialaniaA(x)
    elif  stan == "B":
        stan = dzialaniaB(x)
    ...
\end{minted}
\end{minipage}

\begin{Zadanie}{}{zadanie_konczace_ab}
Zaimplementuj automat sprawdzajƒÖcy czy podane s≈Çowo nale≈ºy do jƒôzyka nad alfabetem s≈Ç√≥w ko≈ÑczƒÖcych siƒô ciƒÖgiem \Verb{ab}:

\vspace{-0.5cm}\begin{center}\begin{tikzpicture}[->, >={Stealth[length=8pt,width=6pt]}, node distance=2.8cm, semithick]
\node[circle, draw, initial] (0) {0};
\node[circle, draw] (A) [right = of 0] {1};
\node[circle, draw, accepting] (AB) [right = of A] {2};
\path (0)  edge [bend left=45] node[above] {a} (A);
\path (0)  edge [loop] node[above] {b} (0);
\path (A)  edge [bend left=45] node[above] {b} (AB);
\path (A)  edge [loop] node[above] {a} (A);
\path (AB) edge [bend left=45] node[above] {a} (A);
\path (AB) edge [bend left=45] node[above] {b} (0);
\end{tikzpicture}\end{center}\vspace{-0.5cm}

\emph{Wskaz√≥wka: zamiast \Verb{while True} mo≈ºesz u≈ºyƒá pƒôtli iterujƒÖcej po literach s≈Çowa.}
\end{Zadanie}



\subsubsection{SMTP}

Oficjalna specyfikacja protoko≈Çu przesy≈Çu poczty elektronicznej SMTP (Simple Mail Transfer Protocol) czyli \href{https://www.rfc-editor.org/info/rfc821}{RFC 821} nie definiuje tego protoko≈Çu bezpo≈õrednio z u≈ºyciem automatu sko≈Ñczonego. Jednak mo≈ºliwe jest opisanie go w taki spos√≥b. Poni≈ºej znajduje siƒô graf automatu reprezentujƒÖcy typowƒÖ sesjƒô protoko≈Çu SMTP (nie jest to pe≈Çen opis protoko≈Çu ani jego dzia≈Çania - pominiƒôte zosta≈Çy niekt√≥re z obowiƒÖzkowych komend protoko≈Çu oraz zagadnienia weryfikacji).

\vspace{0.5cm}

\begin{adjustbox}{trim=2.95cm 0.7cm 0cm 0cm, clip=false, scale=.95}
\begin{tikzpicture} [ ->, >={Stealth[length=8pt,width=6pt]}, node distance=2.8cm, semithick, initial text={}, ]
	\tikzstyle{stan}=[ellipse, draw]
	\tikzstyle{klient}=[above, align=center, font=\footnotesize\tt\color{blue}]
	\tikzstyle{serwer}=[below, align=center, font=\footnotesize\tt\color{xgreen}]
	
	\node[stan, initial] (S0) {IDLE};
	\node[stan] (S2) [right = 2.5cm of S0] {C};
	\node[stan] (H)  [right = of S2] {HA};
	\node[stan] (MF) [right = 3.1cm of H]  {SA};
	\node[stan] (RT) [right = 3.1cm of MF] {RA};
	\node[stan] (DATA) [below = of RT] {DATA};
	
	\path
		(S2)
			edge[out=-90, in=-130, looseness=0.65]
				node[klient, pos=0.45] {QUIT}
				node[serwer, pos=0.45] {221 ... \textit{zamkniƒôcie po≈Ç.}}
				(S0)
		(H)
			edge[out=-100, in=-130, looseness=0.9]
				node[klient] {QUIT}
				node[serwer] {221 ... \textit{zamkniƒôcie po≈Ç.}}
				(S0)
		(MF)
			edge[out=-90, in=-130, looseness=1]
				node[klient] {QUIT}
				node[serwer] {221 ... \textit{zamkniƒôcie po≈Ç.}}
				(S0)
		(RT)
			edge[out=-110, in=-130, looseness=1]
				node[klient] {QUIT}
				node[serwer] {221 ... \textit{zamkniƒôcie po≈Ç.}}
				(S0)
		;
	\path
		(S0)
			edge
				node[klient] {\itshape nawiƒÖzanie\\\itshape po≈ÇƒÖczenia}
				node[serwer] {220 ...}
				(S2)
		(S2)
			edge
				node[klient] {HELLO ...}
				node[serwer] {250 ...}
				(H)
		(H)
			edge[loop, out=30, in=150, looseness=7]
				node[klient] {...}
				node[serwer] {500 ...}
				(H)
			edge[loop, out=30, in=150, looseness=16]
				node[klient] {RCPT TO: ... \\ DATA}
				node[serwer] {503 ...}
				(H)
			edge
				node[klient] {MAIL FROM: ...}
				node[serwer] {250 ...}
				(MF)
			edge[out=-110, in=-160, looseness=11]
				node[klient,sloped] {RSET}
				node[serwer,sloped] {250 ...}
				(H)
		(MF)
			edge[loop, out=30, in=150, looseness=7]
				node[klient] {...}
				node[serwer] {500 ...}
				(MF)
			edge[loop, out=30, in=150, looseness=16]
				node[klient] {DATA}
				node[serwer] {503 ...}
				(MF)
			edge
				node[klient] {RCPT TO: ...}
				node[serwer] {250 ...}
				(RT)
			edge[out=-110, in=-70, looseness=0.7]
				node[klient] {RSET}
				node[serwer] {250 ...}
				(H)
		(RT)
			edge[loop, out=30, in=150, looseness=7]
				node[klient] {...}
				node[serwer] {500 ...}
				(RT)
			edge[loop, out=30, in=150, looseness=16]
				node[klient] {RCPT TO: ...}
				node[serwer] {250 ...}
				(RT)
			edge[out=-40, in=90]
				node[klient,sloped] {DATA ...}
				node[serwer,sloped] {250 ...}
				(DATA)
			edge[out=-110, in=-70]
				node[klient] {RSET}
				node[serwer] {250 ...}
				(H)
		(DATA)
			edge[loop, out=-20, in=-90, looseness=3]
				node[klient] {...}
				(DATA)
			edge[out=-150, in=-90]
				node[klient, pos=0.25] {\itshape pojedyncza\\\itshape kropka w linii}
				node[serwer, pos=0.25] {250 ...}
				(H)
	;
\end{tikzpicture}
\end{adjustbox}

\noindent
Poszczeg√≥lne stany oznaczajƒÖ:
\begin{itemize}
\item IDLE -- oczekiwanie na po≈ÇƒÖczenie
\item C -- nawiƒÖzane po≈ÇƒÖczenie w warstwie ni≈ºszej (TCP)
\item HA -- otrzymano i zapamiƒôtano informacjƒô o adresie klienta przekazanym w HELO (jest to nazwa hosta lub nazwa domenowa, ale nie adres poczty)
\item SA -- otrzymano i zapamiƒôtano informacjƒô o adresie e-mail nadawcy
\item RA -- otrzymano i zapamiƒôtano informacjƒô o adresach e-mail odbiorc√≥w (kolejne wej≈õcia do tego stanu powodujƒÖ dodanie kolejnego odbiorcy do listy)
\item DATA -- odbieranie tre≈õci maila (zako≈Ñczenie przy pomocy linii z≈Ço≈ºonej wy≈ÇƒÖcznie z kropki, skutkuje zakolejkowaniem listu do wysy≈Çki lub jego wys≈Çaniem)
\end{itemize}

\noindent
Powy≈ºej strza≈Çek reprezentujƒÖcych przej≈õcia pomiƒôdzy stanami (kolor niebieski) podane zosta≈Çy dzia≈Çania i polecenia wysy≈Çane przez klienta wywo≈ÇujƒÖce dane przej≈õcie, za≈õ poni≈ºej (kolor zielony) podane zosta≈Çy odpowiedzi serwera.
W miejscu {\tt ...} wystƒôpuje tekst stanowiƒÖcy dane (np. adres nadawcy lub odbiorcy), komunikat zwiƒÖzany z podanym kodem odpowiedzi lub dowolnƒÖ, innƒÖ od wymienionych komendƒô.
Zapis przyk≈Çadowej sesji protoko≈Çu SMTP opisywanej powy≈ºszym automatem:

{\vspace{0.3cm}\noindent\tt
  ¬†\hspace{1cm}\color{xgreen}220 dragon.icm.edu.pl ESMTP Exim 4.89 Fri, 26 Apr 2019 13:14:42 +0000
\\¬†\hspace{1cm}\color{blue}HELO test.example.com
\\¬†\hspace{1cm}\color{xgreen}250 dragon.icm.edu.pl Hello test.example.com [2001:6a0:0:21::60:13]
\\¬†\hspace{1cm}\color{blue}MAIL FROM: rrp@dragon.icm.edu.pl
\\¬†\hspace{1cm}\color{xgreen}250 OK
\\¬†\hspace{1cm}\color{blue}RCPT TO: rrp@dragon.icm.edu.pl
\\¬†\hspace{1cm}\color{xgreen}250 Accepted
\\¬†\hspace{1cm}\color{blue}DATA
\\¬†\hspace{1cm}\color{xgreen}354 Enter message, ending with "." on a line by itself
\\¬†\hspace{1cm}\color{blue}to jest e-mail, ale bez standardowych naglowkow ...
\\¬†\hspace{1cm}\color{blue}wiec bedzie dziwnie wygladal w programie klienckim ...
\\¬†\hspace{1cm}\color{blue}.
\\¬†\hspace{1cm}\color{xgreen}250 OK id=1hK0hn-0008FU-OV
\\¬†\hspace{1cm}\color{blue}QUIT
\\¬†\hspace{1cm}\color{xgreen}221 dragon.icm.edu.pl closing connection
\color{black}\vspace{0.3cm}}

\begin{Zadanie}{\domowe{3}}{zadanie_smtp}
\teacher{\strong{Uwaga:} Pomimo ≈ºe zadanie sugerujƒô daƒá jako domowe to na zajƒôciach warto kr√≥tko om√≥wiƒá dzia≈Çanie tego automatu. }
Napisz symulator serwera SMTP w postaci wy≈ºej przedstawionego automatu. Program powinien przyjmowaƒá kolejne komendy od u≈ºytkownika i stosownie na nie reagowaƒá.

\vspace{0.3cm}
\emph{Wskaz√≥wka: do wczytywania kolejnych linii w ramach pƒôtli g≈Ç√≥wnej automatu mo≈ºesz u≈ºyƒá: \python{linia = sys.stdin.readline().rstrip()}.
                 Wymaga to wcze≈õniejszego zaimportowania modu≈Çy sys poprzez: \python{import sys}.\student{\\}
                 Dziƒôki u≈ºyciu metody \python{rstrip()} wczytana linia nie bƒôdzie zawiera≈Ça ko≈ÑczƒÖcego jƒÖ znaku nowej linii (ani innych bia≈Çych znak√≥w na ko≈Ñcu).
}
\end{Zadanie}

\subsection{elektronika ‚Äì uk≈Çady logiczne}

\subsubsection{opis automatu przy pomocy tablicy prawdy}

Jak pamiƒôtamy z zajƒôƒá o sumatorze elektronicy lubiƒÖ opisywaƒá uk≈Çady cyfrowe z u≈ºyciem tablic prawdy. W taki spos√≥b mo≈ºna opisaƒá tak≈ºe dowolny automat sko≈Ñczony.
W tym celu numerujemy (binarnie) stany automatu oraz pobudzenia wywo≈ÇujƒÖce przej≈õcia pomiƒôdzy stanami (elementy alfabetu), numery te bƒôdziemy nazywaƒá wektorami stanu i wektorami wej≈õƒá.
Nastƒôpnie tworzymy tablicƒô prawdy postaci:

\begin{center}\begin{tabular}{c|c|c|c|c|c|c|c||c|c|c|c}
$S_l$ & ... & $S_1$ & $S_0$   &   $I_k$ & ... & $I_1$ & $I_0$   &    $N_l$ & ... & $N_1$ & $N_0$\\
\hline
& & &   &   & & &   &   & & &
\end{tabular}\end{center}

\noindent
gdzie $S_l ... S_1 S_0$ to wektor stanu (czyli $l$ bitowy numer stanu), $I_k ... I_1 I_0$ to wektor wej≈õƒá (czyli $l$ bitowy numer pobudzenia wywo≈ÇujƒÖcego zmianƒô stanu), a $N_l ... N_1 N_0$ to $l$ bitowy numer stanu do kt√≥rego ma przej≈õƒá automat znajdujƒÖcy siƒô w stanie okre≈õlonym w kolumnach $S_l ... S_1 S_0$, pod wp≈Çywem pobudzenia podanego w kolumnach $I_k ... I_1 I_0$.
WadƒÖ takiego opisu jest bardzo szybko rosnƒÖca liczba wierszy w tabeli. Wynosi ona $2^{l+k}$, czyli np. dla 3 stanowego automatu z 2 bitowym wej≈õciem jest ich ju≈º 32.

\subsubsection{realizacja pamiƒôciowa}

Opis taki natomiast umo≈ºliwia bardzo prostƒÖ implementacjƒô w postaci ‚Äû\emph{pamiƒôciowej}‚Äù. U≈ºywajƒÖc $l+k$ kom√≥rek pamiƒôci, adresowanych ciƒÖgiem bitowym $S_l ... S_1 S_0 I_k ... I_1 I_0$, mo≈ºemy w ka≈ºdej z nich przechowywaƒá po prostu numer nastƒôpnego stanu (w zwiƒÖzku z tym muszƒÖ to byƒá co najmniej $l$ bitowe kom√≥rki pamiƒôci). Ideƒô takiej realizacji automatu przedstawia poni≈ºszy schemat:

\begin{center}\begin{tikzpicture}[ ->, >={Stealth[length=8pt,width=6pt]}, semithick ]
	\node[draw, minimum height=6em, minimum width=10em,
		label={[label distance=-.7cm, text depth=3.5ex, rotate=90]right:DANE},
		label={[label distance=-.9cm, text depth=3.5ex, rotate=-90]left:ADRES}
		] (M) {PAMIƒòƒÜ};
	
	\node[invisibleNode, above right = 2.2em and 2em of M] (rt) {};
	\node[invisibleNode, above left = 2.2em and 2em of M] (lt) {};
	\draw (M.0) -| (rt) -- node[below] {$S_l ... S_1 S_0 \quad \leftarrow \quad N_l ... N_1 N_0$} (lt) |- (M.165);
	%\draw (lt) edge[draw, red, ->, to path={|- (\tikztotarget)}] (M.165);
	
	\node[invisibleNode, left = 5em of M.195] (de) {};
	\draw (de) --node[below] {$I_k ... I_1 I_0$} (M.195);
\end{tikzpicture}\end{center}

\begin{ProTip}{Ciekawostka {\Symbola ü§î}}
Pamiƒôƒá o $n$ bitowym rozmiarze pojedynczej kom√≥rki (i szyny danych) oraz o $m$ bitowej przestrzeni adresowej (i nie mniejszej szynie adresowej) stanowi bardzo prostƒÖ realizacjƒô bramki logicznej mogƒÖcej realizowaƒá dowolnƒÖ funkcjƒô logicznƒÖ. Dodatkowo funkcja ta mo≈ºe byƒá programowo zmieniana. W≈Çasno≈õƒá ta jest powszechnie wykorzystywana w wsp√≥≈Çczesnej elektronice i le≈ºy u podstaw dzia≈Çania uk≈Çad√≥w o programowalnej strukturze, takich jak FPGA.
\end{ProTip}

\begin{Zadanie}{\domowe{2}}{zadanie_pamiec_8kB}
Czy pamiƒôƒá o wielko≈õci 8kB, z≈Ço≈ºona z kom√≥rek o wielko≈õci 8bit√≥w (i u≈ºywajƒÖca takiej szeroko≈õci szyny danych), posiadajƒÖca 16 bitowƒÖ szynƒô adresowƒÖ\footnote{
	W przypadku gdy szyna adresowa udostƒôpnia wiƒôkszƒÖ przestrze≈Ñ adresowƒÖ ni≈º rozmiar pamiƒôci, najstarsze bity adresu sƒÖ ignorowane.
	Oznacza to ≈ºe w przypadku tej pamiƒôci odwo≈Çanie do adresu $8{\rm k} + x$ (dok≈Çadnie $8*1024+x$), jest odwo≈Çaniem do adresu $x$.
} umo≈ºliwia realizacjƒô (w przedstawiony powy≈ºej spos√≥b) automatu o 8 stanach i 4 bitowym wej≈õciu? Odpowied≈∫ kr√≥tko uzasadnij.
\end{Zadanie}

\subsubsection{realizacja w postaci funkcji logicznej}

Jak wiemy (z zajƒôƒá o sumatorze) opis uk≈Çadu przy pomocy tablicy prawdy pozwala na jego realizacjƒô z u≈ºyciem standardowych funkcji logicznych (bramek and, or, not, xor). W ten spos√≥b mo≈ºemy tak≈ºe realizowaƒá automaty. Analogicznie jak na powy≈ºszym schemacie realizacji \emph{pamiƒôciowej} bƒôdzie musia≈Ço wystƒÖpiƒá podanie sygna≈Çu z wyj≈õcia bramek na ich wej≈õcie (sprzƒô≈ºenie zwrotne).

Realizacja taka jest bardziej oszczƒôdna pod wzglƒôdem zasob√≥w od realizacji \emph{pamiƒôciowej}, jednak bardziej wymagajƒÖca na etapie projektowania ‚Äì trzeba dokonaƒá konwersji tablicy prawdy na funkcje logiczne. Konwersji takiej dokonujemy niezale≈ºnie dla ka≈ºdego bitu nowego wektora stanu ($N_l ... N_1 N_0$), czyli musimy skonwertowaƒá $l$ tablic prawdy na $l$ funkcji logicznych, ka≈ºda w og√≥lno≈õci\footnote{czƒô≈õƒá argument√≥w mo≈ºe okazaƒá siƒô nieistotna dla obliczania danego $N_x$ ‚Äì nie wp≈Çywaƒá na jego warto≈õƒá} o $l+k$ argumentach.

\begin{Zadanie}{}{automat_rs}
Przyjrzyj siƒô poni≈ºszemu automatowi (y=x oznacza "gdy y ma warto≈õƒá x", ? ‚Äì dowolna warto≈õƒá).
\begin{center}
\begin{adjustbox}{stack=cc}\begin{tikzpicture}[->, >={Stealth[length=8pt,width=6pt]}, node distance=4.3cm, semithick]
\node[circle, minimum size=3em, draw, initial] (0) {0};
\node[circle, minimum size=3em, draw] (1) [right = of 0] {1};
\path (0)  edge [bend left=45] node[above] {r=0 s=1} (1);
\path (1)  edge [bend left=45] node[above] {r=1 s=0} (0);

\path (0)  edge [loop] node[above] {r=? s=0} (0);
\path (1)  edge [loop] node[above] {r=0 s=?} (1);
\end{tikzpicture}\end{adjustbox}
\begin{tabular}{>{\centering}m{1.1cm}|>{\centering}m{1.1cm}|>{\centering}m{1.1cm}||c}
Stan & r & s & Nowy Stan\\
\hline
0 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 1\\
%0 & 1 & 1 & ?\\
1 & 0 & 0 & 1\\
1 & 1 & 0 & 0\\
1 & 0 & 1 & 1\\
%1 & 1 & 1 & ?
\end{tabular}
\end{center}

\begin{enumerate}
\item Czy zauwa≈ºy≈Çe≈õ co≈õ nietypowego?
	\teacher{
		Opis automatu jest niekompletny, nie okre≈õla dzia≈Çania w przypadku r=1 s=1.
		TakƒÖ sytuacjƒô traktujemy jako zabronionƒÖ i nie interesuje nas ona.
		Pozwala to na wiƒôkszƒÖ swobodƒô w konstrukcji automatu i ≈Çatwiejsze odnalezienie wyra≈ºenia go opisujƒÖcego.
	}
\item Spr√≥buj znale≈∫ƒá wyra≈ºenie logiczne realizujƒÖce ten automat.
	\teacher {
		PatrzƒÖc po wierszach dla kt√≥rych ‚ÄûNowy Stan‚Äù ma warto≈õƒá 1 uzyskujemy: \python{s or (Stan and not r)}.
	}
\item Zaimplementuj funkcjƒô realizujƒÖcƒÖ ten automat i u≈ºyj je do wypisania tablicy prawdy, celem weryfikacji poprawno≈õci dzia≈Çania.
\end{enumerate}

\begin{teacherOnly}
\begin{CodeFrame}[python]{0.65\textwidth}
def rs(s, r, q):
	return s or (q and not r)

for q in [0,1]:
  for s in [0,1]:
    for r in [0,1]:
      print(q, r, s, int(rs(s,r,q)))
\end{CodeFrame}
\begin{CodeFrame}[text][escapeinside=@@]{auto}
0 0 0 0
0 1 0 0
0 0 1 1
@\textcolor{xgray}{0 1 1 1}@
1 0 0 1
1 1 0 0
1 0 1 1
@\textcolor{xgray}{1 1 1 1}@
\end{CodeFrame}
\end{teacherOnly}

\begin{teacherOnly}
%\fontspec{lmroman12-regular}[Color=teacherColor]
\textcolor{\FSTop{colors}}{}\color{\FSTop{colors}}
Klasyczna realizacja w elektronice zatrzasku RS (z niezanegowanymi wej≈õciami) sk≈Çada siƒô z dw√≥ch bramek nor (not or):

\begin{center}
\includegraphics[width=0.45\textwidth]{img/elektronika/RS}
\end{center}

Ze wzglƒôdu na skomplikowane sprzƒô≈ºenie zwrotne, wymaga ona dwukrotnego przetworzenia stanu automatu i daje inne wyniki dla zabronionej sytuacji r=1 s=1:

\begin{CodeFrame}[python][]{0.65\textwidth}
def rs2(s, r, q, nq):
	return [not (r or nq), not (s or q)]

def rs(s, r, q):
	q, nq = rs2(s, r, q, not q)
	q, nq = rs2(s, r, q, nq)
	return q

for q in [0,1]:
  for s in [0,1]:
    for r in [0,1]:
      print(q, r, s, int(rs(s,r,q)))
\end{CodeFrame}
\begin{CodeFrame}[text][escapeinside=@@]{auto}
0 0 0 0
0 1 0 0
0 0 1 1
@\textcolor{xgray}{0 1 1 0}@
1 0 0 1
1 1 0 0
1 0 1 1
@\textcolor{xgray}{1 1 1 0}@
\end{CodeFrame}
\end{teacherOnly}
\end{Zadanie}

\subsubsection{asynchroniczne i synchroniczne}

Om√≥wione do tej pory automaty charakteryzowa≈Çy siƒô brakiem jakiegokolwiek mechanizmu ustalania kiedy powinny odczytaƒá stan wektora wej≈õciowego i wykonaƒá zwiƒÖzane z nim przej≈õcia.
Uk≈Çady tego typu (kt√≥re reagujƒÖ na zmiany wej≈õcia zachodzƒÖce w dowolnym momencie) nazywamy asynchronicznymi.

Niestety taka prosta realizacja napotyka kilka problem√≥w:
\begin{itemize}
\item Automat nie uzyskuje ≈ºadnej informacji o tym, i≈º wektor wej≈õciowy jest nowy (podana zosta≈Ça nowa litera analizowanego s≈Çowa).
      W efekcie, je≈ºeli litera $v$ odpowiada za przej≈õcia z A do B i z B do C, to automat na skutek podania jej na wej≈õcie mo≈ºe przeskoczyƒá z A do C zanim zostanie podana inna litera.
      Aby tego uniknƒÖƒá ka≈ºdy wektor wej≈õciowy powodujƒÖcy wej≈õcie do danego stanu powinien powodowaƒá pozostawanie w nim.
\item Zmiana kilku bit√≥w wektora wej≈õciowego praktycznie nigdy nie bƒôdzie r√≥wnoczesna.
      W efekcie, je≈ºeli np. jeste≈õmy w stanie A (z kt√≥rego mo≈ºemy przej≈õƒá pod wp≈Çywem $01$ do B, $10$ do C, $11$ do D) i nastƒôpuje zmiana wektora wej≈õciowego z $00$ na $11$ nie mo≈ºemy przewidzieƒá do kt√≥rego stanu przejdziemy (B, C czy mo≈ºe D).
      Aby uniknƒÖƒá negatywnych skutk√≥w takiego dzia≈Çania automat taki powinien ze stan√≥w B i C przechodziƒá do D pod wp≈Çywem wektora $11$.
\end{itemize}

\begin{ProTip}{Ciekawostka {\Symbola ü§î}}
Mianem uk≈Çad√≥w asynchronicznych okre≈õlane mogƒÖ byƒá nie tylko automaty, ale te≈º inne uk≈Çady elektroniczne.
Nie wszystkie z omawianych problem√≥w dotyczƒÖ wszystkich uk≈Çad√≥w asynchronicznych.
Du≈ºa czƒô≈õƒá tych problem√≥w zwiƒÖzana jest z faktem sprzƒô≈ºenia zwrotnego, z kt√≥rym mamy do czynienia w konstrukcji automatu.
\end{ProTip}

Pomimo tych utrudnie≈Ñ w konstrukcji automaty asynchroniczne sƒÖ spotykane w praktyce (zauwa≈º, ≈ºe wcze≈õniej tak≈ºe skonstruowali≈õmy poprawny automat asynchroniczny ‚Äì przerzutnik RS).
Jednak ze wzglƒôdu na te problemy du≈ºo czƒô≈õciej stosowane sƒÖ automaty synchroniczne.

W automatach synchronicznych wystƒôpuje dodatkowy sygna≈Ç zegarowy, s≈Çu≈ºƒÖcy do synchronizacji odczytu wej≈õƒá i wykonywania przej≈õƒá.
Mo≈ºna powiedzieƒá, ≈ºe informuje on o tym, i≈º na wej≈õciu przygotowana zosta≈Ça kolejna litera analizowanego s≈Çowa i mo≈ºna wykonaƒá zwiƒÖzanƒÖ z niƒÖ zmianƒô stanu automatu.

\begin{ProTip}{Ciekawostka {\Symbola ü§î}}
W naturalny spos√≥b prowadzi to do stosowania w realizacji automat√≥w synchronicznych, jako kom√≥rek pamiƒôtajƒÖcych poszczeg√≥lne bity wektora stanu przerzutnik√≥w typu D.
Przerzutniki te zapamiƒôtujƒÖ podawanƒÖ na nie informacjƒô w momencie narastajƒÖcego bƒÖd≈∫ opadajƒÖcego zbocza zegara i przechowujƒÖ jƒÖ (oraz wystawiajƒÖ na swoim wyj≈õciu) do nadej≈õcia kolejnego zbocza.
Ze wzglƒôdu na spos√≥b dzia≈Çania pamiƒôci, implementacje automat√≥w oparte na niej na og√≥≈Ç w naturalny spos√≥b sƒÖ automatami synchronicznymi ‚Äì funkcjƒô zegara pe≈ÇniƒÖ sygna≈Çy sterujƒÖce wykonaniem operacji odczytu.
\end{ProTip}

Zwr√≥ƒá uwagƒô, i≈º nasze implementacje automat√≥w w Pythonie sƒÖ du≈ºo bli≈ºsze automatom synchronicznym ni≈º asynachronicznym ‚Äì nie mamy typowego okresowego sygna≈Çu zegarowego, ale jego funcjƒô pe≈Çni zatwierdzenie wprowadzonych danych przy pomocy znaku nowej linii w \python{readline()}, bƒÖd≈∫ jawne wywo≈Çanie funkcji.


\subsubsection{automaty Moore'a i Mealy'ego}

W praktycznych zastosowaniach chcemy aby dzia≈Çanie uk≈Çadu elektronicznego realizujƒÖcego dany automat objawia≈Ço siƒô nie tylko zmianƒÖ stan√≥w wewnƒôtrznych automatu, ale przede wszystkim zmianƒÖ stan√≥w jaki≈õ wyj≈õƒá.
Mo≈ºna zostaƒá to zrealizowane na jeden z dw√≥ch sposob√≥w:
\begin{itemize}
\item Mo≈ºemy ≈õci≈õle powiƒÖzaƒá stan wyj≈õcia z stanem w kt√≥rym siƒô znajduje automat.
      W tym celu ustalamy funkcjƒô logicznƒÖ przekszta≈ÇcajƒÖcƒÖ wektor stanu na stan wyj≈õƒá z nim zwiƒÖzany (wektor wyj≈õciowy).
      Ten typ automatu okre≈õlamy mianem automatu Moore'a.
      W niekt√≥rych przypadkach mo≈ºliwe jest takie zakodowanie automatu w taki spos√≥b aby wektor stanu lub jego fragment stanowi≈Ç bezpo≈õrednio wektor wyj≈õciowy (lub jego fragment).
      Je≈ºeli automat realizujemy w postaci \emph{pamiƒôciowej} to wektor wyj≈õciowy mo≈ºe byƒá przechowywany w tych samych kom√≥rkach pamiƒôci co wektor stanu.
\item Alternatywnie przy ustalaniu warto≈õci wyj≈õƒá opr√≥cz bie≈ºƒÖcego stanu automatu mo≈ºemy tak≈ºe uwzglƒôdniaƒá warto≈õƒá wej≈õƒá (pobudzenia, kt√≥re spowodowa≈Ço ostatnie przej≈õcie).
      Ten typ automatu okre≈õlamy mianem automatu Mealy'ego.
      Czƒôsto pozwala on na zmniejszenie ilo≈õci stan√≥w automatu, kosztem bardziej rozbudowanej logiki wyj≈õciowej.
\end{itemize}

\begin{Zadanie}[breakable]{}{zadanie_konczace_ab_pamieciowy}
Przypomnij sobie automat akceptujƒÖcy s≈Çowa ko≈ÑczƒÖce siƒô na ab z zadania \ref{zadanie_konczace_ab}.
Dodaj do tego automatu jedno bitowe wyj≈õcie informujƒÖce o tym ≈ºe aktualnie wprowadzone s≈Çowo zosta≈Ço zaakceptowane.
Mo≈ºesz w tym celu wybraƒá rozwiƒÖzanie automatu Moore'a albo Mealy'ego. Wyb√≥r kr√≥tko uzasadnij.
Zapisz tablicƒô prawdy dla tego automatu i zasymuluj jego dzia≈Çanie w postaci pamiƒôciowej.

\emph{Wskaz√≥wka: do zasymulowania pamiƒôci mo≈ºesz u≈ºyƒá s≈Çownika w kt√≥rym kluczami sƒÖ sta≈Çe listy\footnote{
	Sta≈ÇƒÖ listƒô (nazywanƒÖ \emph{krotkƒÖ}) zapisujemy u≈ºywajƒÖc nawias√≥w okrƒÖg≈Çych zamiast kwadratowych, np. \Verb{(1, 2, 3)}. Mo≈ºemy konwertowaƒá zwyk≈Çe listy na krotki przy pomocy \Verb{tuple()} i krotki na listy przy pomocy \Verb{list()}
} reprezentujƒÖce wektor stanu i wektor wej≈õciowy, a warto≈õciami reprezentujƒÖ nowy wektor stanu.}
\end{Zadanie}

\begin{Zadanie}[breakable]{\domowe{1}}{zadanie_rs_pamieciowy}
Zaimplementuj automat z zadania \ref{automat_rs} w postaci pamiƒôciowej, jako automat z jednobitowym wyj≈õciem. Mo≈ºesz w tym celu wybraƒá rozwiƒÖzanie automatu Moore'a albo Mealy'ego. Wyb√≥r kr√≥tko uzasadnij.
\end{Zadanie}


\subsubsection{realizacja w postaci uk≈Çadu mikro-programowalnego {\Symbola ü§î}}

Jeszcze innym podej≈õciem do realizacji automatu w oparciu o pamiƒôƒá jest uk≈Çad mikro-programowalny. Jego dzia≈Çanie opiera siƒô na przechowywaniu w pamiƒôci instrukcji z≈Ço≈ºonych z p√≥l: adresowych, kontrolnych, sterujƒÖcych i operacyjnych.
W oparciu o aktualne dane wej≈õciowe (z \emph{uk≈Çadu operacyjnego}) i aktualny stan (czyli warto≈õƒá tych p√≥l) wystawiane sƒÖ dane wyj≈õciowe (do \emph{uk≈Çadu operacyjnego}) oraz podejmowana jest decyzja o wyborze stanu nastƒôpnego.
Poni≈ºej znajduje siƒô przyk≈Çadowy schemat dzia≈Çania uk≈Çadu mikro-programowalnego.

\begin{center}\begin{adjustbox}{scale=.95}\begin{tikzpicture}[semithick, node distance=0.9cm]
	\tikzstyle{hor}=[rectangle, draw, minimum height=2.5em, minimum width=9em]
	\tikzstyle{vert}=[rectangle, draw, minimum height=2.5em, minimum width=9em, rotate=90]
	\tikzstyle{memory}=[rectangle, draw, minimum height=2.5em, anchor=north west, minimum width=24em, outer sep = 0pt]
	\tikzstyle{subMem}=[rectangle, draw, minimum height=1.7em, anchor=north west, minimum width=6em, outer sep = 0pt]
	\tikzstyle{da1}=[arrowDouble=8pt colored by black, rounded corners=5pt]
	\tikzstyle{da2}=[arrowInner=8pt colored by white and scale by 2pt, rounded corners=5pt]
	\tikzstyle{sa}=[draw, ->, >={Stealth[length=8pt,width=6pt]}]
	\tikzstyle{ssa}=[arrowOuter=7pt colored by xgray, rounded corners=5pt]
	
	\node[hor] (SUM)                      {\LARGE$\Sigma$};
	\node[hor, text depth=2.2ex] (MUX1)  [below = of SUM]   {MUX1};
		\draw[-] (MUX1.north west) -- (MUX1.-90); \draw[-] (MUX1.north east) -- (MUX1.-90);
	\node[hor] (COUNT) [below = of MUX1]  {Licznik};
	\node[memory] (MEM)   [below = of COUNT] {Pamiƒôƒá};
		\node[subMem] (MEM_A) [] at (MEM.south west)   {adresowe};
		\node[subMem] (MEM_K) [] at (MEM_A.north east) {kontrolne};
		\node[subMem] (MEM_S) [] at (MEM_K.north east) {sterujƒÖce};
		\node[subMem] (MEM_O) [] at (MEM_S.north east) {operacyjne};
	
	\node[vert, text depth=2.2ex] (MUX2)  [below = 1.3cm of MEM_K, anchor=east]   {MUX2};
		\draw[-] (MUX2.north west) -- (MUX2.-90); \draw[-] (MUX2.north east) -- (MUX2.-90);
	\node[rectangle, draw, align=left, minimum height=7em, minimum width=6em] (DMI)  [above right = 0.7cm and 2.8cm of MUX2.south, anchor=west]   {Dekoder\\Mikro\\Instrukcji};
	
	% address sum-mem path
	\draw[da1] (SUM) -- (MUX1.90);
	\draw[da1] (MUX1) --  (COUNT.90);
	\draw[da1] (COUNT) -- (MEM.90);
	
	% address count-sum path
	\node[invisibleNode, above = 1.2em of MEM] (addr1) {};
	\node[invisibleNode, above right = 1.2em and 2.0em of MUX1] (addr2) {};
	\node[invisibleNode, above right = 1.2em and 0.0em of SUM] (addr3) {};
	\draw[da1] (addr1) -| (addr2) |- (addr3) -| (SUM.30);
	\draw[da1] (addr2) -| (MUX1.30);
	
	% filling fix
	\draw[da2] (addr1) -| (addr2) |- (addr3) -| (SUM.30);
	\draw[da2] (addr2) -| (MUX1.30);
	\draw[da2] (COUNT) -- (MEM.90);
	\draw[da2] (MUX1) --  (COUNT.90);
	\draw[da2] (SUM) -- (MUX1.90);
	
	% address mem-sum path
	\node[invisibleNode, below left = 1.2em and 0.0em of MEM_A] (addr5) {};
	\node[invisibleNode, above left = 1.2em and 2.0em of MEM_A] (addr6) {};
	\node[invisibleNode, above left = 1.2em and 2.0em of MUX1] (addr7) {};
	\node[invisibleNode, above left = 1.2em and 2.0em of SUM] (addr8) {};
	\draw[da1] (MEM_A.-90) |- (addr5) -| (addr6) |- (addr8) -| (SUM.150);
	\draw[da1] (addr6 |- addr7) -| (MUX1.150);
	
	% filling fix
	\draw[da2] (addr6 |- addr7) -| (MUX1.150);
	\draw[da2] (MEM_A.-90) |- (addr5) -| (addr6) |- (addr8) -| (SUM.150);
	
	% MUX and CONT control signals in
	\node[inner sep=0, minimum size=0, left = 6em of MUX1.180] (lMUX) {};
	\draw[sa] (lMUX) -- node[above] {Addr Sel} (MUX1.180);
	\node[inner sep=0, minimum size=0, left = 6em of COUNT.180] (lCOUNT) {};
	\draw[sa] (lCOUNT) -- node[above] {Load / Inc} (COUNT.180);
	
	% MUX and CONT control signals out
	\node[inner sep=0, minimum size=0, right = 6em of DMI.25]  (ruDMI) {};
	\node[inner sep=0, minimum size=0, right = 6em of DMI.-25] (rdDMI) {};
	\draw[sa] (DMI.25) -- node[above]  {Addr Sel} (ruDMI);
	\draw[sa] (DMI.-25) -- node[above] {Load / Inc} (rdDMI);
	
	% data in, data out
	\node[invisibleNode, align=center, below right = 1.2em and 2.0em of MEM_O, anchor=west] (rbMEM_O) {dane\\wyj≈õciowe};
	\draw[ssa] (MEM_O) |- (rbMEM_O);
	\node[invisibleNode, align=center, left = 4.5em of MUX2.90] (lMUX2) {dane\\wej≈õciowe};
	\draw[ssa] (lMUX2) -- (MUX2);
	
	% other control signals
	\draw[sa] (MEM_K) -- (MUX2);
	\node[invisibleNode, below = 0.7cm of DMI.west] (DMIb) {};
	\draw[sa] (MUX2) -- (DMIb);
	\draw[sa] (MEM_S) |- (DMI.160);
\end{tikzpicture}\end{adjustbox}\end{center}

\vspace{-6pt}\noindent
W przedstawionym uk≈Çadzie:
\begin{enumerate}
\item MUX2 dokonuje selekcji informacji wej≈õciowych w oparciu o zawarto≈õƒá pola kontrolnego.
\item Dekoder Mikro Instrukcji steruje MUX1 (sygna≈Ç \textit{Addr Sel}) i licznikiem (sygna≈Ç \textit{Load / Inc}) w oparciu o dane przekazane przez MUX2 i zawarto≈õƒá pola sterujƒÖcego (zawierajƒÖcƒÖ informacje o typie instrukcji), w ten spos√≥b podejmuje on decyzjƒô odno≈õnie wyboru nastƒôpnego stanu automatu.
\item Licznik w zale≈ºno≈õci od sygna≈Çu \textit{Load / Inc} zwiƒôksza adres (numer) obecnego stanu (w rezultacie czego automat przechodzi do stanu nastƒôpnego) lub ≈Çaduje adres z multiplexera MUX1.
\item Multiplexer MUX1 w zale≈ºno≈õci od sygna≈Çu \textit{Addr Sel} wystawia do licznika:
	\begin{itemize}
		\item warto≈õƒá pola adresowego (co pozwala na skok bezwzglƒôdny do innego stanu),
		\item warto≈õƒá aktualnego stanu licznika (co pozwala na pozostanie w obecnym stanie),
		\item sumƒô tych warto≈õci (co pozwala na skok wzglƒôdny do innego stanu).
	\end{itemize}
\item Pole operacyjne u≈ºywane jest jako warto≈õƒá wyj≈õcia, je≈ºeli realizowany jest automat typu Mealy'ego to w celu ustalenia w≈Ça≈õciwego stanu wyj≈õƒá mo≈ºe zostaƒá funkcja logiczna na tych danych i danych wej≈õciowych
\end{enumerate}

Zauwa≈º, ≈ºe model ten nak≈Çada pewne ograniczenia na implementowany automat ‚Äì w ka≈ºdym stanie mamy ograniczony zbi√≥r przej≈õƒá kt√≥re mo≈ºemy wykonaƒá, zazwyczaj sƒÖ to: pozostanie w aktualnym stanie, przej≈õcie do stanu nastƒôpnego, skok bezwarunkowy lub warunkowy do innego stanu (numer stanu do kt√≥rego przechodzimy lub warto≈õƒá skoku sƒÖ na og√≥≈Ç na sta≈Çe powiƒÖzane z obecnym stanem).

\begin{Zadanie}{ {\Symbola ü§î}}{zadanie_konczace_ab_mikroprogramowalny}
Zaimplementuj automat z zadania \ref{zadanie_konczace_ab} w postaci uk≈Çadu mikro-programowalnego
\end{Zadanie}

\section{Automaty ze stosem}

Najpowszechniejszym zastosowaniem automat√≥w ze stosem sƒÖ r√≥≈ºnego rodzaju analizatory sk≈Çadniowe (parsery), mogƒÖ one tak≈ºe pos≈Çu≈ºyƒá np. do obliczania warto≈õci wyra≈ºe≈Ñ artmetycznych.

Wyra≈ºenia arytmetyczne zazwyczaj zapisujemy w postaci infixowej, czyli z operatorem pomiƒôdzy argumentami ($2 + 3 * 5$). Taka notacja wymaga wiedzy o priorytetach poszczeg√≥lnych operator√≥w oraz stosowania nawias√≥w celem wymuszenia innej ni≈º standardowa kolejno≈õci wykonywania dzia≈Ça≈Ñ.

Je≈ºeli spojrzeƒá na operacje arytmetyczne jako na dwuargumentowe funkcje mogliby≈õmy wyra≈ºenia zapisywaƒá jako zagnie≈ºd≈ºony ciƒÖg wywo≈Ça≈Ñ funkcji: $+(2, *(3, 5))$. Zauwa≈º, ≈ºe zapis taki dodatkowo tak≈ºe jednoznacznie okre≈õla kolejno≈õƒá wykonywania operacji.

Obydwie te notacje umo≈ºliwiajƒÖ stworzenie automatu ze stosem obliczajƒÖcego warto≈õƒá wyra≈ºenia, jednak w tym drugim wypadku jest to znacznie prostsze. Wystarczy ≈ºeby automat odk≈Çada≈Ç na stos kolejne czytane znaki z wej≈õcia a≈º do napotkania $)$, a nastƒôpnie zdejmowa≈Ç ze stosu argumenty funkcji a≈º do napotkania funkcji kt√≥rƒÖ ma wykonaƒá. Po wykonaniu funkcji automat powinien od≈Ço≈ºyƒá wynik na stos i kontynuowaƒá czytanie s≈Çowa wej≈õciowego.

\begin{Zadanie}{}{oblicz_w_funkcyjnej1}
Napisz program symulujƒÖcy dzia≈Çanie automatu ze stosem obliczajƒÖcego warto≈õci wyra≈ºe≈Ñ w przedstawionej notacji funkcyjnej. Automat powinien obs≈Çugiwaƒá nastƒôpujƒÖce dwuargumentowe funkcje: $+()$, $-()$, $*()$ i $/()$. Dla uproszczenia przyjmij ≈ºe wszystkie liczby w danych wej≈õciowych sƒÖ jednocyfrowe.
\end{Zadanie}

\begin{Zadanie}{}{oblicz_w_funkcyjnej1b}
Zmodyfikuj rozwiƒÖzanie zadania \ref{oblicz_w_funkcyjnej1} tak aby poprawnie obs≈Çugiwaƒá liczby wielocyfrowe.
\end{Zadanie}

Zwr√≥ƒá uwagƒô i≈º przy zastosowaniu tej notacji niekt√≥re (te dla kt√≥rych ma to sens) funkcje mogƒÖ posiadaƒá dowolnƒÖ ilo≈õƒá argument√≥w. Np. zapis $+(*(4,2), /(8,2), 13, +(1,3))$ jest sensowny i jednoznacznie interpretowany.

\begin{Zadanie}[breakable]{}{oblicz_w_funkcyjnej2}
Zmodyfikuj rozwiƒÖzanie zadania \ref{oblicz_w_funkcyjnej1} tak aby funkcje $+()$ i $*()$ mog≈Çy przyjmowaƒá dowolnƒÖ ilo≈õƒá argument√≥w.

\vspace{6pt}

Wskaz√≥wka: Wieloargumentowe operacje dodawania i mno≈ºenia mo≈ºesz uzyskaƒá np. w nastƒôpujƒÖcy spos√≥b (dla argument√≥w w postaci listy w zmiennej \Verb#lista_argumentow#):
\begin{minted}{python}
import functools, operator
wynik_dodawania = functools.reduce(operator.add, lista_argumentow, 0)
wynik_mno≈ºenia = functools.reduce(operator.mul, lista_argumentow, 1)
\end{minted}
\end{Zadanie}


\begin{Zadanie}{}{}
Zastan√≥w siƒô czy mo≈ºemy wyeliminowaƒá tak≈ºe znaki nawias√≥w $($ i $)$ w tym zapisie, gdy nadal chcemy korzystaƒá z automatu ze stosem i:
\begin{enumerate}
\item ka≈ºda funkcja przyjmuje dok≈Çadnie dwa argumenty (jak w zadaniu \ref{oblicz_w_funkcyjnej1})
\item ilo≈õƒá argument√≥w jest zale≈ºna od funkcji, ale sta≈Ça dla danej funkcji
\item wystƒôpujƒÖ funkcje kt√≥re mogƒÖ przyjmowaƒá dowolnƒÖ ilo≈õƒá argument√≥w (jak w zadaniu \ref{oblicz_w_funkcyjnej2})
\end{enumerate}

\begin{teacherOnly}
Nawias otwierajƒÖcy mo≈ºna wyeliminowaƒá ‚Äì ju≈º samo s≈Çowo kluczowe + - / * wystarcza.

W pierwszym przypadku powinno byƒá mo≈ºliwe wyeliminowanie nawiasu zamykajƒÖcego --- stan automatu zale≈ºy od liczby argument√≥w liczbowych, gdy napotkali≈õmy drugi to zwijamy ze stosu i wykonujemy funkcjƒô, przed po≈Ço≈ºeniem wyniku sprawdzamy czy na stosie jest liczba czy funkcja i w zale≈ºno≈õci od tego wiemy czy dokonujemy kolejnego zwiniƒôcia i obliczenia warto≈õci czy wczytujemy kolejne dane z wej≈õcia.

W drugim wypadku wydaje siƒô to niemo≈ºliwe do realizacji w automacie z pojedynczym stosem --- musieliby≈õmy gdzie≈õ pamiƒôtaƒá ile argument√≥w jeszcze potrzebujemy aby m√≥c wywo≈Çaƒá najwy≈ºszƒÖ funkcjƒô ze stosu, jako ≈ºe funkcje sƒÖ zagnie≈ºd≈ºone to potrzebowaliby≈õmy do tego drugi stos.

W trzecim wypadku zapis jest niejednoznaczny {\tt + * 4 2 / 8 2 13} mo≈ºe oznaczaƒá  $(4 * 2) + (8 / 2) + 13$, jak te≈º $(4 * 2 * (8 / 2)) + 13$.

\strong{Zwr√≥ƒá uwagƒô ≈ºe eliminujƒÖc nawiasy i zastƒôpujƒÖc przecinki spacjami uzyskujmy Notacjƒô PolskƒÖ.}
\end{teacherOnly}
\end{Zadanie}

Okazuje siƒô, ≈ºe przy przetwarzaniu tego typu wyra≈ºe≈Ñ z u≈ºyciem automat√≥w wiƒôksze znaczenie ma informacja o tym, ≈ºe w≈Ça≈õnie zako≈Ñczy≈Çy siƒô argumenty jakiej≈õ funkcji, ni≈º informacja ≈ºe siƒô zaczynajƒÖ ‚Äì pozwala to na konstrukcjƒô prostszych automat√≥w.
W zwiƒÖzku z tym czƒôsto stosowana jest Odwrotna Notacja Polska, polegajƒÖca na podawaniu argument√≥w przed operatorem dzia≈Çania (funkcjƒÖ). Np. {\tt 2 3 5 * +} oznacza $3*5 + 2$. Wyra≈ºenia takie mogƒÖ byƒá ≈Çatwo obliczane z u≈ºyciem automatu ze stosem, kt√≥ry pobiera dane z wej≈õcia i odk≈Çada je na stos do momentu napotkania operatora, wtedy zdejmuje ze stosu wymaganƒÖ przez niego liczbƒô argument√≥w i odk≈Çada na stos wynik dzia≈Çania, a nastƒôpnie kontynuuje pobieranie danych z wej≈õcia.

% wygodnie mieƒá w danych explicite znacznik informujƒÖcy o ko≈Ñcu argument√≥w funkcji ... => zwalnia nas on z konieczno≈õci pamiƒôtania ile dana funkcja potrzebuje argument√≥w
% {\Symbola ü§î} : zauwa≈º ≈ºe w wiƒôkszo≈õƒá jƒôzyk√≥w programowania te≈º oczekuje znacznika ko≈Ñca instrukcji w kodzie ...

\begin{Zadanie}{}{oblicz_w_odwrotnej}
Napisz program symulujƒÖcy dzia≈Çanie automatu ze stosem obliczajƒÖcego warto≈õci wyra≈ºe≈Ñ w Odwrotnej Notacji Polskiej. Automat powinien obs≈Çugiwaƒá dwuargumentowe operatory: $+$, $-$, $*$ i $/$.
\end{Zadanie}

\begin{Zadanie}{\domowe{3}}{konwersja_do_odwrotnej}
Automat ze stosem mo≈ºe zostaƒá tak≈ºe u≈ºyty do konwersji standardowej notacji infixowej na OdwrotnƒÖ Notacjƒô PolskƒÖ. Napisz program symulujƒÖcy dzia≈Çanie takiego automatu.
\end{Zadanie}


\section{Maszyna Turinga}

\setcounter{\tcbcounter}{0}

\begin{Zadanie}{ {\Symbola ü§î}}{}
Na \href{https://prezi.com/t5oeo0zsrr60/matematyczna-wieza-babel-8-i-9-jezyki-rozstrzygalne-i-turinga/?utm_campaign=share&token=1c979aac7d3a67db3ed5fc5e446fbcf4102a033e5f9bcda71854414e3fb1c59f&utm_medium=copy}{wyk≈Çadzie o jƒôzykach rozstrzygalnych} w okolicy 26 slajdu przedstawione by≈Ço dzia≈Çanie Maszyny Turinga w roli sumatora dw√≥ch liczb binarnych.

\vspace{0.4cm}

Dzia≈Çanie Maszyny Turinga mo≈ºna zasymulowaƒá w postaci programu komputerowego. W tym celu niesko≈ÑczonƒÖ ta≈õmƒô mo≈ºna zasymulowaƒá z u≈ºyciem listy i funkcji, kt√≥ra dla odwo≈Ça≈Ñ poza listƒÖ odpowiednio jƒÖ rozszerzy wstawiajƒÖc \Verb{'#'}:
\begin{minted}{python}
def get(l, i):
  if i >= len(l):
    l += ['#'] * (i-len(l)+1)
  return l[i]
\end{minted}

\vspace{0.4cm}

Napisz program symulujƒÖcy dzia≈Çanie Maszyny Turinga sumujƒÖcej dwie liczby.
Program dla ta≈õmy wej≈õciowej w postaci listy: \Verb@{'#', 0, 1, '+', 1, 1, '#'}@
powinien zwr√≥ƒá ta≈õmƒô z wynikiem oblicze≈Ñ czyli: \Verb@{'#', A, A, '+', B, B, '=', 1, 0, 1, '#'}@.

\vspace{0.4cm}

Zwr√≥ƒá uwagƒô, i≈º listy zosta≈Çy zapisane w pozornie odwrotnej kolejno≈õci ni≈º na wyk≈Çadzie.
Jest to efektem tego ≈ºe przy takiem zapisie pierwszy element listy jest podawany po lewej,
a naturalne wydaje siƒô podawanie operacji do wykonania na poczƒÖtku niesko≈Ñczonej ta≈õmy.
Zadanie mo≈ºesz rozwiƒÖzaƒá tak≈ºe z odwr√≥conƒÖ kolejno≈õciƒÖ list.
\end{Zadanie}

\ifdefined\inputOnlyContent\else
\rozwiazania

\copyrightFooter{
	¬© Matematyka dla Ciekawych ≈öwiata, 2019.\\
	¬© Robert Ryszard Paciorek <rrp@opcode.eu.org>, 2008-2019.\\
	Kopiowanie, modyfikowanie i redystrybucja dozwolone pod warunkiem zachowania informacji o autorach.
}
\end{document}
\fi

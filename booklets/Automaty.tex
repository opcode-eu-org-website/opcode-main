\documentclass{pdfBooklets}

\title{Laboratorium programistyczne: Zastosowania automatÃ³w}
\author{%
	Projekt ,,Matematyka dla Ciekawych Åšwiata'',\\
	Robert Ryszard Paciorek\\\normalsize\ttfamily <rrp@opcode.eu.org>
}
\date  {2019-05-09}

\makeatletter\hypersetup{
	pdftitle = {\@title}, pdfauthor = {\@author}
}\makeatother


\usepackage{tikz}
\usetikzlibrary{positioning} % for positionig nodes with `right = of X`
\usetikzlibrary{automata} % for initial and accepting nodes in tikzpicture graphs
\usetikzlibrary{arrows.meta, decorations.markings} % for arrows formating in tikzpicture
\usetikzlibrary{shapes} % for elipse nodes

\tikzset{
  arrowOuter/.style args={#1 colored by #2}{
    line width=#1, #2,
    decoration = {markings, mark=at position -0.01pt with \arrow{Kite[length=(#1),width=5*(#1)/2,inset=0,#2]}},
    preaction = {decorate}, % put arrow via decoration to prevent move due to shorten
    shorten >= {3*(#1)/4},  % use shorten to cut line inside arrow
  },
  arrowInner/.style args={#1 colored by #2 and scale by #3}{
    line width=#1-4*#3/3, #2,
    decoration = {markings, mark=at position -7*#3/8 with \arrow{Kite[length=(#1-3*#3/2),width=5*(#1-3*#3/2)/2,inset=0,#2]}},
    preaction = {decorate}, % put arrow via decoration to prevent move due to shorten
    shorten >= {3*(#1)/4 - #3/4},  % use shorten to cut line inside arrow
  },
  arrowDouble/.style args={#1 colored by #2}{
    double, line width=#1/6, double distance=2*#1/3, #2,
    decoration = {markings, mark=at position -0.01pt with \arrow{Kite[length=(#1),width=5*(#1)/2,inset=0,line width=11*#1/60,open,#2]}},
    preaction = {decorate}, % put arrow via decoration to prevent move due to shorten
    shorten >= {49*#1/60 - 0.015pt},  % use shorten to cut line inside arrow
    %postaction = {draw, line width=2*#1/3, green, shorten >= {3*(#1)/4}}
  },
  invisibleNode/.style={inner sep=0, outer sep = 0pt, minimum size=0},
}

\definecolor{xgreen}{rgb}{0.0,0.55,0.0}
\definecolor{xgray}{rgb}{0.45,0.45,0.45}

\begin{document}

\maketitle

\section{Automaty skoÅ„czone}

JuÅ¼ najprostszy z poznanych typÃ³w automatÃ³w, czyli automat skoÅ„czony, znajduje szerokie zastosowania praktyczne m.in. w informatyce i elektronice. Model automatu uÅ¼ywany jest m.in. do opisu dziaÅ‚ania niektÃ³rych protokoÅ‚Ã³w komunikacyjnych, czy teÅ¼ algorytmÃ³w postÄ™powania, a takÅ¼e do opisu i realizacji elektronicznych ukÅ‚adÃ³w logicznych.

\subsection{opisy algorytmÃ³w}
W zastosowaniach informatycznych najczÄ™Å›ciej:
\begin{itemize}
\item przejÅ›cia zwiÄ…zane sÄ… z reakcjÄ… na dziaÅ‚ania uÅ¼ytkownika lub klienta
\item wykonaniu przejÅ›cia do nowego stanu towarzyszy teÅ¼ wykonanie jakiejÅ› akcji (np. wysÅ‚anie odpowiedzi do klienta, zapamiÄ™tanie jakiÅ› dodatkowych informacji)
\item stan automatu zwiÄ…zany jest z stanem wewnÄ™trznym realizowanego algorytmu
\end{itemize}

\subsubsection{Typowe sposoby implementacji automatÃ³w}


Najbardziej klasycznym przykÅ‚adem implementacji algorytmu w postaci automatu jest (zazwyczaj nieskoÅ„czona) pÄ™tla w ramach ktÃ³rej:

\noindent\begin{minipage}[t]{0.61\textwidth}
\begin{itemize}
\item wczytujemy kolejne porcje danych odpowiedzialne za wywoÅ‚ywanie kolejnych przejÅ›Ä‡ pomiÄ™dzy stanami automatu,
\item z uÅ¼yciem instrukcji warunkowej {\tt if / else} (lub nie wystÄ™pujÄ…cej w Pythonie instrukcji wyboru {\tt switch / case}) w oparciu o aktualny stan automatu wybieramy stosowne postÄ™powanie,
\item w wyniku wykonanych operacji ustalamy nowy stan automatu.
\end{itemize}
\end{minipage}\hfill\begin{minipage}[t]{0.35\textwidth}
\vspace{-8pt}
\begin{minted}{python}
while True:
    x = pobierzDane()
    if stan == "A":
        stan = dzialaniaA(x)
    elif  stan == "B":
        stan = dzialaniaB(x)
    ...
\end{minted}
\end{minipage}

\begin{Zadanie}{}{zadanie_konczace_ab}
Zaimplementuj automat sprawdzajÄ…cy czy podane sÅ‚owo naleÅ¼y do jÄ™zyka nad alfabetem sÅ‚Ã³w koÅ„czÄ…cych siÄ™ ciÄ…giem \Verb{ab}:

\vspace{-0.5cm}\begin{center}\begin{tikzpicture}[->, >={Stealth[length=8pt,width=6pt]}, node distance=2.8cm, semithick]
\node[circle, draw, initial] (0) {0};
\node[circle, draw] (A) [right = of 0] {1};
\node[circle, draw, accepting] (AB) [right = of A] {2};
\path (0)  edge [bend left=45] node[above] {a} (A);
\path (0)  edge [loop] node[above] {b} (0);
\path (A)  edge [bend left=45] node[above] {b} (AB);
\path (A)  edge [loop] node[above] {a} (A);
\path (AB) edge [bend left=45] node[above] {a} (A);
\path (AB) edge [bend left=45] node[above] {b} (0);
\end{tikzpicture}\end{center}\vspace{-0.5cm}

\emph{WskazÃ³wka: zamiast \Verb{while True} moÅ¼esz uÅ¼yÄ‡ pÄ™tli iterujÄ…cej po literach sÅ‚owa.}
\end{Zadanie}



\subsubsection{SMTP}

Oficjalna specyfikacja protokoÅ‚u przesyÅ‚u poczty elektronicznej SMTP (Simple Mail Transfer Protocol) czyli \href{https://www.rfc-editor.org/info/rfc821}{RFC 821} nie definiuje tego protokoÅ‚u bezpoÅ›rednio z uÅ¼yciem automatu skoÅ„czonego. Jednak moÅ¼liwe jest opisanie go w taki sposÃ³b. PoniÅ¼ej znajduje siÄ™ graf automatu reprezentujÄ…cy typowÄ… sesjÄ™ protokoÅ‚u SMTP (nie jest to peÅ‚en opis protokoÅ‚u ani jego dziaÅ‚ania - pominiÄ™te zostaÅ‚y niektÃ³re z obowiÄ…zkowych komend protokoÅ‚u oraz zagadnienia weryfikacji).

\vspace{0.5cm}

\begin{adjustbox}{trim=2.95cm 0.7cm 0cm 0cm, clip=false, scale=.95}
\begin{tikzpicture} [ ->, >={Stealth[length=8pt,width=6pt]}, node distance=2.8cm, semithick, initial text={}, ]
	\tikzstyle{stan}=[ellipse, draw]
	\tikzstyle{klient}=[above, align=center, font=\footnotesize\tt\color{blue}]
	\tikzstyle{serwer}=[below, align=center, font=\footnotesize\tt\color{xgreen}]
	
	\node[stan, initial] (S0) {IDLE};
	\node[stan] (S2) [right = 2.5cm of S0] {C};
	\node[stan] (H)  [right = of S2] {HA};
	\node[stan] (MF) [right = 3.1cm of H]  {SA};
	\node[stan] (RT) [right = 3.1cm of MF] {RA};
	\node[stan] (DATA) [below = of RT] {DATA};
	
	\path
		(S2)
			edge[out=-90, in=-130, looseness=0.65]
				node[klient, pos=0.45] {QUIT}
				node[serwer, pos=0.45] {221 ... \textit{zamkniÄ™cie poÅ‚.}}
				(S0)
		(H)
			edge[out=-110, in=-130, looseness=0.9]
				node[klient] {QUIT}
				node[serwer] {221 ... \textit{zamkniÄ™cie poÅ‚.}}
				(S0)
		(MF)
			edge[out=-90, in=-130, looseness=1]
				node[klient] {QUIT}
				node[serwer] {221 ... \textit{zamkniÄ™cie poÅ‚.}}
				(S0)
		(RT)
			edge[out=-110, in=-130, looseness=1]
				node[klient] {QUIT}
				node[serwer] {221 ... \textit{zamkniÄ™cie poÅ‚.}}
				(S0)
		;
	\path
		(S0)
			edge
				node[klient] {\itshape nawiÄ…zanie\\\itshape poÅ‚Ä…czenia}
				node[serwer] {220 ...}
				(S2)
		(S2)
			edge
				node[klient] {HELLO ...}
				node[serwer] {250 ...}
				(H)
		(H)
			edge[loop, out=30, in=150, looseness=7]
				node[klient] {...}
				node[serwer] {500 ...}
				(H)
			edge[loop, out=30, in=150, looseness=16]
				node[klient] {RCPT TO: ... \\ DATA}
				node[serwer] {503 ...}
				(H)
			edge
				node[klient] {MAIL FROM: ...}
				node[serwer] {250 ...}
				(MF)
		(MF)
			edge[loop, out=30, in=150, looseness=7]
				node[klient] {...}
				node[serwer] {500 ...}
				(MF)
			edge[loop, out=30, in=150, looseness=16]
				node[klient] {DATA}
				node[serwer] {503 ...}
				(MF)
			edge
				node[klient] {RCPT TO: ...}
				node[serwer] {250 ...}
				(RT)
			edge[out=-110, in=-70, looseness=0.7]
				node[klient] {RSET}
				node[serwer] {250 ...}
				(H)
		(RT)
			edge[loop, out=30, in=150, looseness=7]
				node[klient] {...}
				node[serwer] {500 ...}
				(RT)
			edge[loop, out=30, in=150, looseness=16]
				node[klient] {RCPT TO: ...}
				node[serwer] {250 ...}
				(RT)
			edge[out=-40, in=90]
				node[klient,sloped] {DATA ...}
				node[serwer,sloped] {250 ...}
				(DATA)
			edge[out=-110, in=-70]
				node[klient] {RSET}
				node[serwer] {250 ...}
				(H)
		(DATA)
			edge[loop, out=-20, in=-90, looseness=3]
				node[klient] {...}
				(DATA)
			edge[out=-150, in=-90]
				node[klient, pos=0.25] {\itshape pojedyncza\\\itshape kropka w linii}
				node[serwer, pos=0.25] {250 ...}
				(H)
	;
\end{tikzpicture}
\end{adjustbox}

\noindent
PoszczegÃ³lne stany oznaczajÄ…:
\begin{itemize}
\item IDLE -- oczekiwanie na poÅ‚Ä…czenie
\item C -- nawiÄ…zane poÅ‚Ä…czenie w warstwie niÅ¼szej (TCP)
\item HA -- otrzymano i zapamiÄ™tano informacjÄ™ o adresie klienta przekazanym w HELO (jest to nazwa hosta lub nazwa domenowa, ale nie adres poczty)
\item SA -- otrzymano i zapamiÄ™tano informacjÄ™ o adresie e-mail nadawcy
\item RA -- otrzymano i zapamiÄ™tano informacjÄ™ o adresach e-mail odbiorcÃ³w (kolejne wejÅ›cia do tego stanu powodujÄ… dodanie kolejnego odbiorcy do listy)
\item DATA -- odbieranie treÅ›ci maila (zakoÅ„czenie przy pomocy linii zÅ‚oÅ¼onej wyÅ‚Ä…cznie z kropki, skutkuje zakolejkowaniem listu do wysyÅ‚ki lub jego wysÅ‚aniem)
\end{itemize}

\noindent
PowyÅ¼ej strzaÅ‚ek reprezentujÄ…cych przejÅ›cia pomiÄ™dzy stanami (kolor niebieski) podane zostaÅ‚y dziaÅ‚ania i polecenia wysyÅ‚ane przez klienta wywoÅ‚ujÄ…ce dane przejÅ›cie, zaÅ› poniÅ¼ej (kolor zielony) podane zostaÅ‚y odpowiedzi serwera.
W miejscu {\tt ...} wystÄ™puje tekst stanowiÄ…cy dane (np. adres nadawcy lub odbiorcy), komunikat zwiÄ…zany z podanym kodem odpowiedzi lub dowolnÄ…, innÄ… od wymienionych komendÄ™.
Zapis przykÅ‚adowej sesji protokoÅ‚u SMTP opisywanej powyÅ¼szym automatem:

{\vspace{0.3cm}\noindent\tt
  Â \hspace{1cm}\color{xgreen}220 dragon.icm.edu.pl ESMTP Exim 4.89 Fri, 26 Apr 2019 13:14:42 +0000
\\Â \hspace{1cm}\color{blue}HELO test.example.com
\\Â \hspace{1cm}\color{xgreen}250 dragon.icm.edu.pl Hello test.example.com [2001:6a0:0:21::60:13]
\\Â \hspace{1cm}\color{blue}MAIL FROM: rrp@dragon.icm.edu.pl
\\Â \hspace{1cm}\color{xgreen}250 OK
\\Â \hspace{1cm}\color{blue}RCPT TO: rrp@dragon.icm.edu.pl
\\Â \hspace{1cm}\color{xgreen}250 Accepted
\\Â \hspace{1cm}\color{blue}DATA
\\Â \hspace{1cm}\color{xgreen}354 Enter message, ending with "." on a line by itself
\\Â \hspace{1cm}\color{blue}to jest e-mail, ale bez standardowych naglowkow ...
\\Â \hspace{1cm}\color{blue}wiec bedzie dziwnie wygladal w programie klienckim ...
\\Â \hspace{1cm}\color{blue}.
\\Â \hspace{1cm}\color{xgreen}250 OK id=1hK0hn-0008FU-OV
\\Â \hspace{1cm}\color{blue}QUIT
\\Â \hspace{1cm}\color{xgreen}221 dragon.icm.edu.pl closing connection
\color{black}\vspace{0.3cm}}

\begin{Zadanie}{\domowe{3}}{zadanie_smtp}
\teacher{\strong{Uwaga:} Pomimo Å¼e zadanie sugerujÄ™ daÄ‡ jako domowe to na zajÄ™ciach warto krÃ³tko omÃ³wiÄ‡ dziaÅ‚anie tego automatu. }
Napisz symulator serwera SMTP w postaci wyÅ¼ej przedstawionego automatu.

\vspace{0.3cm}
\emph{WskazÃ³wka: do wczytywania kolejnych linii w ramach pÄ™tli gÅ‚Ã³wnej automatu moÅ¼esz uÅ¼yÄ‡: \python{linia = sys.stdin.readline().rstrip()}.
                 Wymaga to wczeÅ›niejszego zaimportowania moduÅ‚y sys poprzez: \python{import sys}.\student{\\}
                 DziÄ™ki uÅ¼yciu metody \python{rstrip()} wczytana linia nie bÄ™dzie zawieraÅ‚a koÅ„czÄ…cego jÄ… znaku nowej linii (ani innych biaÅ‚ych znakÃ³w na koÅ„cu).
}
\end{Zadanie}

\subsection{elektronika â€“ ukÅ‚ady logiczne}

\subsubsection{opis automatu przy pomocy tablicy prawdy}

Jak pamiÄ™tamy z zajÄ™Ä‡ o sumatorze elektronicy lubiÄ… opisywaÄ‡ ukÅ‚ady cyfrowe z uÅ¼yciem tablic prawdy. W taki sposÃ³b moÅ¼na opisaÄ‡ takÅ¼e dowolny automat skoÅ„czony.
W tym celu numerujemy (binarnie) stany automatu oraz pobudzenia wywoÅ‚ujÄ…ce przejÅ›cia pomiÄ™dzy stanami (elementy alfabetu), numery te bÄ™dziemy nazywaÄ‡ wektorami stanu i wektorami wejÅ›Ä‡.
NastÄ™pnie tworzymy tablicÄ™ prawdy postaci:

\begin{center}\begin{tabular}{c|c|c|c|c|c|c|c||c|c|c|c}
$S_l$ & ... & $S_1$ & $S_0$   &   $I_k$ & ... & $I_1$ & $I_0$   &    $N_l$ & ... & $N_1$ & $N_0$\\
\hline
& & &   &   & & &   &   & & &
\end{tabular}\end{center}

\noindent
gdzie $S_l ... S_1 S_0$ to wektor stanu (czyli $l$ bitowy numer stanu), $I_k ... I_1 I_0$ to wektor wejÅ›Ä‡ (czyli $l$ bitowy numer pobudzenia wywoÅ‚ujÄ…cego zmianÄ™ stanu), a $N_l ... N_1 N_0$ to $l$ bitowy numer stanu do ktÃ³rego ma przejÅ›Ä‡ automat znajdujÄ…cy siÄ™ w stanie okreÅ›lonym w kolumnach $S_l ... S_1 S_0$, pod wpÅ‚ywem pobudzenia podanego w kolumnach $I_k ... I_1 I_0$.
WadÄ… takiego opisu jest bardzo szybko rosnÄ…ca liczba wierszy w tabeli. Wynosi ona $2^{l+k}$, czyli np. dla 3 stanowego automatu z 2 bitowym wejÅ›ciem jest ich juÅ¼ 32.

\subsubsection{realizacja pamiÄ™ciowa}

Opis taki natomiast umoÅ¼liwia bardzo prostÄ… implementacjÄ™ w postaci â€ž\emph{pamiÄ™ciowej}â€. UÅ¼ywajÄ…c $l+k$ komÃ³rek pamiÄ™ci, adresowanych ciÄ…giem bitowym $S_l ... S_1 S_0 I_k ... I_1 I_0$, moÅ¼emy w kaÅ¼dej z nich przechowywaÄ‡ po prostu numer nastÄ™pnego stanu (w zwiÄ…zku z tym muszÄ… to byÄ‡ co najmniej $l$ bitowe komÃ³rki pamiÄ™ci). IdeÄ™ takiej realizacji automatu przedstawia poniÅ¼szy schemat:

\begin{center}\begin{tikzpicture}[ ->, >={Stealth[length=8pt,width=6pt]}, semithick ]
	\node[draw, minimum height=6em, minimum width=10em,
		label={[label distance=-.7cm, text depth=3.5ex, rotate=90]right:DANE},
		label={[label distance=-.9cm, text depth=3.5ex, rotate=-90]left:ADRES}
		] (M) {PAMIÄ˜Ä†};
	
	\node[invisibleNode, above right = 2.2em and 2em of M] (rt) {};
	\node[invisibleNode, above left = 2.2em and 2em of M] (lt) {};
	\draw (M.0) -| (rt) -- node[below] {$S_l ... S_1 S_0 \quad \leftarrow \quad N_l ... N_1 N_0$} (lt) |- (M.165);
	%\draw (lt) edge[draw, red, ->, to path={|- (\tikztotarget)}] (M.165);
	
	\node[invisibleNode, left = 5em of M.195] (de) {};
	\draw (de) --node[below] {$I_k ... I_1 I_0$} (M.195);
\end{tikzpicture}\end{center}

\begin{ProTip}{Ciekawostka {\Symbola ðŸ¤”}}
PamiÄ™Ä‡ o $n$ bitowym rozmiarze pojedynczej komÃ³rki (i szyny danych) oraz o $m$ bitowej przestrzeni adresowej (i nie mniejszej szynie adresowej) stanowi bardzo prostÄ… realizacjÄ™ bramki logicznej mogÄ…cej realizowaÄ‡ dowolnÄ… funkcjÄ™ logicznÄ…. Dodatkowo funkcja ta moÅ¼e byÄ‡ programowo zmieniana. WÅ‚asnoÅ›Ä‡ ta jest powszechnie wykorzystywana w wspÃ³Å‚czesnej elektronice i leÅ¼y u podstaw dziaÅ‚ania ukÅ‚adÃ³w o programowalnej strukturze, takich jak FPGA.
\end{ProTip}

\begin{Zadanie}{\domowe{2}}{zadanie_pamiec_8kB}
Czy pamiÄ™Ä‡ o wielkoÅ›ci 8kB, zÅ‚oÅ¼ona z komÃ³rek o wielkoÅ›ci 8bitÃ³w (i uÅ¼ywajÄ…ca takiej szerokoÅ›ci szyny danych), posiadajÄ…ca 16 bitowÄ… szynÄ™ adresowÄ…\footnote{
	W przypadku gdy szyna adresowa udostÄ™pnia wiÄ™kszÄ… przestrzeÅ„ adresowÄ… niÅ¼ rozmiar pamiÄ™ci, najstarsze bity adresu sÄ… ignorowane.
	Oznacza to Å¼e w przypadku tej pamiÄ™ci odwoÅ‚anie do adresu $8{\rm k} + x$ (dokÅ‚adnie $8*1024+x$), jest odwoÅ‚aniem do adresu $x$.
} umoÅ¼liwia realizacjÄ™ (w przedstawiony powyÅ¼ej sposÃ³b) automatu o 8 stanach i 4 bitowym wejÅ›ciu? OdpowiedÅº krÃ³tko uzasadnij.
\end{Zadanie}

\subsubsection{realizacja w postaci funkcji logicznej}

Jak wiemy (z zajÄ™Ä‡ o sumatorze) opis ukÅ‚adu przy pomocy tablicy prawdy pozwala na jego realizacjÄ™ z uÅ¼yciem standardowych funkcji logicznych (bramek and, or, not, xor). W ten sposÃ³b moÅ¼emy takÅ¼e realizowaÄ‡ automaty. Analogicznie jak na powyÅ¼szym schemacie realizacji \emph{pamiÄ™ciowej} bÄ™dzie musiaÅ‚o wystÄ…piÄ‡ podanie sygnaÅ‚u z wyjÅ›cia bramek na ich wejÅ›cie (sprzÄ™Å¼enie zwrotne).

Realizacja taka jest bardziej oszczÄ™dna pod wzglÄ™dem zasobÃ³w od realizacji \emph{pamiÄ™ciowej}, jednak bardziej wymagajÄ…ca na etapie projektowania â€“ trzeba dokonaÄ‡ konwersji tablicy prawdy na funkcje logiczne. Konwersji takiej dokonujemy niezaleÅ¼nie dla kaÅ¼dego bitu nowego wektora stanu ($N_l ... N_1 N_0$), czyli musimy skonwertowaÄ‡ $l$ tablic prawdy na $l$ funkcji logicznych, kaÅ¼da w ogÃ³lnoÅ›ci\footnote{czÄ™Å›Ä‡ argumentÃ³w moÅ¼e okazaÄ‡ siÄ™ nieistotna dla obliczania danego $N_x$ â€“ nie wpÅ‚ywaÄ‡ na jego wartoÅ›Ä‡} o $l+k$ argumentach.

\begin{Zadanie}{}{automat_rs}
Przyjrzyj siÄ™ poniÅ¼szemu automatowi (y=x oznacza "gdy y ma wartoÅ›Ä‡ x", ? â€“ dowolna wartoÅ›Ä‡).
\begin{center}
\begin{adjustbox}{stack=cc}\begin{tikzpicture}[->, >={Stealth[length=8pt,width=6pt]}, node distance=4.3cm, semithick]
\node[circle, minimum size=3em, draw, initial] (0) {0};
\node[circle, minimum size=3em, draw] (1) [right = of 0] {1};
\path (0)  edge [bend left=45] node[above] {r=0 s=1} (1);
\path (1)  edge [bend left=45] node[above] {r=1 s=0} (0);

\path (0)  edge [loop] node[above] {r=? s=0} (0);
\path (1)  edge [loop] node[above] {r=0 s=?} (1);
\end{tikzpicture}\end{adjustbox}
\begin{tabular}{>{\centering}m{1.1cm}|>{\centering}m{1.1cm}|>{\centering}m{1.1cm}||c}
Stan & r & s & Nowy Stan\\
\hline
0 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 1\\
%0 & 1 & 1 & ?\\
1 & 0 & 0 & 1\\
1 & 1 & 0 & 0\\
1 & 0 & 1 & 1\\
%1 & 1 & 1 & ?
\end{tabular}
\end{center}

\begin{enumerate}
\item Czy zauwaÅ¼yÅ‚eÅ› coÅ› nietypowego?
	\teacher{
		Opis automatu jest niekompletny, nie okreÅ›la dziaÅ‚ania w przypadku r=1 s=1.
		TakÄ… sytuacjÄ™ traktujemy jako zabronionÄ… i nie interesuje nas ona.
		Pozwala to na wiÄ™kszÄ… swobodÄ™ w konstrukcji automatu i Å‚atwiejsze odnalezienie wyraÅ¼enia go opisujÄ…cego.
	}
\item SprÃ³buj znaleÅºÄ‡ wyraÅ¼enie logiczne realizujÄ…ce ten automat.
	\teacher {
		PatrzÄ…c po wierszach dla ktÃ³rych â€žNowy Stanâ€ ma wartoÅ›Ä‡ 1 uzyskujemy: \python{s or (Stan and not r)}.
	}
\item Zaimplementuj funkcjÄ™ realizujÄ…cÄ… ten automat i uÅ¼yj je do wypisania tablicy prawdy, celem weryfikacji poprawnoÅ›ci dziaÅ‚ania.
\end{enumerate}

\begin{teacherOnly}
\begin{CodeFrame}[python]{0.65\textwidth}
def rs(s, r, q):
	return s or (q and not r)

for q in [0,1]:
  for s in [0,1]:
    for r in [0,1]:
      print(q, r, s, int(rs(s,r,q)))
\end{CodeFrame}
\begin{CodeFrame}[text][escapeinside=@@]{auto}
0 0 0 0
0 1 0 0
0 0 1 1
@\textcolor{xgray}{0 1 1 1}@
1 0 0 1
1 1 0 0
1 0 1 1
@\textcolor{xgray}{1 1 1 1}@
\end{CodeFrame}
\end{teacherOnly}

\begin{teacherOnly}
%\fontspec{lmroman12-regular}[Color=teacherColor]
\textcolor{\FSTop{colors}}{}\color{\FSTop{colors}}
Klasyczna realizacja w elektronice zatrzasku RS (z niezanegowanymi wejÅ›ciami) skÅ‚ada siÄ™ z dwÃ³ch bramek nor (not or):

\begin{center}
\includegraphics[width=0.45\textwidth]{img/elektronika/RS}
\end{center}

Ze wzglÄ™du na skomplikowane sprzÄ™Å¼enie zwrotne, wymaga ona dwukrotnego przetworzenia stanu automatu i daje inne wyniki dla zabronionej sytuacji r=1 s=1:

\begin{CodeFrame}[python][]{0.65\textwidth}
def rs2(s, r, q, nq):
	return [not (r or nq), not (s or q)]

def rs(s, r, q):
	q, nq = rs2(s, r, q, not q)
	q, nq = rs2(s, r, q, nq)
	return q

for q in [0,1]:
  for s in [0,1]:
    for r in [0,1]:
      print(q, r, s, int(rs(s,r,q)))
\end{CodeFrame}
\begin{CodeFrame}[text][escapeinside=@@]{auto}
0 0 0 0
0 1 0 0
0 0 1 1
@\textcolor{xgray}{0 1 1 0}@
1 0 0 1
1 1 0 0
1 0 1 1
@\textcolor{xgray}{1 1 1 0}@
\end{CodeFrame}
\end{teacherOnly}
\end{Zadanie}

\subsubsection{asynchroniczne i synchroniczne}

OmÃ³wione do tej pory automaty charakteryzowaÅ‚y siÄ™ brakiem jakiegokolwiek mechanizmu ustalania kiedy powinny odczytaÄ‡ stan wektora wejÅ›ciowego i wykonaÄ‡ zwiÄ…zane z nim przejÅ›cia.
UkÅ‚ady tego typu (ktÃ³re reagujÄ… na zmiany wejÅ›cia zachodzÄ…ce w dowolnym momencie) nazywamy asynchronicznymi.

Niestety taka prosta realizacja napotyka kilka problemÃ³w:
\begin{itemize}
\item Automat nie uzyskuje Å¼adnej informacji o tym, iÅ¼ wektor wejÅ›ciowy jest nowy (podana zostaÅ‚a nowa litera analizowanego sÅ‚owa).
      W efekcie, jeÅ¼eli litera $v$ odpowiada za przejÅ›cia z A do B i z B do C, to automat na skutek podania jej na wejÅ›cie moÅ¼e przeskoczyÄ‡ z A do C zanim zostanie podana inna litera.
      Aby tego uniknÄ…Ä‡ kaÅ¼dy wektor wejÅ›ciowy powodujÄ…cy wejÅ›cie do danego stanu powinien powodowaÄ‡ pozostawanie w nim.
\item Zmiana kilku bitÃ³w wektora wejÅ›ciowego praktycznie nigdy nie bÄ™dzie rÃ³wnoczesna.
      W efekcie, jeÅ¼eli np. jesteÅ›my w stanie A (z ktÃ³rego moÅ¼emy przejÅ›Ä‡ pod wpÅ‚ywem $01$ do B, $10$ do C, $11$ do D) i nastÄ™puje zmiana wektora wejÅ›ciowego z $00$ na $11$ nie moÅ¼emy przewidzieÄ‡ do ktÃ³rego stanu przejdziemy (B, C czy moÅ¼e D).
      Aby uniknÄ…Ä‡ negatywnych skutkÃ³w takiego dziaÅ‚ania automat taki powinien ze stanÃ³w B i C przechodziÄ‡ do D pod wpÅ‚ywem wektora $11$.
\end{itemize}

\begin{ProTip}{Ciekawostka {\Symbola ðŸ¤”}}
Mianem ukÅ‚adÃ³w asynchronicznych okreÅ›lane mogÄ… byÄ‡ nie tylko automaty, ale teÅ¼ inne ukÅ‚ady elektroniczne.
Nie wszystkie z omawianych problemÃ³w dotyczÄ… wszystkich ukÅ‚adÃ³w asynchronicznych.
DuÅ¼a czÄ™Å›Ä‡ tych problemÃ³w zwiÄ…zana jest z faktem sprzÄ™Å¼enia zwrotnego, z ktÃ³rym mamy do czynienia w konstrukcji automatu.
\end{ProTip}

Pomimo tych utrudnieÅ„ w konstrukcji automaty asynchroniczne sÄ… spotykane w praktyce (zauwaÅ¼, Å¼e wczeÅ›niej takÅ¼e skonstruowaliÅ›my poprawny automat asynchroniczny â€“ przerzutnik RS).
Jednak ze wzglÄ™du na te problemy duÅ¼o czÄ™Å›ciej stosowane sÄ… automaty synchroniczne.

W automatach synchronicznych wystÄ™puje dodatkowy sygnaÅ‚ zegarowy, sÅ‚uÅ¼Ä…cy do synchronizacji odczytu wejÅ›Ä‡ i wykonywania przejÅ›Ä‡.
MoÅ¼na powiedzieÄ‡, Å¼e informuje on o tym, iÅ¼ na wejÅ›ciu przygotowana zostaÅ‚a kolejna litera analizowanego sÅ‚owa i moÅ¼na wykonaÄ‡ zwiÄ…zanÄ… z niÄ… zmianÄ™ stanu automatu.

\begin{ProTip}{Ciekawostka {\Symbola ðŸ¤”}}
W naturalny sposÃ³b prowadzi to do stosowania w realizacji automatÃ³w synchronicznych, jako komÃ³rek pamiÄ™tajÄ…cych poszczegÃ³lne bity wektora stanu przerzutnikÃ³w typu D.
Przerzutniki te zapamiÄ™tujÄ… podawanÄ… na nie informacjÄ™ w momencie narastajÄ…cego bÄ…dÅº opadajÄ…cego zbocza zegara i przechowujÄ… jÄ… (oraz wystawiajÄ… na swoim wyjÅ›ciu) do nadejÅ›cia kolejnego zbocza.
Ze wzglÄ™du na sposÃ³b dziaÅ‚ania pamiÄ™ci, implementacje automatÃ³w oparte na niej na ogÃ³Å‚ w naturalny sposÃ³b sÄ… automatami synchronicznymi â€“ funkcjÄ™ zegara peÅ‚niÄ… sygnaÅ‚y sterujÄ…ce wykonaniem operacji odczytu.
\end{ProTip}

ZwrÃ³Ä‡ uwagÄ™, iÅ¼ nasze implementacje automatÃ³w w Pythonie sÄ… duÅ¼o bliÅ¼sze automatom synchronicznym niÅ¼ asynachronicznym â€“ nie mamy typowego okresowego sygnaÅ‚u zegarowego, ale jego funcjÄ™ peÅ‚ni zatwierdzenie wprowadzonych danych przy pomocy znaku nowej linii w \python{readline()}, bÄ…dÅº jawne wywoÅ‚anie funkcji.


\subsubsection{automaty Moore'a i Mealy'ego}

W praktycznych zastosowaniach chcemy aby dziaÅ‚anie ukÅ‚adu elektronicznego realizujÄ…cego dany automat objawiaÅ‚o siÄ™ nie tylko zmianÄ… stanÃ³w wewnÄ™trznych automatu, ale przede wszystkim zmianÄ… stanÃ³w jakiÅ› wyjÅ›Ä‡.
MoÅ¼na zostaÄ‡ to zrealizowane na jeden z dwÃ³ch sposobÃ³w:
\begin{itemize}
\item MoÅ¼emy Å›ciÅ›le powiÄ…zaÄ‡ stan wyjÅ›cia z stanem w ktÃ³rym siÄ™ znajduje automat.
      W tym celu ustalamy funkcjÄ™ logicznÄ… przeksztaÅ‚cajÄ…cÄ… wektor stanu na stan wyjÅ›Ä‡ z nim zwiÄ…zany (wektor wyjÅ›ciowy).
      Ten typ automatu okreÅ›lamy mianem automatu Moore'a.
      W niektÃ³rych przypadkach moÅ¼liwe jest takie zakodowanie automatu w taki sposÃ³b aby wektor stanu lub jego fragment stanowiÅ‚ bezpoÅ›rednio wektor wyjÅ›ciowy (lub jego fragment).
      JeÅ¼eli automat realizujemy w postaci \emph{pamiÄ™ciowej} to wektor wyjÅ›ciowy moÅ¼e byÄ‡ przechowywany w tych samych komÃ³rkach pamiÄ™ci co wektor stanu.
\item Alternatywnie przy ustalaniu wartoÅ›ci wyjÅ›Ä‡ oprÃ³cz bieÅ¼Ä…cego stanu automatu moÅ¼emy takÅ¼e uwzglÄ™dniaÄ‡ wartoÅ›Ä‡ wejÅ›Ä‡ (pobudzenia, ktÃ³re spowodowaÅ‚o ostatnie przejÅ›cie).
      Ten typ automatu okreÅ›lamy mianem automatu Mealy'ego.
      CzÄ™sto pozwala on na zmniejszenie iloÅ›ci stanÃ³w automatu, kosztem bardziej rozbudowanej logiki wyjÅ›ciowej.
\end{itemize}

\begin{Zadanie}[breakable]{}{zadanie_konczace_ab_pamieciowy}
Przypomnij sobie automat akceptujÄ…cy sÅ‚owa koÅ„czÄ…ce siÄ™ na ab z zadania \ref{zadanie_konczace_ab}.
Dodaj do tego automatu jedno bitowe wyjÅ›cie informujÄ…ce o tym Å¼e aktualnie wprowadzone sÅ‚owo zostaÅ‚o zaakceptowane.
MoÅ¼esz w tym celu wybraÄ‡ rozwiÄ…zanie automatu Moore'a albo Mealy'ego. WybÃ³r krÃ³tko uzasadnij.
Zapisz tablicÄ™ prawdy dla tego automatu i zasymuluj jego dziaÅ‚anie w postaci pamiÄ™ciowej.

\emph{WskazÃ³wka: do zasymulowania pamiÄ™ci moÅ¼esz uÅ¼yÄ‡ sÅ‚ownika w ktÃ³rym kluczami sÄ… staÅ‚e listy\footnote{
	StaÅ‚Ä… listÄ™ (nazywanÄ… \emph{krotkÄ…}) zapisujemy uÅ¼ywajÄ…c nawiasÃ³w okrÄ…gÅ‚ych zamiast kwadratowych, np. \Verb{(1, 2, 3)}. MoÅ¼emy konwertowaÄ‡ zwykÅ‚e listy na krotki przy pomocy \Verb{tuple()} i krotki na listy przy pomocy \Verb{list()}
} reprezentujÄ…ce wektor stanu i wektor wejÅ›ciowy, a wartoÅ›ciami reprezentujÄ… nowy wektor stanu.}
\end{Zadanie}

\begin{Zadanie}[breakable]{\domowe{1}}{zadanie_rs_pamieciowy}
Zaimplementuj automat z zadania \ref{automat_rs} w postaci pamiÄ™ciowej, jako automat z jednobitowym wyjÅ›ciem. MoÅ¼esz w tym celu wybraÄ‡ rozwiÄ…zanie automatu Moore'a albo Mealy'ego. WybÃ³r krÃ³tko uzasadnij.
\end{Zadanie}


\subsubsection{realizacja w postaci ukÅ‚adu mikro-programowalnego {\Symbola ðŸ¤”}}

Jeszcze innym podejÅ›ciem do realizacji automatu w oparciu o pamiÄ™Ä‡ jest ukÅ‚ad mikro-programowalny. Jego dziaÅ‚anie opiera siÄ™ na przechowywaniu w pamiÄ™ci instrukcji zÅ‚oÅ¼onych z pÃ³l: adresowych, kontrolnych, sterujÄ…cych i operacyjnych.
W oparciu o aktualne dane wejÅ›ciowe (z \emph{ukÅ‚adu operacyjnego}) i aktualny stan (czyli wartoÅ›Ä‡ tych pÃ³l) wystawiane sÄ… dane wyjÅ›ciowe (do \emph{ukÅ‚adu operacyjnego}) oraz podejmowana jest decyzja o wyborze stanu nastÄ™pnego.
PoniÅ¼ej znajduje siÄ™ przykÅ‚adowy schemat dziaÅ‚ania ukÅ‚adu mikro-programowalnego.

\begin{center}\begin{adjustbox}{scale=.95}\begin{tikzpicture}[semithick, node distance=0.9cm]
	\tikzstyle{hor}=[rectangle, draw, minimum height=2.5em, minimum width=9em]
	\tikzstyle{vert}=[rectangle, draw, minimum height=2.5em, minimum width=9em, rotate=90]
	\tikzstyle{memory}=[rectangle, draw, minimum height=2.5em, anchor=north west, minimum width=24em, outer sep = 0pt]
	\tikzstyle{subMem}=[rectangle, draw, minimum height=1.7em, anchor=north west, minimum width=6em, outer sep = 0pt]
	\tikzstyle{da1}=[arrowDouble=8pt colored by black, rounded corners=5pt]
	\tikzstyle{da2}=[arrowInner=8pt colored by white and scale by 2pt, rounded corners=5pt]
	\tikzstyle{sa}=[draw, ->, >={Stealth[length=8pt,width=6pt]}]
	\tikzstyle{ssa}=[arrowOuter=7pt colored by xgray, rounded corners=5pt]
	
	\node[hor] (SUM)                      {\LARGE$\Sigma$};
	\node[hor, text depth=2.2ex] (MUX1)  [below = of SUM]   {MUX1};
		\draw[-] (MUX1.north west) -- (MUX1.-90); \draw[-] (MUX1.north east) -- (MUX1.-90);
	\node[hor] (COUNT) [below = of MUX1]  {Licznik};
	\node[memory] (MEM)   [below = of COUNT] {PamiÄ™Ä‡};
		\node[subMem] (MEM_A) [] at (MEM.south west)   {adresowe};
		\node[subMem] (MEM_K) [] at (MEM_A.north east) {kontrolne};
		\node[subMem] (MEM_S) [] at (MEM_K.north east) {sterujÄ…ce};
		\node[subMem] (MEM_O) [] at (MEM_S.north east) {operacyjne};
	
	\node[vert, text depth=2.2ex] (MUX2)  [below = 1.3cm of MEM_K, anchor=east]   {MUX2};
		\draw[-] (MUX2.north west) -- (MUX2.-90); \draw[-] (MUX2.north east) -- (MUX2.-90);
	\node[rectangle, draw, align=left, minimum height=7em, minimum width=6em] (DMI)  [above right = 0.7cm and 2.8cm of MUX2.south, anchor=west]   {Dekoder\\Mikro\\Instrukcji};
	
	% address sum-mem path
	\draw[da1] (SUM) -- (MUX1.90);
	\draw[da1] (MUX1) --  (COUNT.90);
	\draw[da1] (COUNT) -- (MEM.90);
	
	% address count-sum path
	\node[invisibleNode, above = 1.2em of MEM] (addr1) {};
	\node[invisibleNode, above right = 1.2em and 2.0em of MUX1] (addr2) {};
	\node[invisibleNode, above right = 1.2em and 0.0em of SUM] (addr3) {};
	\draw[da1] (addr1) -| (addr2) |- (addr3) -| (SUM.30);
	\draw[da1] (addr2) -| (MUX1.30);
	
	% filling fix
	\draw[da2] (addr1) -| (addr2) |- (addr3) -| (SUM.30);
	\draw[da2] (addr2) -| (MUX1.30);
	\draw[da2] (COUNT) -- (MEM.90);
	\draw[da2] (MUX1) --  (COUNT.90);
	\draw[da2] (SUM) -- (MUX1.90);
	
	% address mem-sum path
	\node[invisibleNode, below left = 1.2em and 0.0em of MEM_A] (addr5) {};
	\node[invisibleNode, above left = 1.2em and 2.0em of MEM_A] (addr6) {};
	\node[invisibleNode, above left = 1.2em and 2.0em of MUX1] (addr7) {};
	\node[invisibleNode, above left = 1.2em and 2.0em of SUM] (addr8) {};
	\draw[da1] (MEM_A.-90) |- (addr5) -| (addr6) |- (addr8) -| (SUM.150);
	\draw[da1] (addr6 |- addr7) -| (MUX1.150);
	
	% filling fix
	\draw[da2] (addr6 |- addr7) -| (MUX1.150);
	\draw[da2] (MEM_A.-90) |- (addr5) -| (addr6) |- (addr8) -| (SUM.150);
	
	% MUX and CONT control signals in
	\node[inner sep=0, minimum size=0, left = 6em of MUX1.180] (lMUX) {};
	\draw[sa] (lMUX) -- node[above] {Addr Sel} (MUX1.180);
	\node[inner sep=0, minimum size=0, left = 6em of COUNT.180] (lCOUNT) {};
	\draw[sa] (lCOUNT) -- node[above] {Load / Inc} (COUNT.180);
	
	% MUX and CONT control signals out
	\node[inner sep=0, minimum size=0, right = 6em of DMI.25]  (ruDMI) {};
	\node[inner sep=0, minimum size=0, right = 6em of DMI.-25] (rdDMI) {};
	\draw[sa] (DMI.25) -- node[above]  {Addr Sel} (ruDMI);
	\draw[sa] (DMI.-25) -- node[above] {Load / Inc} (rdDMI);
	
	% data in, data out
	\node[invisibleNode, align=center, below right = 1.2em and 2.0em of MEM_O, anchor=west] (rbMEM_O) {dane\\wyjÅ›ciowe};
	\draw[ssa] (MEM_O) |- (rbMEM_O);
	\node[invisibleNode, align=center, left = 4.5em of MUX2.90] (lMUX2) {dane\\wejÅ›ciowe};
	\draw[ssa] (lMUX2) -- (MUX2);
	
	% other control signals
	\draw[sa] (MEM_K) -- (MUX2);
	\node[invisibleNode, below = 0.7cm of DMI.west] (DMIb) {};
	\draw[sa] (MUX2) -- (DMIb);
	\draw[sa] (MEM_S) |- (DMI.160);
\end{tikzpicture}\end{adjustbox}\end{center}

\vspace{-6pt}\noindent
W przedstawionym ukÅ‚adzie:
\begin{enumerate}
\item MUX2 dokonuje selekcji informacji wejÅ›ciowych w oparciu o zawartoÅ›Ä‡ pola kontrolnego.
\item Dekoder Mikro Instrukcji steruje MUX1 (sygnaÅ‚ \textit{Addr Sel}) i licznikiem (sygnaÅ‚ \textit{Load / Inc}) w oparciu o dane przekazane przez MUX2 i zawartoÅ›Ä‡ pola sterujÄ…cego (zawierajÄ…cÄ… informacje o typie instrukcji), w ten sposÃ³b podejmuje on decyzjÄ™ odnoÅ›nie wyboru nastÄ™pnego stanu automatu.
\item Licznik w zaleÅ¼noÅ›ci od sygnaÅ‚u \textit{Load / Inc} zwiÄ™ksza adres (numer) obecnego stanu (w rezultacie czego automat przechodzi do stanu nastÄ™pnego) lub Å‚aduje adres z multiplexera MUX1.
\item Multiplexer MUX1 w zaleÅ¼noÅ›ci od sygnaÅ‚u \textit{Addr Sel} wystawia do licznika:
	\begin{itemize}
		\item wartoÅ›Ä‡ pola adresowego (co pozwala na skok bezwzglÄ™dny do innego stanu),
		\item wartoÅ›Ä‡ aktualnego stanu licznika (co pozwala na pozostanie w obecnym stanie),
		\item sumÄ™ tych wartoÅ›ci (co pozwala na skok wzglÄ™dny do innego stanu).
	\end{itemize}
\item Pole operacyjne uÅ¼ywane jest jako wartoÅ›Ä‡ wyjÅ›cia, jeÅ¼eli realizowany jest automat typu Mealy'ego to w celu ustalenia wÅ‚aÅ›ciwego stanu wyjÅ›Ä‡ moÅ¼e zostaÄ‡ funkcja logiczna na tych danych i danych wejÅ›ciowych
\end{enumerate}

ZauwaÅ¼, Å¼e model ten nakÅ‚ada pewne ograniczenia na implementowany automat â€“ w kaÅ¼dym stanie mamy ograniczony zbiÃ³r przejÅ›Ä‡ ktÃ³re moÅ¼emy wykonaÄ‡, zazwyczaj sÄ… to: pozostanie w aktualnym stanie, przejÅ›cie do stanu nastÄ™pnego, skok bezwarunkowy lub warunkowy do innego stanu (numer stanu do ktÃ³rego przechodzimy lub wartoÅ›Ä‡ skoku sÄ… na ogÃ³Å‚ na staÅ‚e powiÄ…zane z obecnym stanem).

\begin{Zadanie}{ {\Symbola ðŸ¤”}}{zadanie_konczace_ab_mikroprogramowalny}
Zaimplementuj automat z zadania \ref{zadanie_konczace_ab} w postaci ukÅ‚adu mikro-programowalnego
\end{Zadanie}

\section{Automaty ze stosem}

Najpowszechniejszym zastosowaniem automatÃ³w ze stosem sÄ… rÃ³Å¼nego rodzaju analizatory skÅ‚adniowe (parsery), mogÄ… one takÅ¼e posÅ‚uÅ¼yÄ‡ np. do obliczania wartoÅ›ci wyraÅ¼eÅ„ artmetycznych.

WyraÅ¼enia arytmetyczne zazwyczaj zapisujemy w postaci infixowej, czyli z operatorem pomiÄ™dzy argumentami ($2 + 3 * 5$). Taka notacja wymaga wiedzy o priorytetach poszczegÃ³lnych operatorÃ³w oraz stosowania nawiasÃ³w celem wymuszenia innej niÅ¼ standardowa kolejnoÅ›ci wykonywania dziaÅ‚aÅ„.

JeÅ¼eli spojrzeÄ‡ na operacje arytmetyczne jako na dwuargumentowe funkcje moglibyÅ›my wyraÅ¼enia zapisywaÄ‡ jako zagnieÅ¼dÅ¼ony ciÄ…g wywoÅ‚aÅ„ funkcji: $+(2, *(3, 5))$. ZauwaÅ¼, Å¼e zapis taki dodatkowo takÅ¼e jednoznacznie okreÅ›la kolejnoÅ›Ä‡ wykonywania operacji.

Obydwie te notacje umoÅ¼liwiajÄ… stworzenie automatu ze stosem obliczajÄ…cego wartoÅ›Ä‡ wyraÅ¼enia, jednak w tym drugim wypadku jest to znacznie prostsze. Wystarczy Å¼eby automat odkÅ‚adaÅ‚ na stos kolejne czytane znaki z wejÅ›cia aÅ¼ do napotkania $)$, a nastÄ™pnie zdejmowaÅ‚ ze stosu argumenty funkcji aÅ¼ do napotkania funkcji ktÃ³rÄ… ma wykonaÄ‡. Po wykonaniu funkcji automat powinien odÅ‚oÅ¼yÄ‡ wynik na stos i kontynuowaÄ‡ czytanie sÅ‚owa wejÅ›ciowego.

\begin{Zadanie}{}{oblicz_w_funkcyjnej1}
Napisz program symulujÄ…cy dziaÅ‚anie automatu ze stosem obliczajÄ…cego wartoÅ›ci wyraÅ¼eÅ„ w przedstawionej notacji funkcyjnej. Automat powinien obsÅ‚ugiwaÄ‡ nastÄ™pujÄ…ce dwuargumentowe funkcje: $+()$, $-()$, $*()$ i $/()$. Dla uproszczenia przyjmij Å¼e wszystkie liczby w danych wejÅ›ciowych sÄ… jednocyfrowe.
\end{Zadanie}

\begin{Zadanie}{}{oblicz_w_funkcyjnej1b}
Zmodyfikuj rozwiÄ…zanie zadania \ref{oblicz_w_funkcyjnej1} tak aby poprawnie obsÅ‚ugiwaÄ‡ liczby wielocyfrowe.
\end{Zadanie}

ZwrÃ³Ä‡ uwagÄ™ iÅ¼ przy zastosowaniu tej notacji niektÃ³re (te dla ktÃ³rych ma to sens) funkcje mogÄ… posiadaÄ‡ dowolnÄ… iloÅ›Ä‡ argumentÃ³w. Np. zapis $+(*(4,2), /(8,2), 13, +(1,3))$ jest sensowny i jednoznacznie interpretowany.

\begin{Zadanie}[breakable]{}{oblicz_w_funkcyjnej2}
Zmodyfikuj rozwiÄ…zanie zadania \ref{oblicz_w_funkcyjnej1} tak aby funkcje $+()$ i $*()$ mogÅ‚y przyjmowaÄ‡ dowolnÄ… iloÅ›Ä‡ argumentÃ³w.

\vspace{6pt}

WskazÃ³wka: Wieloargumentowe operacje dodawania i mnoÅ¼enia moÅ¼esz uzyskaÄ‡ np. w nastÄ™pujÄ…cy sposÃ³b (dla argumentÃ³w w postaci listy w zmiennej \Verb#lista_argumentow#):
\begin{minted}{python}
import functools, operator
wynik_dodawania = functools.reduce(operator.add, lista_argumentow, 0)
wynik_mnoÅ¼enia = functools.reduce(operator.mul, lista_argumentow, 1)
\end{minted}
\end{Zadanie}


\begin{Zadanie}{}{}
ZastanÃ³w siÄ™ czy moÅ¼emy wyeliminowaÄ‡ takÅ¼e znaki nawiasÃ³w $($ i $)$ w tym zapisie, gdy nadal chcemy korzystaÄ‡ z automatu ze stosem i:
\begin{enumerate}
\item kaÅ¼da funkcja przyjmuje dokÅ‚adnie dwa argumenty (jak w zadaniu \ref{oblicz_w_funkcyjnej1})
\item iloÅ›Ä‡ argumentÃ³w jest zaleÅ¼na od funkcji, ale staÅ‚a dla danej funkcji
\item wystÄ™pujÄ… funkcje ktÃ³re mogÄ… przyjmowaÄ‡ dowolnÄ… iloÅ›Ä‡ argumentÃ³w (jak w zadaniu \ref{oblicz_w_funkcyjnej2})
\end{enumerate}

\begin{teacherOnly}
Nawias otwierajÄ…cy moÅ¼na wyeliminowaÄ‡ â€“ juÅ¼ samo sÅ‚owo kluczowe + - / * wystarcza.

W pierwszym przypadku powinno byÄ‡ moÅ¼liwe wyeliminowanie nawiasu zamykajÄ…cego --- stan automatu zaleÅ¼y od liczby argumentÃ³w liczbowych, gdy napotkaliÅ›my drugi to zwijamy ze stosu i wykonujemy funkcjÄ™, przed poÅ‚oÅ¼eniem wyniku sprawdzamy czy na stosie jest liczba czy funkcja i w zaleÅ¼noÅ›ci od tego wiemy czy dokonujemy kolejnego zwiniÄ™cia i obliczenia wartoÅ›ci czy wczytujemy kolejne dane z wejÅ›cia.

W drugim wypadku wydaje siÄ™ to niemoÅ¼liwe do realizacji w automacie z pojedynczym stosem --- musielibyÅ›my gdzieÅ› pamiÄ™taÄ‡ ile argumentÃ³w jeszcze potrzebujemy aby mÃ³c wywoÅ‚aÄ‡ najwyÅ¼szÄ… funkcjÄ™ ze stosu, jako Å¼e funkcje sÄ… zagnieÅ¼dÅ¼one to potrzebowalibyÅ›my do tego drugi stos.

W trzecim wypadku zapis jest niejednoznaczny {\tt + * 4 2 / 8 2 13} moÅ¼e oznaczaÄ‡  $(4 * 2) + (8 / 2) + 13$, jak teÅ¼ $(4 * 2 * (8 / 2)) + 13$.

\strong{ZwrÃ³Ä‡ uwagÄ™ Å¼e eliminujÄ…c nawiasy i zastÄ™pujÄ…c przecinki spacjami uzyskujmy NotacjÄ™ PolskÄ….}
\end{teacherOnly}
\end{Zadanie}

Okazuje siÄ™, Å¼e przy przetwarzaniu tego typu wyraÅ¼eÅ„ z uÅ¼yciem automatÃ³w wiÄ™ksze znaczenie ma informacja o tym, Å¼e wÅ‚aÅ›nie zakoÅ„czyÅ‚y siÄ™ argumenty jakiejÅ› funkcji, niÅ¼ informacja Å¼e siÄ™ zaczynajÄ… â€“ pozwala to na konstrukcjÄ™ prostszych automatÃ³w.
W zwiÄ…zku z tym czÄ™sto stosowana jest Odwrotna Notacja Polska, polegajÄ…ca na podawaniu argumentÃ³w przed operatorem dziaÅ‚ania (funkcjÄ…). Np. {\tt 2 3 5 * +} oznacza $3*5 + 2$. WyraÅ¼enia takie mogÄ… byÄ‡ Å‚atwo obliczane z uÅ¼yciem automatu ze stosem, ktÃ³ry pobiera dane z wejÅ›cia i odkÅ‚ada je na stos do momentu napotkania operatora, wtedy zdejmuje ze stosu wymaganÄ… przez niego liczbÄ™ argumentÃ³w i odkÅ‚ada na stos wynik dziaÅ‚ania, a nastÄ™pnie kontynuuje pobieranie danych z wejÅ›cia.

% wygodnie mieÄ‡ w danych explicite znacznik informujÄ…cy o koÅ„cu argumentÃ³w funkcji ... => zwalnia nas on z koniecznoÅ›ci pamiÄ™tania ile dana funkcja potrzebuje argumentÃ³w
% {\Symbola ðŸ¤”} : zauwaÅ¼ Å¼e w wiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w programowania teÅ¼ oczekuje znacznika koÅ„ca instrukcji w kodzie ...

\begin{Zadanie}{}{oblicz_w_odwrotnej}
Napisz program symulujÄ…cy dziaÅ‚anie automatu ze stosem obliczajÄ…cego wartoÅ›ci wyraÅ¼eÅ„ w Odwrotnej Notacji Polskiej. Automat powinien obsÅ‚ugiwaÄ‡ dwuargumentowe operatory: $+$, $-$, $*$ i $/$.
\end{Zadanie}

\begin{Zadanie}{\domowe{3}}{konwersja_do_odwrotnej}
Automat ze stosem moÅ¼e zostaÄ‡ takÅ¼e uÅ¼yty do konwersji standardowej notacji infixowej na OdwrotnÄ… NotacjÄ™ PolskÄ…. Napisz program symulujÄ…cy dziaÅ‚anie takiego automatu.
\end{Zadanie}


\section{Maszyna Turinga}

\setcounter{\tcbcounter}{0}

\begin{Zadanie}{ {\Symbola ðŸ¤”}}{}
Na \href{https://prezi.com/t5oeo0zsrr60/matematyczna-wieza-babel-8-i-9-jezyki-rozstrzygalne-i-turinga/?utm_campaign=share&token=1c979aac7d3a67db3ed5fc5e446fbcf4102a033e5f9bcda71854414e3fb1c59f&utm_medium=copy}{wykÅ‚adzie o jÄ™zykach rozstrzygalnych} w okolicy 26 slajdu przedstawione byÅ‚o dziaÅ‚anie Maszyny Turinga w roli sumatora dwÃ³ch liczb binarnych.

\vspace{0.4cm}

DziaÅ‚anie Maszyny Turinga moÅ¼na zasymulowaÄ‡ w postaci programu komputerowego. W tym celu nieskoÅ„czonÄ… taÅ›mÄ™ moÅ¼na zasymulowaÄ‡ z uÅ¼yciem listy i funkcji, ktÃ³ra dla odwoÅ‚aÅ„ poza listÄ… odpowiednio jÄ… rozszerzy wstawiajÄ…c \Verb{'#'}:
\begin{minted}{python}
def get(l, i):
  if i >= len(l):
    l += ['#'] * (i-len(l)+1)
  return l[i]
\end{minted}

\vspace{0.4cm}

Napisz program symulujÄ…cy dziaÅ‚anie Maszyny Turinga sumujÄ…cej dwie liczby.
Program dla taÅ›my wejÅ›ciowej w postaci listy: \Verb@{'#', 0, 1, '+', 1, 1, '#'}@
powinien zwrÃ³Ä‡ taÅ›mÄ™ z wynikiem obliczeÅ„ czyli: \Verb@{'#', A, A, '+', B, B, '=', 1, 0, 1, '#'}@.

\vspace{0.4cm}

ZwrÃ³Ä‡ uwagÄ™, iÅ¼ listy zostaÅ‚y zapisane w pozornie odwrotnej kolejnoÅ›ci niÅ¼ na wykÅ‚adzie.
Jest to efektem tego Å¼e przy takiem zapisie pierwszy element listy jest podawany po lewej,
a naturalne wydaje siÄ™ podawanie operacji do wykonania na poczÄ…tku nieskoÅ„czonej taÅ›my.
Zadanie moÅ¼esz rozwiÄ…zaÄ‡ takÅ¼e z odwrÃ³conÄ… kolejnoÅ›ciÄ… list.
\end{Zadanie}


%  BEGIN: Literatura dodatkowa
\section{GÅ‚Ä™biej w Pythona (cz. 4)}

\subsection{Literatura dodatkowa {\Symbola ðŸ¤”}}

\begin{itemize}
\item \emph{The Python Tutorial} (\url{https://docs.python.org/3/tutorial/}) - oficjalny Tutorial Pythona.
\item \emph{Vademecum informatyki praktycznej} (\url{http://vip.opcode.eu.org/}) - zbiÃ³r materiaÅ‚Ã³w na temat elektroniki i programowania m.in. w Pythonie, wykorzystywany m.in. w edycji VIIIbis MdCÅš.
\item \emph{Biblioteka Riklaunima: Podstawy Pythona} (\url{http://www.python.rk.edu.pl/w/p/podstawy/}).
\item \emph{A Byte of Python} (\url{https://python.swaroopch.com/}).
\item \emph{How to Think Like a Computer Scientist: Learning with Python 3} (\url{http://openbookproject.net/thinkcs/python/english3e/}).
\item \emph{Zanurkuj w Pythonie} (\url{https://pl.wikibooks.org/wiki/Zanurkuj_w_Pythonie}).
\end{itemize}
%  END: Literatura dodatkowa

\rozwiazania

\copyrightFooter{
	Â© Matematyka dla Ciekawych Åšwiata, 2019.\\
	Â© Robert Ryszard Paciorek <rrp@opcode.eu.org>, 2008-2019.\\
	Kopiowanie, modyfikowanie i redystrybucja dozwolone pod warunkiem zachowania informacji o autorach.
}
\end{document}

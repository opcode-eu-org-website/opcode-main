% Copyright (c) 2016-2020 Matematyka dla Ciekawych Åšwiata (http://ciekawi.icm.edu.pl/)
% Copyright (c) 2016-2017 Åukasz Mazurek
% Copyright (c) 2018-2020 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\IfStrEq{\dbEntryID}{}{
	\ifdefined\noExtraInfoMode\else
		\subsection{napisy}
	\fi
	
	\insertZadanie{\currfilepath}{funkcja_wspak}{}
	\insertZadanie{\currfilepath}{funkcja_wyiksuj}{}
	\insertZadanie{\currfilepath}{dekodowanie_utf8_w_base64}{}
	
	\ifdefined\noExtraInfoMode\else
		\subsection{wyraÅ¼enia regularne}
	\fi
	
	\insertZadanie{\currfilepath}{regex_czy_slowo}{}
	\insertZadanie{\currfilepath}{regex_czy_liczba}{}
}


%
% napisy
%

\dbEntryBegin{funkcja_wspak}\if1\dbEntryCheckResults
Napisz funkcjÄ™, ktÃ³ra dla danej listy sÅ‚Ã³w wypisze kaÅ¼de sÅ‚owo z listy wspak. Np. dla listy \python{['Ala', 'ma', 'kota']} funkcja powinna wypisaÄ‡:
\begin{Verbatim}
alA
am
atok
\end{Verbatim}

\textit{
	WskazÃ³wka: Po elementach listy znajdujÄ…cej siÄ™ w zmiennej moÅ¼emy iterowaÄ‡ pÄ™tlÄ… \texttt{for},
	tak jak robiliÅ›my to po literach napisu, czy po elementach listy liczb zapisanej bezpoÅ›rednio w konstrukcji pÄ™tli
	(sprÃ³buj \python{for x in lista:}).
}
\fi

\dbEntryBegin{funkcja_wspak-rozwiazanie}\if1\dbEntryCheckResults
\begin{minted}[frame=single]{python}
def wskap(lista):
  for slowo in lista:
    # w pythonie zamiast poniÅ¼szej pÄ™tli moÅ¼na proÅ›ciej ...
    # ale warto poznaÄ‡ (takÅ¼e) takie rozwiÄ…zanie
    for i in range(len(slowo)):
      print(slowo[-1 - i], end = '')
    print()
\end{minted}
%
Prostszym rozwiÄ…zaniem (nie wymagajÄ…cym jawnego pisania pÄ™tli w pÄ™tli) jest:
\begin{minted}[frame=single]{python}
def wskap(lista):
  for slowo in lista:
    print(slowo[::-1])
\end{minted}
ktÃ³re korzysta z odwrÃ³cenia napisu przy pomocy pobrania wszystkich jego elementÃ³w z krokiem -1 poprzez \python{slowo[::-1]}
\fi


\dbEntryBegin{funkcja_wyiksuj}\if1\dbEntryCheckResults
Napisz funkcjÄ™ \python{wyiksuj(napis)}, ktÃ³ra zwrÃ³ci dany \Verb{napis}, zastÄ™pujÄ…c kaÅ¼dÄ… maÅ‚Ä… literÄ™ przez \Verb{x} i
kaÅ¼dÄ… wielkÄ… literÄ™ przez \Verb{X}, natomiast resztÄ™ znakÃ³w pozostawi bez zmian.
Np. dla napisu \Verb{'Python 3.6.1 (default, Dec 2015, 13:05:11)'} funkcja powinna zwrÃ³ciÄ‡ napis: \Verb{Xxxxxx 3.6.1 (xxxxxxx, Xxx 2015, 13:05:11)}

\teacher{ WskazÃ³wka: Dla kaÅ¼dego znaku uÅ¼yj konstrukcji \python{if}/\python{elif}/\python{else}, aby rozrÃ³Å¼niÄ‡ pomiÄ™dzy trzema przypadkami: maÅ‚e litery, wielkie litery, pozostaÅ‚e znaki. }
\fi
\dbEntryBegin{funkcja_wyiksuj-rozwiazanie}\if1\dbEntryCheckResults
\begin{CodeFrame*}[python]{}
def wyiksuj(napis):
  duzy_alfabet = 'AÄ„BCÄ†DEÄ˜FGHIJKLÅMNÅƒOÃ“PRSÅšTUWYZÅ¹Å»'
  maly_alfabet = 'aÄ…bcÄ‡deÄ™fghijklÅ‚mnÅ„oÃ³prsÅ›tuwyzÅºÅ¼'
  for c in napis:
    if c in duzy_alfabet:
      print('X', end = '')
    elif c in maly_alfabet:
      print('x', end = '')
    else:
      print(c, end = '')
\end{CodeFrame*}

inne rozwiÄ…zanie:

\begin{CodeFrame*}[python]{}
def wyiksuj(napis):
  for c in napis:
    if c.isupper():
      print('X', end = '')
    elif c.islower():
      print('x', end = '')
    else:
      print(c, end = '')
\end{CodeFrame*}

jeszcze inne rozwiÄ…zanie (w tej formie obsÅ‚uguje tylko litery ASCII, ale aktualna wersja zadania to dopuszcza):

\begin{CodeFrame*}[python]{}
def wyiksuj(napis):
  import re
  napis = re.sub("[a-z]", "x", napis)
  return re.sub("[A-Z]", "X", napis)
\end{CodeFrame*}

\noindent ZwrÃ³Ä‡ uwagÄ™ Å¼e:
\begin{itemize}
\item iterowanie po elementach napisu (znakach) z uÅ¼yciem pÄ™tli \python{for}
\item zastosowanie konstrukcji \python{a in b} do sprawdzenia czy element a (w tym wypadku znak) naleÅ¼y do kolekcji b (w tym wypadku napisu, ale mogÅ‚a by to byÄ‡ takÅ¼e np. lista znakÃ³w)
\item zastosowanie metod \python{isupper()} i \python{islower()} w drugim wariancie rozwiÄ…zania, podobne porÃ³wnanie dla znakÃ³w ASCI moÅ¼na Å‚atwo wykonaÄ‡ w oparciu o wartoÅ›Ä‡ numerycznego kodu tego znaku
\item zwiÄ™zÅ‚oÅ›Ä‡ rozwiÄ…zania z uÅ¼yciem wyraÅ¼eÅ„ regularnych
\end{itemize}
\fi


\dbEntryBegin{dekodowanie_utf8_w_base64}\if1\dbEntryCheckResults
Napisz program dekodujÄ…cy napis kodowany w UTF8 zakodowany przy pomocy base64 majÄ…cy postaÄ‡:
\python{b'UHl0aG9uIGplc3QgZmFqbnkg8J+Yjg==\n'}.\\
WskazÃ³wka: dane wejÅ›ciowe funkcji \python{decode()} muszÄ… byÄ‡ typu "bytes", moÅ¼na to uzyskaÄ‡ poprzedzajÄ…c napis prefiksem \Verb{b}, tak jak powyÅ¼ej.
\fi
\dbEntryBegin{dekodowanie_utf8_w_base64-rozwiazanie}\if1\dbEntryCheckResults
\begin{CodeFrame*}[python]{}
import codecs
d = b'UHl0aG9uIGplc3QgZmFqbnkg8J+Yjg==\n'
d = codecs.decode(d, 'base64')
d = d.decode()
print(d)
\end{CodeFrame*}

Zakodowany tekst to: \textcolor{red}{Python jest fajny {\Symbola ğŸ˜}}

\noindent ZwrÃ³Ä‡ uwagÄ™ Å¼e:
\begin{itemize}
\item zdejmowanie kolejnych kodowaÅ„ w kolejnych krokach procedury â€“ w odwrotnej kolejnoÅ›ci niÅ¼ byÅ‚y nakÅ‚adane
\item funkcja \python{codecs.decode} wymaga jako danych wejÅ›ciowych ciÄ…gu bajtowego, i taki ciÄ…g zwraca
\item metoda \python{decode} ciÄ…gu bajtowego zwraca napis powstaÅ‚y przez zdekodowanie tego ciÄ…gu z uÅ¼yciem utf-8
\end{itemize}
\fi



%
% wyraÅ¼enia regularne
%

\dbEntryBegin{regex_czy_slowo}\if1\dbEntryCheckResults
Napisz funkcjÄ™ ktÃ³ra sprawdzi z uÅ¼yciem wyraÅ¼eÅ„ regularnych czy dany napis jest sÅ‚owem (tzn. nie zawiera spacji).
\fi
\dbEntryBegin{regex_czy_slowo-rozwiazanie}\if1\dbEntryCheckResults
\begin{CodeFrame*}[python]{}
import re
def spr(x):
  if re.search("^[^ ]*$", x):
    print(x, "jest sÅ‚owem")
  else:
    print(x, "NIE jest sÅ‚owem")
\end{CodeFrame*}

Zadanie polega przede wszystkim na wymyÅ›leniu odpowiedniego wyraÅ¼enia regularnego.
Ze wzglÄ™du Å¼e funkcja \python{search} dopasowuje dowolny fragment napisu (wymaga aby napis zawieraÅ‚ fragment opisany podanym wyraÅ¼eniem regularnym),
	to nasze wyraÅ¼enie musi rozpoczynaÄ‡ siÄ™ od \Verb#^# konczyÄ‡ siÄ™ \Verb#$#, aby wyraÅ¼enie byÅ‚o dopasowywane do caÅ‚oÅ›ci sprawdzanego napisu.
Zastosowane wyraÅ¼enie wymaga aby napis nie zawieraÅ‚ spacji - wtedy uznajemy go za sÅ‚owo.
\fi

\dbEntryBegin{regex_czy_liczba}\if1\dbEntryCheckResults
Napisz funkcjÄ™ ktÃ³ra sprawdzi z uÅ¼yciem wyraÅ¼eÅ„ regularnych czy dany napis jest liczbÄ… (tzn. jest zÅ‚oÅ¼ony z cyfr i kropki, a na poczÄ…tku moÅ¼e wystÄ…piÄ‡ + albo -).
\fi
\dbEntryBegin{regex_czy_liczba-rozwiazanie}\if1\dbEntryCheckResults
\begin{CodeFrame*}[python]{}
import re
def spr(x):
  if re.search("^[+-]?[0-9]+(.[0-9]+)?$", x):
    print(x, "jest liczbÄ…")
  else:
    print(x, "NIE jest liczbÄ…")
\end{CodeFrame*}
\fi

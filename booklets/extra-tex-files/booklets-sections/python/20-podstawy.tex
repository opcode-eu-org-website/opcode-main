% Copyright (c) 2016-2020 Matematyka dla Ciekawych wiata (http://ciekawi.icm.edu.pl/)
% Copyright (c) 2016-2017 ukasz Mazurek
% Copyright (c) 2018-2020 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\section{Podstawowe elementy skadniowe}

\begin{teacherOnly}
\noindent Dla os贸b zaznajomionych z C/C++:
\begin{itemize}
\item kolejne instrukcje (zamiast rednika) koczy znak nowej linii
\item bloki rozpoczyna dwukropek, a wyznacza je wcicie o danej iloci znak贸w (nie mieszamy tabulator贸w z spacjami)
\item nie ma konstrukcji i++, czy te偶 ++i, jest za to i += 1
\item rednik na kocu instrukcji (linii) nie jest bdem skadniowym (jest ignorowany)
\item warunek if'a w nawiasach nie jest bdem skadniowym (ale po nawiasach musi by dwukropek)
\item nie ma ptli for w stylu C (,,tr贸jinstrukcyjnej''), w Pythonie ptla for zawsze iteruje po elementach jakiej listy
\end{itemize}
\end{teacherOnly}


%  BEGIN: Funkcje
\subsection{Definiowanie wasnych funkcji}

Bardzo czsto bdziemy chcieli m贸c wielokrotnie wykorzysta raz napisany fragment kodu.
W tym celu bdziemy tworzy wasne \emph{funkcje}. Definicja funkcji ma nastpujc posta:

\begin{CodeFrame*}[python]{}
def nazwa_funkcji(argumenty):
  pierwsze_polecenie
  drugie_polecenie
  ...
\end{CodeFrame*}

\noindent
Zwr贸 uwag na kilka rzeczy:
\begin{itemize}
	\item Na kocu pierwszej linijki jest dwukropek.
	\item Druga linijka musi by \emph{wcita}, tzn. rozpoczyna si od spacji, kilku spacji lub znaku tabulacji.
	\item Je偶eli w ramach funkcji chcemy wykona kilka instrukcji musz one mie taki sam poziom wcicia.
	\item ,,Wntrze'' funkcji koczymy wracajc do takiego samego poziomu wcicia na jakim j rozpoczlimy
	      (takiego wcicia jakie miaa linijka z sowem kluczowym \python{def}).
\end{itemize}\vspace{-4pt}
Jest to typowy spos贸b wyznaczania bloku kodu w Pythonie i bdziemy go jeszcze spotyka w innych konstrukcjach (kt贸re poznamy ju偶 niedugo), dlatego szczeg贸lnie wart jest zapamitania.

Gdy umieszczamy inn konstrukcj korzystajc z bloku kodu we wntrzu jakiego innego bloku (np. funkcji), blok tej instrukcji musi by ,,bardziej'' wcity od bloku w kt贸rym jest zawarty,
powr贸t do poziomu wcicia zewntrznego bloku oznacza zakoczenie bloku tej instrukcji i kontynuowanie zewntrznego bloku.

\begin{ProTip}{Porada}
Na funkcj mo偶na patrze jak na nazwany kawaek kodu, kt贸ry mo偶emy wywoa z innego miejsca ze odmiennymi wartociami zmiennych stanowicych jej argumenty.
\end{ProTip}

Polecenie wywoania funkcji ma posta \python{nazwa_funkcji(argumenty)} i mo偶emy napisa je w tym samym pliku, poni偶ej definicji tej funkcji.
Typowo ilo i kolejno argument贸w w definicji, jak i w wywoaniu powinny by takie same.
Je偶eli nasza funkcja nie potrzebuje przyjmowa argument贸w nawiasy okrge w jej definicji i wywoaniu pozostawiamy puste.
Je偶eli potrzebujemy wicej argument贸w rozdzielamy je w obu przypadkach przecinkami (tak jak miao to miejsce w korzystaniu z funkcji \python{print}).

\paragraph{Przykad}
Napiszmy funkcj, kt贸ra wypisuje sw贸j argument podniesiony do kwadratu i wywoajmy j:

\begin{CodeFrame}[python]{.5\textwidth}
def kwadrat(x):
  print(x * x)

kwadrat(7)
kwadrat(2 + 3)
\end{CodeFrame}
\begin{CodeFrame}{auto}
49
25
\end{CodeFrame}

\noindent
Zwr贸 uwag, i偶 wywoania funkcji w powy偶szym przykadzie nie s wcite --- s poza blokiem funkcji.

\begin{ProTip}{Polecenia wieloliniowe w konsoli interaktywnej }
Mo偶liwe jest wprowadzanie polece wieloliniowych w konsoli interaktywnej.
W takim wypadku po wprowadzeniu pierwszej linii (rozpoczynajcej blok, np. \python{def})
nastpi zmiana znaku zachty na \Verb{...}, co oznacza tryb wprowadzania bloku polece.
Nastpnie wprowadzamy kolejne instrukcje wykonywane w ramach tego bloku (np. funkcji) pamitaj o wciciach.
Wprowadzanie bloku koczymy pust lini, po czym znak zachty powr贸ci do standardowego \Verb{>>>}.
\end{ProTip}

\subsubsection{Warto zwracana z funkcji}

Czsto chcemy aby funkcja zamiast wypisa wynik swojego dziaania na ekran zwr贸cia go w taki spos贸b aby mo偶na byo go zapisa do jakiej zmiennej,
mo偶liwe to jest poprzez zastosowanie instrukcji \python{return}. Przerywa ona dziaanie funkcji w miejscu w kt贸rym zostaa wykonaa,
powoduje powr贸t do miejsca gdzie wywoana zostaa funkcja i zwraca podan do niej warto:

\begin{CodeFrame}[python]{.5\textwidth}
def kwadrat(x):
  return x * x

a = kwadrat(7)
print( a - 2, kwadrat(4) )
\end{CodeFrame}
\begin{CodeFrame}{auto}
47 16
\end{CodeFrame}
%  END: Funkcje

\vspace{-13pt}

%  BEGIN: Funkcje2
\subsubsection{Argumenty domylne i nazwane {\Symbola }}

Mo偶liwe jest podanie wartoci domylnych dla wybranych argument贸w funkcji. Utworzy to z nich argumenty opcjonalne, kt贸re nie musz by podawane przy wywoaniu funkcji.
Argumenty z wartociami domylnymi musz wystpowa w definicji funkcji po argumentach bez takich wartoci.
Przy wywoaniu funkcji mo偶na odwoywa si do jej argument贸w z podaniem ich nazw, pozwala to na podawanie argument贸w w innej kolejnoci ni偶 podana w definicji funkcji,
co jest przydatne zwaszcza przy funkcjach z wieloma argumentami opcjonalnymi.

\begin{CodeFrame}[python]{.65\textwidth}
def potega(a = 2, b = 2):
    return a ** b

print( potega(), potega(4), potega(4, 3) )
print( potega(b = 3), potega(b = 1, a = 4) )
\end{CodeFrame}
\begin{CodeFrame}{auto}
4 16 64
8 4
\end{CodeFrame}

\subsubsection{Zasig zmiennej {\Symbola }}

W Pythonie wewntrz funkcji widoczne s zmienne zdefiniowane poza ni, jednak aby m贸c modyfikowa tak zmienn wewntrz
funkcji nale偶y j tam zadeklarowa jako globaln przy pomocy sowa kluczowego \python{global}:

\begin{CodeFrame}[python]{.5\textwidth}
def test():
  global b
  a, b = 5, 13
  print(a, b, c)

a, b, c = 1, 3, 7
test()
print(a, b, c)
\end{CodeFrame}
\begin{CodeFrame}{auto}
5 13 7
1 13 7
\end{CodeFrame}

\noindent
Analizujc dziaanie powy偶szego kodu zwr贸ci uwag na:
\begin{itemize}
\item zasonicie globalnego \Verb{a} poprzez lokalne a wewntrz funkcji (nie mo偶na zmodyfikowa globalnej zmiennej \Verb{a} w funkcji),
\item mo偶liwo dostpu do globalnych zmiennych w funkcji dop贸ki ich nie zasonimy zmienn lokaln (tak u偶ywamy zmiennej \Verb{c})
\item mo偶liwo zmodyfikowania zmiennej globalnej gdy jest zadeklarowana w funkcji jako \python{global}
\end{itemize}
%  END: Funkcje2

%  BEGIN: Ptla for
\subsection{Ptla \python{for}}
Za贸偶my, 偶e chcemy obliczy kwadraty wszystkich liczb od 1 do 4.
Zgodnie z dotychczasow wiedz, w tym celu musimy wykona 4 dziaania:

\begin{CodeFrame}[python]{.5\textwidth}
print(1 * 1)
print(2 * 2)
print(3 * 3)
print(4 * 4)
\end{CodeFrame}
\begin{CodeFrame}{auto}
1
4
9
16
\end{CodeFrame}

Widzimy jednak, 偶e te dziaania s bardzo podobne i chciaoby si je wykona ,,za jednym zamachem''.
Do wykonywania wielokrotnie tego samego (lub podobnego) kodu su偶 ptle.
Najprostszym rodzajem ptli jest ptla \python{for}, kt贸ra dla danej \emph{listy} i operacji do wykonania
wykonuje t operacj po kolei na ka偶dym elemencie listy.

Do wykonania powy偶szego zadania su偶y ptla \python{for} w nastpujcej postaci:

\begin{CodeFrame}[python]{.5\textwidth}
for x in [1, 2, 3, 4]:
    print(x * x)
\end{CodeFrame}
\begin{CodeFrame}{auto}
1
4
9
16
\end{CodeFrame}

\noindent Spr贸buj przepisa t ptl i uruchomi program.
Zauwa偶 偶e wntrze ptli jest wyznaczone w spos贸b analogiczny do wntrza funkcji:
\begin{itemize}
	\item Rozpoczyna si od dwukropka koczcego pierwsz lini.
	\item Kolejne linijki s \emph{wcite}, tzn. rozpoczyna si od spacji, kilku spacji lub znaku tabulacji.
	\item Je偶eli w ramach ptli chcielibymy wykona kilka instrukcji musz one mie taki sam poziom wcicia.
	\item ,,Wntrze'' ptli koczymy wracajc do takiego samego poziomu wcicia na jakim j rozpoczlimy
	      (takiego wcicia jakie miaa linijka z sowem kluczowym \python{for}).
	\item Ptle mo偶emy zagnie偶d偶a jedna w drugiej --- blok wewntrznej ptli musi by ,,bardziej'' wcity.
	Powr贸t do poziomu wcicia zewntrznej ptli oznacza zakoczenie ptli wewntrznej i kontynuowanie zewntrznej.
\end{itemize}
%  END: Ptla for

%  BEGIN: Lista kolejnych liczb naturalnych
\subsection{Lista kolejnych liczb naturalnych}
Czsto potrzebujemy, aby ptla przesza po licie kilku kolejnych liczb naturalnych.
W tym celu mo偶emy oczywicie poda wprost kolejne elementy listy (tak jak w powy偶szym przykadzie),
jednak istnieje wygodniejsze rozwizanie, mianowicie polecenie \python{range()}:

\begin{CodeFrame}[python]{0.5\textwidth}
for x in range(7):
    print(x, end = ', ')
\end{CodeFrame}
\begin{CodeFrame}{auto}
0, 1, 2, 3, 4, 5, 6, 
\end{CodeFrame}

\begin{CodeFrame}[python]{0.5\textwidth}
for x in range(5, 10):
    print(x, end = ', ')
\end{CodeFrame}
\begin{CodeFrame}{auto}
5, 6, 7, 8, 9, 
\end{CodeFrame}

\begin{CodeFrame}[python]{0.5\textwidth}
for x in range(10, 20, 3):
    print(x, end = ', ')
\end{CodeFrame}
\begin{CodeFrame}{auto}
10, 13, 16, 19, 
\end{CodeFrame}

\noindent Na powy偶szych przykadach widzimy, 偶e polecenie \python{range()} wystpuje w trzech wersjach:
\begin{itemize}
	\item \python{range(kon)} generuje list kolejnych liczb od 0 (\strong{wcznie}) do \Verb{kon} (\strong{wycznie}).
	\item \python{range(pocz, kon)} generuje list kolejnych liczb od \Verb{pocz} (\strong{wcznie}) do 
		\Verb{kon} (\strong{wycznie}).
	\item \python{range(pocz, kon, krok)} generuje list liczb od \Verb{pocz} (\strong{wcznie}) 
		do \Verb{kon} (\strong{wycznie}), przeskakujc w ka偶dym kroku o \Verb{krok}.
\end{itemize}

\begin{ProTip}{\normalfont{\strong{Do zapamitania}}}
\normalsize Wszystkie przedziay w Pythonie s domknite z lewej strony i otwarte z prawej strony,
tzn. zawieraj sw贸j lewy koniec i nie zawieraj swojego prawego koca.
\end{ProTip}
%  END: Lista kolejnych liczb naturalnych

%  BEGIN: Typ logiczny
\subsection{Typ logiczny}

Jak ju偶 si przekonalimy mo偶na u偶ywa Pythona jako kalkulatora. Mo偶emy go tak偶e u偶y do obliczania wartoci wyra偶e logicznych. Su偶y do tego wbudowany dwuwartociowy typ logiczny z wartociami:
\begin{itemize}
\item \python{True} oznaczajc logiczn jedynk / prawd
\item \python{False} oznaczajc logiczne zero / fasz
\end{itemize}
Operacje na tym typie wykonujemy z u偶yciem s贸w kluczowych: \python{and}, \python{or}, \python{not} oznaczajcych odpowiednio:
iloczyn logiczny (aby by prawd oba warunki musz by spenione), sum logiczn (aby wynik by prawd co najmniej jednej z warunk贸w musi by speniony) oraz negacj logiczn.
Podobnie jak w zwykych operacjach arytmetycznych mo偶emy grupowa ich fragmenty (celem wymuszenia kolejnoci dziaa) przy pomocy nawias贸w okrgych.

Wartociom tego typu mog odpowiada wybrane wartoci innych typ贸w (np. liczba cakowita 0 odpowiada \python{False}, a pozostae liczby cakowite \python{True}).
Wartociami tego typu s te偶 wyniki r贸偶nego rodzaju por贸wna, takich jak: \python{<} (mniejsze), \python{>} (wiksze), \python{<=} (mniejsze r贸wne),
\python{>=} (wiksze r贸wne), \python{==} (r贸wne), \python{!=} (nier贸wne).
%  END: Typ logiczny

%  BEGIN: Instrukcja warunkowa if
\subsection{Instrukcja warunkowa \python{if}}

Czsto chcemy, aby program zachowywa si w r贸偶ny spos贸b w zale偶noci od tego, czy jaki warunek jest speniony, czy nie.
W Pythonie (jak w wikszoci jzyk贸w programowania) su偶y do tego instrukcja warunkowa \python{if}.

Przypumy, 偶e chcemy napisa funkcj, kt贸ra dla podanej wartoci sprawdzi czy odpowiada ona logicznej prawdzie czy faszowi i wypisuje odpowiedni komunikat.
Zatem kod bdzie wyglda nastpujco:

\begin{CodeFrame}[python]{0.50\textwidth}
def sprawdz(x):
    if x:
        print(x, '-- prawda')
    else:
        print(x, '-- nie prawda')
sprawdz(1)
sprawdz(0)
\end{CodeFrame}
\begin{CodeFrame}{auto}
1 -- prawda
0 -- nie prawda
\end{CodeFrame}

\noindent Zwr贸 uwag na nastpujce rzeczy:
\begin{itemize}
	\item \python{if} to po polsku ,,jeli'', \python{else} to po polsku ,,w przeciwnym przypadku''.
	\item Linijki rozpoczynajce si od \python{if} i \python{else} (podobnie jak linijki rozpoczynajce si np. od \python{def}) kocz si dwukropkiem.
	\item ,,Wntrze'' \python{if}-a i \python{else}-a (linijki 3 i 5) jest wcite (bardziej ni偶 samo wntrze definicji funkcji \Verb{sprawdz}).
	\item Linijka 3 zostanie wykonana, jeli speniony bdzie warunek z linijki 2, czyli jeli warto zmiennej x bdzie odpowiadaa prawdzie.
	\item Linijka 5 zostanie wykonana, jeli warunek z linijki 2 nie bdzie speniony.
\end{itemize}
W powy偶szym przykadzie u偶ylimy konstrukcji \python{if}/\python{else} do rozr贸偶nienia pomidzy dwoma przypadkami.
U偶ywajc komendy \python{elif} (skr贸t od \python{else if}) mo偶emy stworzy bardziej skomplikowany kod do rozr贸偶nienia pomidzy kilkoma r贸偶nymi przypadkami:

\begin{CodeFrame}[python]{0.6\textwidth}
for x in range(0, 5):
    if x < 1 or x == 4:
        print('mniejsze od 1 lub r贸wne 4')
    elif x in [0,2,3]:
        print('0 2 lub 3')
    else:
        print('nic ciekawego')
\end{CodeFrame}
\begin{CodeFrame}{auto}
mniejsze od 1 lub r贸wne 4
nic ciekawego
0 2 lub 3
0 2 lub 3
mniejsze od 1 lub r贸wne 4
\end{CodeFrame}

Ten kod skada si z trzech blok贸w, kt贸re s wykonywane w zale偶noci od spenienia poszczeg贸lnych warunk贸w:
\python{if}, \python{elif}, \python{else}.
Mamy du偶 dowolno w konstruowaniu tego typu fragment贸w kodu: 
blok贸w \python{elif} mo偶e by dowolnie wiele, blok \python{else} mo偶e wystpowa jako ostatni blok,
ale mo偶e te偶 go nie by w og贸le.

W powy偶szym przykadzie widzimy r贸wnie偶, 偶e w roli warunk贸w sprawdzanych w ramach \python{if}a mog wystpowa bardziej zo偶one wyra偶enia.
Mo偶emy tutaj u偶y dowolnego wyra偶enia kt贸rego wynik odpowiada wartoci logicznej \python{True}/\python{False},
najczciej spotkamy si z wyra偶eniami zo偶onymi z poznanych ju偶 operator贸w por贸wna (\python{<}, \python{>}, \python{<=},
\python{>=}, \python{==}, \python{!=}) i operacji logicznych (\python{and}, \python{or}, \python{not}).

Zwr贸 uwag na warunek postaci ,,\python{A in B}''.
Taki warunek sprawdza, czy warto reprezentowana przez \Verb{A} jest elementem \Verb{B}, a jego wynik oczywicie tak偶e jest wartoci logiczn.
W naszym przykadzie sprawdzalimy, czy warto zmiennej \Verb{x} wystpuje w podanej licie liczb, czyli czy jest 1, 2 lub 3.

Zauwa偶, 偶e dla x wynoszcego 0 spenione s dwa warunki (pierwszy i rodkowy), w takim wypadku decydujca jest kolejno warunk贸w i w konstrukcji
\python{if}/\python{elif} wykonany zostanie jedynie kod zwizany z pierwszym pasujcym warunkiem.
%  END: Instrukcja warunkowa if

%  BEGIN: Ptla while
\subsection{Ptla \python{while}}

Do tej pory korzystalimy z ptli \python{for}, kt贸ra pozwala na iterowanie po licie element贸w. Innym istotnym rodzajem ptli
jest ptla \python{while}, kt贸ra powoduje wykonywanie zawartego w niej kodu dop贸ki podany warunek jest speniony.
\teacher{Zwr贸ci uwag na mo偶liwo / ryzyko zaptlenia.}

\begin{CodeFrame}[python]{0.50\textwidth}
a, b = 0, 1
while a <= 20:
    print(a, end=" ")
    a, b = b, a + b
\end{CodeFrame}
\begin{CodeFrame}{auto}
0 1 1 2 3 5 8 13
\end{CodeFrame}

Zwr贸 uwag, 偶e wewntrz ptli \python{while} (tak samo jak innych konstrukcji u偶ywajcych wcitego bloku - takich jak \python{for}, czy \python{if})
mo偶e znajdowa si wicej ni偶 jedno polecenie. Trzeba tylko pamita, aby wszystkie byy poprzedzone takim samym wciciem.

Ptla \python{while} jest te偶 naturalnym wyborem gdy w Pythonie chcemy przechodzi przez jaki zakres liczb z krokiem nie cakowitym
	(wczeniej poznana instrukcja \python{range}, stosowana do iterowania po zakresie liczbowym w ptli \python{for}, wymaga aby krok by cakowity).
%  END: Ptla while

\subsection{\python{break} i \python{continue}}

W ramach zar贸wno ptli for jak i while mo偶emy u偶y instrukcji:
\begin{itemize}
	\item \python{break} powodujcej przerwanie wykonywania ptli
	\item \python{continue} powodujcej pominicie pozostaych instrukcji w aktualnym obiegu ptli
\end{itemize}

Ich dziaanie mo偶e zobrazowa poni偶szy kod:
\begin{CodeFrame}[python]{0.50\textwidth}
for x in [1, 2, 3, 4, 5, 6]:
  print("start", x)
  if x == 2:
    continue
  if x == 4:
    break
  print("...")
\end{CodeFrame}
\begin{CodeFrame}{auto}
start 1
...
start 2
start 3
...
start 4
\end{CodeFrame}


%  BEGIN: Wielokrotne przypisanie
\subsection{Wielokrotne przypisanie}

Zwr贸 uwag w powy偶szym kodzie tak偶e na operacj wielokrotnego przypisania postaci \python{a, b = x, y}.
Dokonuje ona przypisania wartoci x do a i y do b, przy czym wartoci x i y obliczane s przed zmodyfikowaniem a i b.
Pozwala to m.in. na zamian wartoci pomidzy a i b bez stosowania zmiennej tymczasowej poprzez zapis: \python{a, b = b, a}.
Podobnie mo偶emy zapisywa przypisania wikszej iloci wartoci do wikszej iloci zmiennych np: \python{a, b, c = 1, 5, 9}.
Z notacji tej bdziemy te偶 czsto korzysta w dalszej czci skryptu przy inicjalizacji zmiennych.
\teacher{Nale偶y powici chwil uwagi tej notacji.}
%  END: Wielokrotne przypisanie

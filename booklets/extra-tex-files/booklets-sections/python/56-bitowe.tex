% Copyright (c) 2020 Matematyka dla Ciekawych Åšwiata (http://ciekawi.icm.edu.pl/)
% Copyright (c) 2020 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

%  BEGIN: Kod binarny
\subsection{Kod binarny {\Symbola ğŸ¤”}}

Jak wiemy liczby moÅ¼emy zapisywaÄ‡ w rÃ³Å¼nych systemach liczbowych i jednym z nich jest system dwÃ³jkowy, nazywany teÅ¼ binarnym.
Taka reprezentacja liczb jest podstawÄ… dziaÅ‚ania elektroniki cyfrowej w tym wspÃ³Å‚czesnych komputerÃ³w.

Napis przedstawiajÄ…cy liczbÄ™ w reprezentacji dwÃ³jkowej w Pythonie moÅ¼na z pomocÄ… funkcji \python{bin}. Funkcja ta niestety nie pozwala wymusiÄ‡ dÅ‚ugoÅ›ci wypisywanej liczby (co jest bardzo przydatne jeÅ¼eli chcemy operowaÄ‡ na poszczegÃ³lnych bitach) a dodatkowo liczby ujemne wypisuje ze znakiem minus i reprezentacjÄ… liczby dodatniej (czyli zasadniczo w kodzie znak moduÅ‚) a nie rzeczywiÅ›cie stosowanym do zapisu takich liczb na zdecydowanej wiÄ™kszoÅ›ci architektur kodzie uzupeÅ‚nieÅ„ do dwÃ³ch. Dlatego na potrzeby przykÅ‚adÃ³w w tym rozdziale bÄ™dziemy uÅ¼ywaÄ‡ wÅ‚asnej funkcji zwracajÄ…cej binarnÄ… reprezentacjÄ™ liczb 8bitowych (czyli 1 bajta):

\begin{CodeFrame}[python]{0.55\textwidth}
def bin8(x):
	return "0b{0:08b}".format(x & 0xff)
\end{CodeFrame}

Liczby dodatnie w systemie binarny zapisuje siÄ™ praktycznie zawsze w postaci NKB. Zapis taki jest analogiczny do zapisu dziesiÄ™tnego stosowanego na co dzieÅ„, z tym Å¼e kolejne cyfry liczby majÄ… wagÄ™ $2^n$ a nie $10^n$ (gdzie $n$ jest numerem cyfry, zaczynajÄ…cym siÄ™ od zera dla skrajnie prawej).

$$ a_{n}a_{n-1}...a_{1}a_{0} \leftrightarrow a_{n} \cdot 2^{n} + a_{n-1} \cdot 2^{n-1} + ... + a_{1} \cdot 2^{1} + a_{0} \cdot 2^{0} $$

Liczby ujemne mogÄ… byÄ‡ zapisywane na rÃ³Å¼ne sposoby.
Wspomniany kod moduÅ‚-znak polega na zapisie moduÅ‚u liczby w postaci NKB oraz umieszczenia flagi znaku w najstarszym bicie (0 â€“ liczba dodatnia, 1 â€“ ujemna).
NajczÄ™Å›ciej stosowany jest jednak kod uzupeÅ‚nieÅ„ do dwÃ³ch (okreÅ›lany jako U2) przypominajÄ…cy NKB tyle Å¼e najstarszy n-ty bit wchodzi z wagÄ… $-(2^n)$ a nie $2^n$:

$$ a_{n}a_{n-1}...a_{1}a_{0} \leftrightarrow - a_{n} \cdot 2^{n} + a_{n-1} \cdot 2^{n-1} + ... + a_{1} \cdot 2^{1} + a_{0} \cdot 2^{0} $$

\begin{CodeFrame}[python]{0.55\textwidth}
print(bin8(3),  bin(3))
print(bin8(-3), bin(-3))
\end{CodeFrame}
\begin{CodeFrame}{auto}
0b00000011 0b11
0b11111101 -0b11
\end{CodeFrame}

MoÅ¼emy sprawdziÄ‡ czy bin8 rzeczywiÅ›cie wypisaÅ‚o reprezentacjÄ™ -3 w kodzie U2 wykonujÄ…c proste obliczenie:

\begin{CodeFrame}[python]{0.75\textwidth}
-2**7 + 2**6 + 2**5 + 2**4 + 2**3 + 2**2 + 0*(2**1) + 2**0
\end{CodeFrame}
\begin{CodeFrame}{auto}
-3
\end{CodeFrame}

\subsubsection{Operacje bitowe}

Python, jak wiele innych jÄ™zykÃ³w, pozwala wykonywaÄ‡ operacje boolowskie nie tylko na wartoÅ›ciach reprezentujÄ…cych pradwÄ™ i faÅ‚sz, ale takÅ¼e na odpowiadajacych sobie bitach dwÃ³ch liczb.
OperacjÄ™ bitowego AND zapisujemy z pomocÄ… \python{&}, OR z pomocÄ… \python{|}, XOR z pomocÄ… \python{^}, a NOT  z pomocÄ… \python{~}:

\begin{CodeFrame}[python]{0.55\textwidth}
print(bin8( 0b11001010 & 0b10101110 ))
print(bin8( 0b11001010 | 0b10101110 ))
print(bin8( 0b11001010 ^ 0b10101110 ))
print(bin8( ~0b11001010 ))
\end{CodeFrame}
\begin{CodeFrame}{auto}
0b10001010
0b11101110
0b01100100
0b00110101
\end{CodeFrame}

Jak widzimy w pokazanym przykÅ‚adzie operacje te sÄ… wykonywane na kaÅ¼dym z bitÃ³w liczby niezaleÅ¼nie czyli n-ty bit wyniku bitowego AND to n-ty bit pierwszej liczby AND n-ty bit drugiej liczby, itd.

\begin{CodeFrame}[python]{0.55\textwidth}
print(bin8( 0b11001010 << 3 ))
print(bin8( 0b11001010 >> 3 ))
\end{CodeFrame}
\begin{CodeFrame}{auto}
0b01010000
0b00011001
\end{CodeFrame}

DostÄ™pne sÄ… takÅ¼e operacje przesuniÄ™cia bitÃ³w w ramach liczby w lewo lub prawo (brakujÄ…ce bity uzupeÅ‚niane sÄ… zerami, a bity wystajÄ…ce poza dÅ‚ugoÅ›Ä‡ liczby binarnej sÄ… obcinane\footnote{
	W przypadku Pythona liczby caÅ‚kowite nie majÄ… maksymalnej wielkoÅ›ci, a obcinanie przy przesuwaniu w lewo realizuje nasza funkcja wypisujÄ…ca bin8.
}). Operacje te odpowiadajÄ… mnoÅ¼eniu i dzieleniu caÅ‚kowitemu przez $2^x$, gdzie $x$ to iloÅ›Ä‡ bitÃ³w do przesuniecia podawana po prawej stronie operatora przesuniecia w postaci \python{<<} lub \python{>>}.

Operacje takie sÄ… przydatne do sprawdzania bÄ…dÅº ustawiania wartoÅ›ci poszczegÃ³lnych bitÃ³w.
SÄ… to operacje doÅ›Ä‡ niskopoziomowe i nie czÄ™sto stosowane w Pythonie, ale wiedza o nich przyda nam siÄ™ w niedalekiej przyszÅ‚oÅ›ci.
%  END: Kod binarny

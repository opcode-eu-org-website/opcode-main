% Copyright (c) 2016-2020 Matematyka dla Ciekawych Åšwiata (http://ciekawi.icm.edu.pl/)
% Copyright (c) 2016-2017 Åukasz Mazurek
% Copyright (c) 2018-2020 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

%  BEGIN: Napisy - wprowadzenie
\section{Napisy}
Do tej pory uÅ¼ywaliÅ›my zmiennych do przechowywania liczb i operowania na nich. Zmienne mogÄ… rÃ³wnieÅ¼ jako wartoÅ›ci przyjmowaÄ‡ litery, sÅ‚owa, a nawet caÅ‚e zdania:

\begin{CodeFrame}[python]{.5\textwidth}
x = 'A'
a, b, c = 'Ala', "ma", " kota i psa"
d = """ ... a co ma ...
 "kotek"?"""
print(x, a[2])
print(c[1], c[-1], c[-3])
print(a + b)
print(3 * a)
print(a + " " + b + c + d)
\end{CodeFrame}
\begin{CodeFrame}{auto}
A a
o a p
Alama
AlaAlaAla
Ala ma kota i psa ... a co ma ...
 "kotek"?
\end{CodeFrame}

\pagebreak[2]\noindent
ZwrÃ³Ä‡ uwagÄ™ na nastÄ™pujÄ…ce rzeczy:
\begin{itemize}
\item Napisy muszÄ… byÄ‡ otoczone pojedynczymi apostrofami lub podwÃ³jnym cudzysÅ‚owami (nie ma znaczenia,
	ktÃ³rÄ… wersjÄ™ wybierzemy), w przypadku napisÃ³w wieloliniowych uÅ¼ywamy trzykrotnie apostrofu lub cudzysÅ‚owowa na poczÄ…tku i koÅ„cu napisu.\\
	Nie przypisane do Å¼adnej zmiennej napisy wieloliniowe mogÄ… byÄ‡ stosowane jako komentarze wieloliniowe.
\item Przy uÅ¼yciu liczby w nawiasie kwadratowym moÅ¼emy poznaÄ‡ poszczegÃ³lne litery napisu (\strong{\emph{numeracja rozpoczyna siÄ™ od 0}}).
\item Ujemny indeks oznacza odliczanie liter od koÅ„ca napisu: ostatnia litera napisu \python{c} to \python{c[-1]},
	przedostatnia to \python{c[-2]}, itd.
\item Przy uÅ¼yciu znaku dodawania moÅ¼emy sklejaÄ‡ (\emph{konkatenowaÄ‡}) napisy.
\item Przy uÅ¼yciu znaku gwiazdki moÅ¼emy mnoÅ¼yÄ‡ napisy (czyli sklejaÄ‡ same ze sobÄ…).
\end{itemize}
Innymi przydatnymi operacjami na napisach jest sprawdzanie dÅ‚ugoÅ›ci napisu poleceniem \python{len()}
oraz wycinanie podnapisu przy uÅ¼yciu dwukropka:

\begin{CodeFrame}[python]{.7\textwidth}
tekst = 'Python'
dlugosc = len(tekst)
print(dlugosc, tekst[2:5], tekst[3:], tekst[:3])
\end{CodeFrame}
\begin{CodeFrame}{auto}
6 tho hon Pyt
\end{CodeFrame}

\pagebreak[2]\noindent
W powyÅ¼szym przykÅ‚adzie:
\begin{itemize}
\item komenda \python{tekst[2:5]} zwraca podnapis od znaku nr 2 (\strong{wÅ‚Ä…cznie}) do znaku nr 5 
(\strong{wyÅ‚Ä…cznie}),
\item komenda \python{tekst[3:]} zwraca podnapis od znaku nr 3 (\strong{wÅ‚Ä…cznie}) do koÅ„ca, 
\item komenda \python{tekst[:3]} zwraca podnapis od poczÄ…tku do znaku nr 3 
(\strong{wyÅ‚Ä…cznie}).
\end{itemize}

Podobnie jak w \python{range()} moÅ¼emy podaÄ‡ trzeci argument okreÅ›lajÄ…cy przedziaÅ‚ czyli krok.
Pozwala to na wybieranie co n-tego znaku z napisu, zarÃ³wno zaczynajÄ…c od poczÄ…tku jak i koÅ„ca:

\begin{CodeFrame}[python]{.7\textwidth}
tekst = '123456789'
print(tekst[::2], tekst[1::2])
print(tekst[::-1], tekst[::-3])
print(tekst[::-1][::3], tekst[::3][::-1])
\end{CodeFrame}
\begin{CodeFrame}{auto}
13579 2468
987654321 963
963 741
\end{CodeFrame}

\pagebreak[2]\noindent
W powyÅ¼szym przykÅ‚adzie:
\begin{itemize}
\item komenda \python{tekst[::2]} zwraca co drugi znak,
\item komenda \python{tekst[1::2]} zwraca co drugi znak od znaku nr 1,
\item komenda \python{tekst[::-1]} zwraca napis od tyÅ‚u,
\item komenda \python{tekst[::-3]} zwraca co 3 znak z napisu od tyÅ‚u (warto zauwaÅ¼yÄ‡ Å¼e nie zawsze jest to rÃ³wnowaÅ¼ne wypisaniu napisu zÅ‚oÅ¼onego z co 3 znaku od tyÅ‚u).
\end{itemize}

\subsection{Napis jako lista}

Wszystkie listy, ktÃ³rych do tej pory uÅ¼ywaliÅ›my w pÄ™tli \python{for} byÅ‚y listami liczb.
Okazuje siÄ™, Å¼e w Pythonie napisy mogÄ… byÄ‡ traktowane jako lista, a dokÅ‚adniej listÄ… liter. 
Oznacza to, Å¼e po napisie moÅ¼na przejÅ›Ä‡ przy uÅ¼yciu pÄ™tli \python{for}, tak samo jak przechodziliÅ›my po liÅ›cie liczb:

\begin{CodeFrame}[python]{0.50\textwidth}
for l in 'Abc':
    print('litera', end = ' ')
    print(l)
\end{CodeFrame}
\begin{CodeFrame}{auto}
litera A
litera b
litera c
\end{CodeFrame}

\subsubsection{ModyfikowalnoÅ›Ä‡ napisÃ³w}

Python pozwala odwoÅ‚ywaÄ‡ siÄ™ do poszczegÃ³lnych znakÃ³w w napisie jak do elementÃ³w listy, jednak nie pozwala na ich modyfikowanie:

\begin{CodeFrame}[python]{0.25\textwidth}
s = "abcdefgh"
s[2] = "X"
print(s)
\end{CodeFrame}
\begin{CodeFrame}{auto}
Traceback (most recent call last):
  File "python", line 2, in <module>
TypeError: 'str' object does not support item assignment
\end{CodeFrame}

ZwrÃ³Ä‡ uwagÄ™ na komunikat bÅ‚Ä™du, ktÃ³ry zostaÅ‚ wyÅ›wietlony, podaje on informacji o tym co wywoÅ‚aÅ‚o bÅ‚Ä…d (opis bÅ‚Ä™du) i w  ktÃ³rej linii programu on wystÄ…piÅ‚.
\strong{Czytanie ze zrozumieniem komunikatÃ³w o bÅ‚Ä™dach uÅ‚atwia naprawianie niedziaÅ‚ajÄ…cego programu.}

\teacher{
	\ \\ \strong{Warto pokazaÄ‡ kilka innych komunikatÃ³w o bÅ‚Ä™dach i poprosiÄ‡ uczestnikÃ³w o ich wyjaÅ›nienie.}\\\ 
}

JeÅ¼eli zachodzi potrzeba modyfikowania napisu konkretnych znakÃ³w w napisie moÅ¼emy uÅ¼yÄ‡ poznanej wczeÅ›niej metody uzyskiwania podnapisÃ³w:

\begin{CodeFrame}[python]{0.50\textwidth}
s = "abcdefgh"
s = s[:2] + "X" + s[3:5] + s[6:]
print(s)
\end{CodeFrame}
\begin{CodeFrame}{auto}
abXdegh
\end{CodeFrame}

PowyÅ¼szy przykÅ‚ad w miejsce znaku nr 2 wstawia napis "X" oraz usuwa znak nr 5 z napisu.
Przy koniecznoÅ›ci modyfikacji znak po znaku moÅ¼emy uÅ¼yÄ‡ iteracji po napisie i budowaÄ‡ nowy napis znak po znaku:

\begin{CodeFrame}[python]{0.50\textwidth}
s, ns = "abcdefgh", ""
for z in s:
    if z in "cf":
        ns = ns + "X"
    else:
        ns = ns + z
print(ns)
\end{CodeFrame}
\begin{CodeFrame}{auto}
abXdeXgh
\end{CodeFrame}
%  END: Napisy - wprowadzenie

%  BEGIN: ObiektowoÅ›Ä‡
\subsection{ObiektowoÅ›Ä‡}

Jak byÄ‡ moÅ¼e zauwaÅ¼yliÅ›my wszystkie podstawowe typy w Pythonie sÄ… klasami. ZwiÄ…zane z tym jest m.in. to iÅ¼ posiadajÄ… one metody sÅ‚uÅ¼Ä…ce do operowania na nich.
MetodÄ… nazywamy funkcjÄ™ zwiÄ…zanÄ… z danym typem i wykonywanÄ… na obiekcie tego typu.
Zapisywane jest to z uÅ¼yciem kropki, nazwy metody i nawiasÃ³w okrÄ…gÅ‚ych ktÃ³re mogÄ… zawieraÄ‡ dodatkowe argumenty.
Na przykÅ‚ad: \python{"aÄ…cd".islower()} jest wywoÅ‚aniem metody \python{islower} typu napisowego na napisie \python{"aÄ…cd"}; metoda ta sprawdza czy w podanym ciÄ…gu znakÃ³w nie wystÄ™pujÄ… wielkie litery.

Klasy posiadajÄ… takÅ¼e konstruktory, ktÃ³re moÅ¼emy wywoÅ‚aÄ‡ uÅ¼ywajÄ…c nazwy danej klasy jak funkcji i uÅ¼yÄ‡ np. do konwersji pomiÄ™dzy rÃ³Å¼nymi typami.
Jak juÅ¼ wiemy wszystkie nazwy w pythonie Å¼yjÄ… w jednym Å›wiecie, dotyczy to teÅ¼ nazw klas.
Dlatego warto uwaÅ¼aÄ‡ aby nie nazywaÄ‡ swoich zmiennych zarÃ³wno tak jak nazywajÄ… siÄ™ wbudowane funkcje, ani tak jak nazywajÄ… siÄ™ wbudowane typy danych (takie jak int, bool, str, folat i tak dalej).

Opis danego typu wraz z dostÄ™pnymi metodami moÅ¼na obejrzeÄ‡ przy pomocy polecenia \python{help()}, np. \python{help("str")}.
\teacher{
Chcemy nauczyÄ‡ korzystania z dokumentacji, wiÄ™c w zadaniach zwiÄ…zanych z stosowaniem metod jakiejÅ› klasy starajmy siÄ™ aby uczniowie sami odnajdywali w niej odpowiedzi.
}

W przypadku napisÃ³w za pomocÄ… metod tej klasy mamy moÅ¼liwoÅ›Ä‡ miÄ™dzy innymi wyszukania miejsca wystÄ…pienia podnapisu, zamiany wielkich liter na maÅ‚e i odwrotnie, etc.
%  END: ObiektowoÅ›Ä‡

%  BEGIN: Konwersje liczba -- napis
\subsection{Konwersje liczba -- napis}

Z punktu widzenia komputera liczba czy teÅ¼ element napisu, ktÃ³rym jest litera sÄ… pewnÄ… wartoÅ›ciÄ… numerycznÄ….
Natomiast my do zapisu liczb uÅ¼ywamy rÃ³Å¼nych systemÃ³w (np. dziesiÄ™tnego, czy teÅ¼ szesnastkowego).
DomyÅ›lnie liczby wprowadzane do programu interpretowane sÄ… jako zapisane w systemie dziesiÄ™tnym,
podobnie liczby uzyskiwane poprzez konwersjÄ™ napisu przy pomocy funkcji \python{int()} (dokÅ‚adniej jest to konstruktor typu caÅ‚kowitego).
MoÅ¼liwe jest jednak wprowadzanie liczb zapisanych w innych systemach liczbowych lub konwersja z napisu zawierajÄ…cego liczbÄ™ ---
drugi, opcjonalny argument \python{int()} pozwala okreÅ›liÄ‡ podstawÄ™ systemu z ktÃ³rego konwertujemy, zero oznacza automatyczne wykrycie w oparciu o prefix:

\begin{CodeFrame}[python]{0.7\textwidth}
# szesnastkowo
h1, h2, h3 = 0x1F, int("0x1F", 0), int("1F", 16)
# oktalnie
o1, o2, o3 = 0o17, int("0o17", 0), int("17", 8)
# binarnie
b1, b2, b3 = 0b101, int("0b101", 0), int("101", 2)

print("",h1,o1,b1, "\n",h2,o2,b2, "\n",h3,o3,b3)
\end{CodeFrame}
\begin{CodeFrame}{auto}
 31 15 5
 31 15 5
 31 15 5
\end{CodeFrame}
\teacher{
ZwrÃ³ciÄ‡ uwagÄ™ Å¼e w kaÅ¼dym wariancie konwersji dostajemy ten sam wynik. Jako ciekawostkÄ™ moÅ¼na zapytaÄ‡ siÄ™ o konwertowanie z innych systemÃ³w liczbowych.
}

MoÅ¼liwe jest takÅ¼e konwertowanie wartoÅ›ci liczbowej na napis w okreÅ›lonym systemie liczbowym:

\begin{CodeFrame*}[python]{}
a, b = 3, 13
c = (a + b) * b
s = "(" + bin(a) + " + " + oct(b) + ") * " + hex(b) + " = " + str(c)
print( s )
\end{CodeFrame*} 
% (0b11 + 0o15) * 0xd = 208
%  END: Konwersje liczba -- napis

%  BEGIN: Kodowania znakÃ³w
\subsection{Kodowania znakÃ³w}

Python uÅ¼ywa Unicode dla obsÅ‚ugi napisÃ³w, jednak przed przekazaniem napisu do Å›wiata zewnÄ™trznego konieczne moÅ¼e byÄ‡ zastosowanie konwersji do okreÅ›lonej postaci bytowej (zastosowanie odpowiedniego kodowania).
SÅ‚uÅ¼y do tego metoda \python{encode()} np.:

\begin{CodeFrame*}[python]{}
a = "aÄ…bcÄ‡ ... â†â†“â†’"
inUTF7 = a.encode('utf7')
inUTF8 =  a.encode() # lub a.encode('utf8')
print("'" + a + "' w UTF7 to: " + str(inUTF7) + ", w UTF8: " + str(inUTF8))
\end{CodeFrame*}

Zmienne typu 'bytes' oprÃ³cz przekazania na zewnÄ…trz (np. zapisu do pliku lub wysÅ‚ania przez sieÄ‡) mogÄ… zostaÄ‡ takÅ¼e m.in. zdekodowane do napisu z uÅ¼yciem metody \python{decode()} lub poddane dalszej konwersji np. kodowaniu base64:

\begin{CodeFrame*}[python]{}
print("zdekodowany UTF7: " + inUTF7.decode('utf7'))

import codecs
b64 = codecs.encode(inUTF8, 'base64')
print("napis w UTF8 po zakodowaniu base64 to: " + str(b64))
\end{CodeFrame*}

W powyÅ¼szym przykÅ‚adzie naleÅ¼y zwrÃ³ciÄ‡ uwagÄ™ na instrukcjÄ™ \python{import}, ktÃ³ra sÅ‚uÅ¼y do zaÅ‚Ä…czania bibliotek pythonowych do naszego programu.
W tym wypadku zaÅ‚Ä…czamy fragment standardowej biblioteki Pythona o nazwie \python{codecs}.

Base64 jest jednym z kodowaÅ„ pozwalajÄ…cych na zapis danych binarnych w postaci ograniczonego zbioru znakÃ³w drukowalnych,
co pozwala m.in. na osadzanie danych binarnych (np. obrazki) w plikach tekstowych (np. dokumenty html, pliki ÅºrÃ³dÅ‚owe programÃ³w).
%  END: Kodowania znakÃ³w

%  BEGIN: Konwersja znak - numer unicode
\subsubsection{Konwersja pomiÄ™dzy znakiem a jego numerem}

MoÅ¼liwe jest takÅ¼e konwertowanie pomiÄ™dzy liczbowym numerem znaku Unicode, a napisem go reprezentujÄ…cym i w drugÄ… stronÄ™ --- sÅ‚uÅ¼Ä… do tego odpowiednio funkcje \python{chr()} i \python{ord()}.
W ramach napisÃ³w moÅ¼na teÅ¼ uÅ¼yÄ‡ \python{\uNNNN} lub \python{\UNNNNNNNN} (gdzie \Verb{NNNN}/\Verb{NNNNNNNN} jest cztero/oÅ›mio\footnote{
	UÅ¼ycie wariantu cztero cyfrowego jest moÅ¼liwe jedynie dla znakÃ³w unicode o numerach mniejszych niÅ¼ 0xffff
} cyfrowym numerem znaku zapisanym szesnastkowo)
lub po prostu umieÅ›ciÄ‡ dany znak w pliku kodowanym UTF8\footnote{
	UÅ¼yty w przykÅ‚adzie symbol nieskoÅ„czonoÅ›ci moÅ¼na uzyskaÄ‡ na standardowej polskiej klawiaturze pod Linuxem przy pomocy kombinacji AltGr + Shift + M
}.

\begin{CodeFrame*}[python]{}
print(chr(0x221e) + " == \u221e == âˆ == \U0000221e")
print(hex(ord("âˆ")), hex(ord("\u221e")), hex(ord(chr(0x221e))) )
\end{CodeFrame*}

\teacher{
Warto skomentowaÄ‡ Å¼e powyÅ¼szy przykÅ‚ad demonstruje rÃ³wnowaÅ¼noÅ›Ä‡ poszczegÃ³lnych zapisÃ³w (drukujÄ… taki sam znak na konsoli, generujÄ… taki sam numer unicodowy).
}

NiektÃ³re znaki specjalne jak np. znak nowej linii, tabulator moÅ¼emy wprowadziÄ‡ z uÅ¼yciem krÃ³tszych i Å‚atwiejszych do zapamietania sekwencji niÅ¼ opartych o ich numer. Dla znaku nowej linii jest to \python{\n}, a tabulatora \python{\t}.
%  END: Konwersja znak - numer unicode

%  BEGIN: WyraÅ¼enia regularne 01
\subsection{WyraÅ¼enia regularne {\Symbola ğŸ¤”}}

W przetwarzaniu napisÃ³w bardzo czÄ™sto stosowane sÄ… wyraÅ¼enia regularne sÅ‚uÅ¼Ä…ce do dopasowywania napisÃ³w do wzorca ktÃ³ry opisujÄ…, wyszukiwaniu/zastÄ™powaniu tego wzorca. Do typowej, podstawowej skÅ‚adni wyraÅ¼eÅ„ regularnych zalicza siÄ™ m.in. nastÄ™pujÄ…ce operatory:

\vspace{-6pt}\begin{Verbatim}
.      - dowolny znak
[a-z]  - znak z zakresu
[^a-z] - znak z poza zakresu (aby mieÄ‡ zakres z ^ naleÅ¼y daÄ‡ go nie na poczÄ…tku)
^      - poczÄ…tek napisu/linii
$      - koniec napisu/linii
\end{Verbatim}
\vspace{-8pt}\begin{Verbatim}
*      - dowolna iloÅ›Ä‡ powtÃ³rzeÅ„
?      - 0 lub jedno powtÃ³rzenie
+      - jedno lub wiÄ™cej powtÃ³rzeÅ„
{n,m}  - od n do m powtÃ³rzeÅ„
\end{Verbatim}
\vspace{-8pt}\begin{Verbatim}
()     - pod-wyraÅ¼enie (moÅ¼e byÄ‡ uÅ¼ywane dla operatorÃ³w powtÃ³rzeÅ„,
         a takÅ¼e dla referencji wstecznych)
|      - alternatywa: wystÄ…pienie wyraÅ¼enia podanego po lewej stronie
         albo wyraÅ¼enia podanego prawej stronie
\end{Verbatim}

\pagebreak[2]\noindent
Python umoÅ¼liwia korzystanie z wyraÅ¼eÅ„ regularnych za pomocÄ… moduÅ‚u \python{re}:

\begin{CodeFrame}[python]{0.57\textwidth}
import re

y = "aa bb cc bb ff bb ee"
x = "aa bb cc dd ff gg ee"

if re.search("[dz]", y):
  print("y zawiera d lub z")

if re.search(".*[dz]", x):
  print("x zawiera d lub z")

if re.search(" ([a-z]{2}) .* \\1", y):
  print("y zawiera dwa razy to samo")

if re.search(" ([a-z]{2}) .* \\1", x):
  print("x zawiera dwa razy to samo")

# wypisanie dopasowania
wynik = re.search("cc (xx)|(dd) ff", x)
if wynik:
  print( wynik.group(0) )

wynik = re.search("cc (xx|dd) ff", x)
if wynik:
  print( wynik.group(0) )

# zastÄ™powanie
print (re.sub('[bc]+', "XX", y, 2))
print (re.sub('[bc]+', "XX", y))

# zachÅ‚annoÅ›Ä‡
print (re.sub('bb (.*) bb', "X \\1 X", y))
print (re.sub('.*bb (.*) bb.*', "\\1", y))
print (re.sub('.*?bb (.*) bb.*', "\\1", y))
\end{CodeFrame}
\begin{CodeFrame}{auto}
x zawiera d lub z
y zawiera dwa razy to samo
dd ff
cc dd ff
aa XX XX bb ff bb ee
aa XX XX XX ff XX ee
aa X cc bb ff X ee
ff
cc bb ff
\end{CodeFrame}

ZwrÃ³Ä‡ uwagÄ™ na:
\begin{itemize}
\item DziaÅ‚anie funkcji \Verb{search}, ktÃ³ra wyszukuje podnapis pasujÄ…cy do wyraÅ¼enia i umoÅ¼liwia zarÃ³no uzyskanie pasujÄ…cego podnapisu, jak teÅ¼ samej informacji o fakcie pasowania lub nie do wyraÅ¼enia.
\item DziaÅ‚anie alternatywy i nawiasÃ³w - standardowo alternatywa obejmuje wszystko co po lewej kontra wszystko co po prawej,
	nawiasy obejmujÄ…ce fragment prawej bÄ…dÅº lewej strony na to nie wpÅ‚ywajÄ… (\Verb{cc (xx)|(dd) ff} nie zadziaÅ‚o jako "xx" ablo "dd" pomiÄ™dzy "cc" a "ff", a jako "cc xx" albo "dd ff"),
	aby ograniczyÄ‡ dziaÅ‚anie alternatywy tylko do fragmentu wyraÅ¼enia naleÅ¼y objÄ…Ä‡ nawiasami ten fragment wraz z alternatywÄ… w nim umieszczonÄ… (\Verb{cc (xx|dd) ff} zadziaÅ‚o jako "xx" ablo "dd" pomiÄ™dzy "cc" a "ff".
\item OdwoÅ‚ania wsteczne do pod-wyraÅ¼eÅ„ (fragmentÃ³w ujÄ™tych w nawiasy) postaci \Verb{\\x}, gdzie \Verb{x} jest numerem pod-wyraÅ¼enia.
\item ,,\emph{ZachÅ‚annoÅ›Ä‡}'' (ang. \emph{greedy}) wyraÅ¼eÅ„ regularnych:
	\begin{itemize}
	\item w pierwszym wypadku \Verb{bb (.*) bb} dopasowaÅ‚o najdÅ‚uÅ¼szy moÅ¼liwy fragment, czyli \Verb{cc bb ff},
	\item w drugim przypadku gdy zostaÅ‚o poprzedzone \Verb{.*} dopasowaÅ‚o tylko \Verb{ff}, gdyÅ¼ \Verb{.*} dopasowaÅ‚o najdÅ‚uÅ¼szy moÅ¼liwy fragment czyli \Verb{aa bb cc},
	\item w trzecim wypadku \Verb{bb (.*) bb} mogÅ‚o i dopasowaÅ‚o najdÅ‚uÅ¼szy moÅ¼liwy fragment, czyli \Verb{cc bb ff}, gdyÅ¼ byÅ‚o poprzedzone niezachÅ‚annÄ… odmianÄ… dopasowania dowolnego napisu, czyli: \Verb{.*?}.
	\end{itemize}
	Po kaÅ¼dym z operatorÃ³w powtÃ³rzeÅ„ (\Verb@. ? + {n,m}@) moÅ¼emy dodaÄ‡ pytajnik (\Verb@.? ?? +? {n,m}?@) aby wskazaÄ‡ Å¼e ma on dopasowywaÄ‡ najmniejszy moÅ¼liwy fragment, czyli ma dziaÅ‚aÄ‡ nie zachÅ‚annie.
\end{itemize}
%  END: WyraÅ¼enia regularne 01

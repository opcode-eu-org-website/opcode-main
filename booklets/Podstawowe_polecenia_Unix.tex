% Copyright (c) 2017-2020 Matematyka dla Ciekawych Świata (http://ciekawi.icm.edu.pl/)
% Copyright (c) 2017-2020 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\documentclass{pdfBooklets}

\title{Linux i sieci: Podstawowe polecenia Unix'a}
\author{%
	Projekt ,,Matematyka dla Ciekawych Świata'',\\
	Robert Ryszard Paciorek\\\normalsize\ttfamily <rrp@opcode.eu.org>
}
\date  {2020-06-05}

\makeatletter\hypersetup{
	pdftitle = {\@title}, pdfauthor = {\@author}
}\makeatother

\usepackage[ampersand]{easylist}

\begin{document}

\maketitle

% BEGIN: unix intro
\section{Praca w terminalu}

\section{Praca w terminalu}

Komputer potrafi jedynie wykonywać jakiś wcześniej zaprogramowany ciąg instrukcji.
Każde wydane przez użytkownika polecenie wiąże się z uruchomieniem takiego ciągu instrukcji (programu komputerowego lub jakieś funkcji w ramach niego).

Podstawowym sposobem wydawania poleceń w systemach typu Unix jest wpisywanie ich w terminalu.
Terminal może pracować w trybie tekstowym lub może być uruchomiony (jako tzw. emulator terminala) w trybie graficznym.

\subsection{Powłoka}

Wprowadzane polecenia interpretowane są przez działający w terminalu program nazywany powłoką (interpreterem poleceń).
W terminalu mogą być uruchamiane kolejne (takie same lub różne) interpretery poleceń.
Różne interpretery korzystają z różnych składni oraz często różnią się znakiem zachęty (czyli wypisanym tekstem poprzedzającym wprowadzane polecenia).

\subsubsection{bash}
Bash jest chyba najpopularniejszą powłoką (interpreterem poleceń).
Jest zgodny ze składnią z sh, zapewnia m.in. obsługę zmiennych (zasadniczo napisowych) oraz omówionych w dalszej części skryptu znaków uogólniających.
Umożliwia edycję linii poleceń, dopełnianie komend, ścieżek, itp przy pomocy tabulatora oraz zapewnia dostęp do historii linii poleceń (poruszanie się po historii strzałkami, wyszukiwanie przy pomocy Ctrl+R, polecenie \texttt{history}).

\subsubsection{screen i tmux}
\texttt{screen} i \texttt{tmux} są tzw. multiplexerami terminala - pozwala na uzyskanie wielu okien konsoli (także np. wyświetlanych jedno obok drugiego) na pojedynczym terminalu.
Ponadto pozwalają na odłączanie i podłączanie sesji, co pozwala na łatwe pozostawienie działającego programu po wylogowaniu i powrót do niego później.

\subsection{Komendy}

Unixowe komendy (czyli polecenia rozumiane przez bash lub inny interpreter zgodny z sh) składają się z nazwy polecenia oraz opcji i argumentów.
Nazwą polecenia może być nazwa funkcji wbudowanej, nazwa programu (znajdującego się w ścieżce wyszukiwania programów) lub pełna ścieżka do programu.
Po nazwie polecenia mogą występować opcje i/lub argumenty. Są one oddzielane od nazwy polecenia i od siebie przy pomocy spacji\footnote{
	zasadniczo dowolnego ciągu białych znaków: spacji, tabulatorów, ,,escapowanych'' nowych linii.
}.
Nie ma silnego rozróżnienia opcji od argumentów, typowo stosowaną konwencją jest rozpoczynanie opcji od pojedynczego myślnika (opcje krótkie - jednoliterowe) lub dwóch myślników (opcje długie).
	W przypadku stosowania tej konwencji po pojedynczym myślniku może występować kilka bezargumentowych opcji jednoliterowych.
	Typowo argumenty opcji oddzielane są od nich spacją (w przypadku opcji krótkich) lub znakiem równości (w przypadku opcji długich).
Jeżeli któryś z składników komendy (np. argument) zawiera spacje należy je zabezpieczyć przy pomocy odwrotnego ukośnika lub ujęcia zawierającego je napisu w apostrofy lub cudzysłowia.

\subsection{Uzyskiwanie pomocy}

Informację na temat działania danej komendy oraz jej opcji można uzyskać w wbudowanym systemie pomocy przy pomocy poleceń \Verb{man} lub \Verb{info} / \Verb{pinfo}.
Większość poleceń obsługuje także opcje \Verb{--help} lub \Verb{-h}, które wyświetlają informację na temat ich użycia.

\pagebreak[2]\begin{ProTip}{\normalfont{\strong{Do zapamiętania}}}
Zarówno w tekstach pomocy jak i w tym dokumencie stosowana jest konwencja polegająca na oznaczaniu opcjonalnych argumentów poprzez umieszczanie ich w nawiasach kwadartowych (jeżeli podajemy ten argument do komendy nie obejmujemy go już tymi nawiasami) oraz rozdzielaniu alternatywnych opcji przy pomocy~\Verb{|}. Np. \Verb{a [b] c|d} oznacza iż polecenie \Verb{a} wymaga argumentu postaci \Verb{c} albo \Verb{d}, który może być poprzedzony argumentem \Verb{b}.
\end{ProTip}

\subsection{more i less}

Jeżeli wynik jakiejś komendy nie mieści się na ekranie do jego obejrzenia możemy użyć poleceń \Verb{more} lub \Verb{less}. Są to programy umożliwiające przeglądanie tekstu ekran po ekranie.
\Verb{less} posiada większe możliwości od more (w szczególności posiada możliwość przeglądanie dokumentu w tył)\footnote{
wybrane przydatne opcje:
	\Verb{-X} nie czyści ekranu przy wychodzeniu z less'a (całość historii wyświetlania pliku pozostaje w historii terminala)
	\Verb{-F} automatycznie kończy gdy wyświetlany tekst mieści się na jednym ekranie
}. Programy te kończą się po wciśnięciu klawisza \Verb{q}. \Verb{less} umożliwia także wyszukiwanie -- klawisz \Verb{/} pozwala na wprowadzenie szukanej frazy, a \Verb{n} na wyszukanie kolejnego wystąpienia.
Programy te umożliwiają też wyświetlanie wskazanych jako argumenty plików.

\subsection{Przekierowania}

Typowo program posiada trzy strumienie danych: jednen wejściowy (stdin) i dwa wyjściowe (stdout i stderr). Standardowe wyjście możemy przekierować na standardowe wejście innego programu przy pomocy~\Verb{|}, np:
\begin{Verbatim}
ls --help | less
\end{Verbatim}
Konstrukcja ta przekieruje wynik komendy \Verb{ls} uruchomionej z opcją \Verb{--help} do komendy \Verb{less}.

Możemy także przekierować standardowe wyjście do pliku (przy pomocy~\Verb{>} lub~\Verb{>>}, gdy chcemy dopisywać do pliku) lub pobrać standardowe wejście z pliku (przy pomocy \Verb{<}).
\Verb{2>} pozwala na przekierowanie standardowego wyjścia błędu do pliku, a \Verb{>&} i \Verb{|&} pozwala na przekierowanie obu strumieni odpowiednio do pliku lub standardowego wejścia innego polecenia.
% END: unix intro

% BEGIN: vi i vim
\subsection{vi i vim}
\Verb{vi} jest chyba najbardziej zaawansowanym edytorem, którego obecność gwarantuje standard POSIX\footnote{IEEE Std 1003.1-2017 (The Open Group Base Specifications Issue 7, 2018 edition), XCU part \url{https://pubs.opengroup.org/onlinepubs/9699919799/}}.
\Verb{vim} jest mocno rozbudowanym jego klonem, oferującym bardzo zaawansowane funkcjonalności, powszechnie stosowanym jako zamiennik oryginalnego \Verb{vi}.
\Verb{vim} obsługuje 3 podstawowe tryby pracy: komend (służący do wydawania opisanych niżej poleceń), wizualny (służący do zaznaczania i wydawania niektórych komend), edycji (wstawiania/nadpisywania - służący do wprowadzania tekstu).
Podstawowa klawiszologia:
\begin{itemize}
\item \Verb{Esc} powrót do trybu komend
\item \Verb{i} tryb wstawiania
\item \Verb{R} tryb zastępowania
\item \Verb{Insert} zmiana trybu wstawiania i zastępowania
\item \Verb{v} tryb wizualny (umożliwia zaznaczenie przy pomocy strzałek)

\vspace{6pt}

\item \Verb{y} skopiuj; \Verb{d} - wytnij (skopiuj i usuń)\\
	po \Verb{y}, \Verb{d} można podać np. \texttt{20l} lub \texttt{20[strzałka w prawo]} co oznacza 20 kolejnych znaków, \texttt{2w}~oznacza dwa słowa
\item \Verb{x} wytnij (skopiuj i usuń) znak (może być poprzedzone ilością znaków do wycięcia)
\item \Verb{yy} skopiuj linię; \Verb{dd} - wytnij (skopiuj i usuń)\\
	w obu wypadkach może być poprzedzone ilością linii do skopiowania/wycięcia

\vspace{6pt}

\item \Verb{p} wkleja po; \Verb{P} - wkleja przed
\item \Verb{u} cofa ostatnią operację

\vspace{6pt}

\item \Verb{/} szukanie
\item \Verb{n} wyszukanie następnego wystąpienie; \Verb{N} wyszukanie poprzedniego wystąpienie
\item \Verb{G} przejście do wskazanej linii, numer podajemy przed G, 0 oznacza ostatnią linię w pliku, więc \Verb{0G} spowoduje przejście do niej

\vspace{6pt}

\item \Verb{:[zakres]s@regexp@napis@[g]} wyszukaj i zastąp wyrażenie regularne regexp przez napis;
	zakres może być:
	\begin{itemize}
		\item numerem linii,
		\item przedziałem z numerami linii postaci \Verb{pierwsza,ostatnia}, gdzie:\\
			\Verb{.}~oznacza bieżącą linię,
			\Verb{$}~oznacza ostatnią linię w pliku,
			wartość numeryczna poprzedzona \Verb{+}~oznacza tyle kolejnych linii od bieżącej, a poprzedzona \Verb{-}~przed bieżącą,
		\item znakiem \Verb{%} (co oznacza cały plik),
		\item zakresem zaznaczonym w trybie wizualnym;
	\end{itemize}
	podanie opcji g powoduje zastępowanie wszystkich wystąpień a nie tylko pierwszego;\\
	znak \Verb{@} pełni rolę separatora i może zostać zamiast niego użyty inny znak

\vspace{6pt}

\item \Verb{:e ścieżka} otwarcie wskazanego pliku
\item \Verb{:w} zapis (można także podać ścieżkę pod jaka ma zostać zapisany plik)
\item \Verb{:q} wyjście
      ;
      \Verb{:q!} wyjście bez zapisywania
      ;
      \Verb{:wq} zapis i wyjście

\vspace{6pt}

\item \Verb{:n} - następny plik
      ;
      \Verb{:N} - poprzedni plik
\item \Verb{:split} - podział okna
      ;
      \Verb{:vs} - pionowy podział okna
      ;
      \Verb{Ctrl}+\Verb{W} a następnie strzałka - przełączanie między oknami

\vspace{6pt}

\item \Verb{:%!xxd} pokazanie wartości numerycznych i umożliwienie edycji pliku jako binarnego;
      \\
      \Verb{:%!xxd -r} powrót do normalnej edycji
\end{itemize}
% END: vi i vim

\section{Operacje na systemie plików}

\subsection{Podstawowe komendy}

\teacher{Pokazać i omówić działanie komend wykonując je w terminalu na rzutniku}

% BEGIN: Operacje na systemie plików
\subsubsection{katalog roboczy}
\begin{itemize}
	\item \Verb{cd [ścieżka]}
		zmiana bieżącego katalogu,\\
			warto zauważyć, iż katalogi w ścieżce oddzielamy ukośnikami \texttt{/}, bieżący katalog oznaczamy kropką \texttt{.}, nadrzędny oznaczamy dwiema kropkami \texttt{..},\\
			ścieżki zaczynające się od ukośnika \texttt{/} oznaczają \emph{ścieżki bezwzględne} (od korzenia systemu plików), pozostałe oznaczają \emph{ścieżkę względną} (wyrażoną względem bierzącego katalogu),\\
			katalog domowy oznacza się tyldą\ \ \texttt{\~}
		
	\item \Verb{pwd}
		wyświetla ścieżkę do bieżącego katalogu
\end{itemize}

\subsubsection{wyświetlanie i wyszukiwanie}
\teacher{Już na początku omawiania \texttt{ls} warto omówić znaki uogólniające - patrz poniżej}
\begin{itemize}
	\item \Verb{ls [opcje] [ścieżka]}
		listowanie zawartości katalogu, do ważniejszych opcji należy zaliczyć:\\
			\texttt{-a} wyświetlaj pliki ukryte (zaczynających się od kropki)\\
			\texttt{-l} wyświetlaj pliki w formie listy z szczegółowymi informacjami (uprawnienia, rozmiar, data modyfikacji, właściciel, grupa, rozmiar)\\
			\texttt{-1} wyświetlaj pliki w formie 1 plik w jednej linii (bez dodatkowych informacji; stosowane domyślne gdy wynik komendy przekazywany jest strumieniem do innej komendy lub pliku)\\
			\texttt{-h} stosuj jednostki typu k, M, G zamiast podawać rozmiar w bajtach\\
			\texttt{-t} sortuj wg daty modyfikacji\\
			\texttt{-S} sortuj wg rozmiaru\\
			\texttt{-r} odwróć kolejność sortowania\\
			\texttt{-c} użyj daty utworzenia zamiast daty modyfikacji (stosowane w połączeniu z \texttt{-l} i/lub \texttt{-t})\\
			\texttt{-d} wyświetlaj informacje o katalogu zamiast jego zawartości
		
	\item \Verb{find [opcje] [katalog startowy] [wyrażenie]}
		wyszukiwanie w systemie plików w oparciu o nazwę/ścieżkę lub właściwości pliku, do ważniejszych opcji należy zaliczyć:\\
			\texttt{-P} wypisuj informacje o linkach symbolicznych a nie plikach przez nie wskazywanych (domyślne)\\
			\texttt{-L} wypisuj informacje o wskazywanych przez linki symboliczne plikach\\
		do ważniejszych elementów wyrażenia należy zaliczyć:\\
			\texttt{-name "wyrażenie"} pliki których nazwa pasuje do wyrażenia korzystającego z shellowych znaków uogólniających\\
				komenda find (w odróżnieniu np. od \texttt{ls}) samodzielnie interpretują wyrażenia zawierające shellowe znaki uogólniające, w związku z czym konieczne może się okazać zabezpieczenie ich przed interpretacją przez powłokę np. przy pomocy umieszczenia wewnątrz pojedynczych cudzysłowów\\
			\texttt{-iname "wyrażenie"} jak \texttt{-name}, tyle że nie rozróżnia wielkości liter\\
			\texttt{-path "wyrażenie"} pliki których ścieżka pasuje do wyrażenia korzystającego z shellowych znaków uogólniających\\
			\texttt{-ipath "wyrażenie"} jak \texttt{-path}, tyle że nie rozróżnia wielkości liter\\
			\texttt{-regex "wyrażenie"} pliki których ścieżka pasuje do wyrażenia regularnego\\
			\texttt{-iregex "wyrażenie"} jak \texttt{-regexp}, tyle że nie rozróżnia wielkości liter\vspace{6pt}\\
			%
			\texttt{warunek -o warunek} łączy warunki sumą logiczną „OR” (zamiast domyślnego iloczynu logicznego „AND”)\\
			\texttt{! warunek} negacja warunku\vspace{6pt}\\
			%
			\texttt{-mtime [+|-]n} pliki których modyfikacja odbyła się \texttt{n}*24 godziny temu\\
			\texttt{-mmin [+|-]n} pliki których modyfikacja odbyła się \texttt{n} minut temu\\
			\texttt{-ctime [+|-]n} pliki które zostały utworzone \texttt{n}*24 godziny temu\\
			\texttt{-cmin [+|-]n} pliki które zostały utworzone \texttt{n} minut temu\\
			\texttt{-size [+|-]n[c|k|M|G]} pliki których rozmiar wynosi \texttt{n} (c - bajtów, k - kilobajtów, M - Megabajtów, G - gigabajtów)\\
			\strong{\emph{w powyższych testach \texttt{+} oznacza więcej niż, \texttt{-} oznacza mniej niż, uwaga: porównywaniu podlegają liczby całkowite, np. +1 oznaczacza $>1$ w liczbach całkowitych tzn. $\ge2$}}\vspace{6pt}\\
			%
			\texttt{-exec}\Verb@ polecenie \{\} \;@ dla każdego znalezionego pliku wykonaj \texttt{polecenie} podstawiając ścieżkę do tego pliku pod \Verb@\{\}@ (zastosowane odwrotne ukośniki służą zabezpieczeniu nawiasów klamrowych i średnika przed zinterpretowaniem ich przez powłokę)\\
			\Verb@-execdir polecenie \{\} \;@, podobnie jak \texttt{-exec} tyle że polecenie zostanie uruchomione w katalogu w którym znajduje się wyszukany plik
		
	\item \Verb{du [opcje] ścieżka1 [ścieżka2 [...]]}
		wyświetlanie informacji o zajętej przestrzeni dyskowej przez wskazane pliki / katalogi, do ważniejszych opcji należy zaliczyć:\\
			\texttt{-s} podaje łączną ilość zajętego miejsca dla każdego argumentów (zamiast wypisywać rozmiar każdego pliku)\\
			\texttt{-c} podaje łączną ilość zajętego miejsca dla wszystkich argumentów\\
			\texttt{-h} stosuje jednostki typu k, M, G\\
		podawany rozmiar może się różnić (w obie strony) od wyniku ls: ls podaje rozmiar pliku (ile zawiera informacji lub ile zostało zadekarowane że może jej zawierać), a du to ile zajmuje na dysku
		
	\item \Verb{df [opcje]}
		wyświetlanie informacji o zajętości miejsca na poszczególnych systemach plików
\end{itemize}

\noindent W ścieżkach i nazwach plików można korzystać z znaków uogólniających powłoki takich jak:
\begin{itemize}
	\item \Verb{?} oznaczający dowolny znak
	\item \Verb{*} oznaczający dowolny (także pusty) ciąg znaków
	\item \Verb{[a-z AD]} oznaczający dowolny znak z wymienionych w zbiorze ujętym w nawiasach kwadratowych, zbiór może być definiowany z użyciem zakresów, np. a-z AD oznacza dowolną małą literę od a do z włącznie, spację, dużą literą A lub D
	\item \Verb{[!a-z]} oznaczający dowolny znak z wyjątkiem znaków wymienionych w podanym zbiorze, zbiór może być definiowany z użyciem zakresów, np. a-z oznacza dowolną małą literę od a do z włącznie
\end{itemize}
Ścieżki mogą być podawane także jako napisy ujęte w cudzysłowie pojedynczym (\texttt{'}, np. \texttt{'aaa bbb'}) lub podwójnym (\texttt{"}, np. \texttt{"aaa bbb"}) celem np. ochrony spacji w nich występujących.
Oba typy cudzysłowów zabezpieczają przed rozwijaniem znaków uogólniających (zastępowaniem napisu ze znakami listą pasujących nazw / ścieżek). Cudzysłów pojedynczy (w odróżnieniu od podwójnego) zabezpiecza także przed interpretacją umieszczonych wewnątrz innych znaków specjalnych takich jak odwołania do zmiennych.

\begin{teacherOnly}
Warto omówić następujące przykłady:
\begin{Verbatim}
# pliki z jednoznakową nazwą
ls ?
# pliki zaczynające się od znaku zapytania
ls \?*
# pliki nie zaczynające się od a
ls [!a]*
# pliki mające w nazwie literę b
ls *b*
# pliki mające w nazwie literę a lub b
ls *[ab]*
# pliki zaczynające się od liter a,b,c,d
ls [a-d]*
\end{Verbatim}
\end{teacherOnly}

Warto zauważyć, iż w przypadku komendy \texttt{ls} znaki uogólniające muszą być rozwinięte przez powłokę.
Natomiast w przypadku komendy \texttt{find} na ogół chcemy aby nie były rozwijane przez powłokę, ale interpretowane przez samą komendę \texttt{find}.
W tym celu powinniśmy je zabezpieczyć przed rozwinięciem przy pomocy cudzysłowów.

Zauważ również, że jeżeli komanda \texttt{ls} w wyniku rozwinięcia znaków uogólniających dostanie jako argument ścieżkę do katalogu to wylistuje jego zawartość (zachowanie to zmienia opcja \texttt{-d}).

\subsubsection{kopiowanie, przenoszenie, usuwanie, ...}
\begin{itemize}
	\item \Verb{cp [opcje] źródło1 [źródło2 [...]] cel}
		kopiuje wskazany plik (lub pliki) do wskazanej lokalizacji, w przypadku kopiowania wielu plików cel powinien być katalogiem, do ważniejszych opcji należy zaliczyć:\\
			\texttt{-r} pozwala na (rekursywne) kopiowanie katalogów\\
			\texttt{-a} podobnie jak \texttt{-r}, dodatkowo zachowując atrybuty plików\\
			\texttt{-l} zamiast kopiować tworzy twarde dowiązania (hard links)\\
			\texttt{-s} zamiast kopiować tworzy linki symboliczne do plików\\
			\texttt{-f} nadpisywanie bez pytania\\
			\texttt{-i} zawsze pytaj przed nadpisaniem
		
	\item \Verb{ln źródło1 [źródło2 [...]] cel}
		tworzy link twardy do wskazanego pliku (lub plików) w wskazanej lokalizacji, w przypadku wskazania wielu plików źródłowych cel powinien być katalogiem, do ważniejszych opcji należy zaliczyć:\\
			\texttt{-s} tworzy dowiązania symboliczne zamiast twardych\\
			\texttt{-r} używa ścieżki względnej zamiast bezwzględnej przy tworzeniu dowiązań symbolicznych
				\\
				Link twardy jest innym uchwytem do tych samych danych i może być używany także po skasowaniu oryginalnego pliku. Liczbę dowiązań do danego pliku pokazuje m.in. komenda \Verb{ls} z opcją \Verb{-l}.
				Nie można utworzyć linków twardych do katalogów, ani do plików na innym zasobie dyskowym (innym systemie plików).
				\\
				Link symboliczny wskazuje na konkretną ścieżkę (względną lub bezwzględną – co może mieć znaczenie przy przenoszeniu takiego linku) do dowolnego (nawet nie istniejącego – wtedy mówimy o zerwanym linku) pliku lub katalogu.
				\vspace{5pt}\\\hspace*{1cm}\includegraphics[width=0.75\textwidth]{link_twardy_i_symboliczny}
		
	\item \Verb{mv [opcje] źródło1 [źródło2 [...]] cel}
		przenosi wskazane pliki / katalogi do wskazanej lokalizacji, w przypadku przenoszenia wielu plików cel powinien być katalogiem, do ważniejszych opcji należy zaliczyć:\\
			\texttt{-f} nadpisywanie bez pytania\\
			\texttt{-i} zawsze pytaj przed nadpisaniem
		
	\item \Verb{rm [opcje] ścieżka1 [ścieżka2 [...]]}
		usuwa wskazane pliki, do ważniejszych opcji należy zaliczyć:\\
			\texttt{-r} pozwala na na (rekursywne) kasowanie katalogów wraz z zawartością\\
			\texttt{-f} usuwanie bez pytania\\
			\texttt{-i} zawsze pytaj przed usunięciem
			
	\item \Verb{mkdir [opcje] ścieżka1 [ścieżka2 [...]]}
		tworzy wskazane katalogi, do ważniejszych opcji należy zaliczyć:\\
			\texttt{-p} pozwala na tworzenie całej ścieżki a nie tylko ostatniego elementu, nie zgłasza błędu gdy wskazany katalog istnieje
\end{itemize}
% END: Operacje na systemie plików

% BEGIN: Struktura katalogów
\subsection{Struktura katalogów}

Systemy unix'owe posiadają drzewiasty system plików zaczynający się w katalogu głównym oznaczanym przez ukośnik (\texttt{/}), w którym zamontowany jest główny system plików (rootfs), inne systemy plików mogą być montowane w kolejnych katalogach. Do najistotniejszych katalogów należy zaliczyć:
\begin{itemize}
	\item \Verb{/bin}
	      zawierający pliki wykonywalne podstawowych programów
	\item \Verb{/sbin}
	      zawierający pliki wykonywalne podstawowych programów administracyjnych
	\item \Verb{/lib}
	      zawierający pliki podstawowych bibliotek
	\item \Verb{/usr}
	      zawierający oprogramowanie dodatkowe (wewnętrznie ma podobną strukturę do głównego - tzn. katalogi \texttt{/usr/bin}, \texttt{/usr/sbin}, \texttt{/usr/lib}, itd)
	
	\vspace{6pt}
	
	\item \Verb{/etc}
	      zawierający konfiguracje ogólnosystemowe
	\item \Verb{/var}
	      zawierający dane programów i usług (takie jak kolejka poczty, harmonogramy zadań, bazy danych)
	\item \Verb{/home}
	      zawierający katalogi domowe użytkowników (często montowany z innego systemu plików, dlatego też root ma swój katalog domowy w \texttt{/root}, aby był dostępny nawet gdy takie montowanie nie doszło do skutku)
	\item \Verb{/tmp}
	      zawierający pliki tymczasowe (typowo czyszczony przy starcie systemu); w Linuxie występuje też \texttt{/run} przeznaczony do trzymania danych tymczasowych działających usług takich jak numery pid, blokady, itp
	
	\vspace{6pt}
	
	\item \Verb{/dev}
	      zawierający pliki reprezentujące urządzenia; w Linuxie występuje też \texttt{/sys} zawierający informacje i ustawienia dotyczące m.in. urządzeń
	\item \Verb{/proc}
	      zawierający informacje o działających procesach (w Linuxie także interfejs konfiguracyjny dla wielu parametrów jądra)
\end{itemize}
Pliki i katalogi których nazwa rozpoczyna się od kropki traktowane są jako pliki ukryte.

Z punktu widzenia programisty czy też użytkownika (prawie) wszystko jest plikiem, których istnieją różne rodzaje (zwykły plik, katalog, urządzenie znakowe, urządzenie blokowe, link symboliczny, kolejka FIFO, ...); pewnym wyjątkiem są urządzenia sieciowe (które nie mają reprezentacji w systemie plików (ale gniazda związane z nawiązanymi połączeniami obsługuje się zasadniczo tak jak pliki).
% END: Struktura katalogów

\setcounter{subsection}{0} % \subsection{zadania}

% BEGIN: system plikow - zadania
\begin{Zadanie}{}{lsetc}
Wyświetlić nazwy (mogą być wraz z pełną ścieżką) wszystkich plików i katalogów znajdujących się bezpośrednio w \texttt{/etc/} których druga litera to \texttt{a} natomiast trzecia to \texttt{p} lub \texttt{s}.

\emph{Wskazówka: to zadanie nie wymaga stosowania find.}
\end{Zadanie}

\begin{Zadanie}{}{findetc}
Wyszukaj (rekurencyjnie) wszystkie pliki w katalogu \texttt{/etc/} zmodyfikowane w przeciągu ostatnich 48 godzin.
\end{Zadanie}

\begin{Zadanie}{}{linki_symboliczne}
Utworzyć w katalogu \texttt{/tmp} linki symboliczne \texttt{ll1} i \texttt{ll2} wskazujące na \texttt{/etc/passwd} odpowiednio poprzez ścieżkę bezwzględną i względną.
\end{Zadanie}

\begin{Zadanie}{}{findetc2}
Zmodyfikuj rozwiązanie zadania \ref{findetc} tak aby wyświetlać szczegóły (w tym datę modyfikacji) dla wyszukanych plików.
\end{Zadanie}
% END: system plikow - zadania


% BEGIN: ssh
\section{Praca zdalna}
\subsection{powłoka zdalna}
Komenda
\texttt{ssh [user@]host}
umożliwia uzyskanie powłoki zdalnego systemu poprzez szyfrowane połączenie, przydatne opcje:\\
	\texttt{-L portLokalny:hostZdalny:portZdalny} tworzy tunel przekierowujący dane kierowane na portLokalny komputera na którym działa klient ssh do portu portZdalny na serwerze hostZdalny poprzez serwer SSH (przydatne gdy hostZdalny jest osiągalny z hostSSH ale nie z komputera lokalnego)\\
	\texttt{-D port} tworzy tunel dynamiczny na wskazanym porcie (może on być użyty jako proxy typu SOCKS np. w Firefoxie w celu zapewnienia dostępu do zasobów WWW dostępnych z serwera SSH a niedostępny z komputera lokalnego)\\
	\texttt{-p port} określa inny niż domyślny port serwera SSH\\
	\texttt{-X} aktywuje przekazywanie komend X serwera ze strony zdalnej do klienta (pozwala na uruchomienie po stronie zdalnej aplikacji z GUI, które zostanie wyświetlone na lokalnym X serwerze)
% END: ssh

% BEGIN: zdalne kopiowanie
\subsection{zdalne kopiowanie}
Najprostszą metą kopiowania plików pomiędzy różnymi systemami jest wykorzystanie do tego ssh, typowo robi się to na jeden z 3 sposobów:
\begin{itemize}
	\item poleceniem
		\texttt{scp [opcje] źródło1 [źródło2 [...]] cel}
		, które
		kopiuje wskazany plik (lub pliki) do wskazanej lokalizacji, w przypadku kopiowania wielu plików cel powinien być katalogiem, do ważniejszych opcji należy zaliczyć:\\
		\texttt{-r} pozwala na (rekursywne) kopiowanie katalogów\\
		\texttt{-P port} określa port SSH\\
		W odróżnieniu od \texttt{cp} źródło lub cel w postaci \texttt{[user@]host:[ścieżka]} wskazują na zdalny system dostępny poprzez SSH.
	\item poleceniem
		\texttt{rsync [opcje] źródło cel}
		, które
		kopiuje (synchronizacjiuje) pliki i drzewa katalogów (zarówno lokalnie jak i zdalnie), do ważniejszych opcji należy zaliczyć:\\
			\texttt{-r} pozwala na (rekursywne) kopiowanie katalogów\\
			\texttt{-l} kopiuje linki symboliczne jako linki symboliczne (zamiast kopiowania zawartości pliku na który wskazują)\\
			\texttt{-t} zachowuje czas modyfikacji plików\\
			\texttt{-u} kopiuje tylko gdy plik źródłowy nowszy niż docelowy\\
			\texttt{-c} kopiuje tylko gdy plik źródłowy i docelowy mają inne sumy kontrolne\\
			\texttt{--delete} usuwa z docelowego drzewa katalogów elementy nie występujące w drzewie źródłowym\vspace{6pt}\\
			%
			\texttt{-e 'ssh'} pozwala na kopiowanie na/z zdalnych systemów za pośrednictwem ssh, źródło lub cel w postaci \texttt{[user@]host:[ścieżka]} wskazują na zdalny system
			\texttt{--partial --partial-dir=."-tmp-"} zachowuje skopiowane częściowo pliki w katalogu .-tmp- (pozwala na przerwanie i wznowienie transferu pliku)\\
			\texttt{--progress} pokazuje postęp kopiowania\\
			\texttt{--exclude="wzorzec"} pomija (w kopiowaniu i kasowaniu) pliki pasujące do wzorzec (wzorzec może zawierać znaki uogólniające powłoki)
			\texttt{-n} symuluje pracę (pokazuje co zostałoby skopiowane, ale nie kopiuje)
	\item złożonego polecenia opartego na przekierowaniu wyjścia jakiejś komendy do ssh, które uruchamia po zdalnej stronie proces odbierający te dane na swoim standardowym wejściu, np.:
		\begin{itemize}
			\item \Verb{tar -czf - ścieżka1 [ścieżka2 [...]] | ssh [user@]host 'cat > plik.tgz'}\\
				archiwizuje wskazane pliki/katalogi bezpośrednio na zdalny system z użyciem tar i kompresji gzip do pliku \texttt{plik.tgz}
			\item \Verb{tar -cf - ścieżka1 [ścieżka2 [...]] | ssh [user@]host 'tar -xf - -C cel'}\\
				kopiuje wskazane pliki/katalogi na zdalny system z użyciem tar do katalogu \texttt{cel}
		\end{itemize}
\end{itemize}
% END: zdalne kopiowanie

\setcounter{subsection}{0} % \subsection{zadania}

% BEGIN: zadania - ssh
\begin{Zadanie}{}{sshls}
Wylistuj zawartość /etc/ z wskazanej maszyny zdalnej.
\end{Zadanie}

\begin{Zadanie}{}{remote_copy}
Skopiuj plik /etc/hostname z wskazanej maszyny zdalnej do /tmp/hostname.
\end{Zadanie}
% END: zadania - ssh

% BEGIN: grep
\section{Operacje na plikach}
\subsection{grep i wyrażenia regularne}

Polecenie
\texttt{grep [opcje] wyrażenie [plik1 [plik2 [...]]]}
wyszukuje pasujące do wyrażenia regularnego wyrażenie linie w plikach, przydatne opcje:\\
	\texttt{-v} zamiast pasujących wypisz nie pasujące\\
	\texttt{-i} ignoruj wielkość liter\\
	\texttt{-a} przetwarzaj pliki binarne jak tekstowe\\
	\texttt{-E} korzystaj z ,,\emph{Extended Regular Expressions}'' (ERE) zamiast ,,\emph{Basic Regular Expressions}'' (BRE)\vspace{6pt}\\
	\texttt{-P} korzystaj z ,,\emph{Perl-compatible Regular Expressions}'' (PCRE) zamiast ,,\emph{Basic Regular Expressions}'' (BRE)\vspace{6pt}\\
	%
	\texttt{-r} rekursywnie przetwarzaj podane katalogi wyszukując w wszystkich znalezionych plikach\\
	\texttt{-R} jak -r, ale zawsze podąża za linkami symbolicznymi\\
	\texttt{--exclude="wyrażenie"} pomiń pliki pasujące do wyrażenie (może zawierać znaki uogólniające powłoki)\vspace{6pt}\\
	%
	\texttt{-l} wypisuje pliki z pasującymi liniami\\
	\texttt{-L} wypisuje pliki z bez pasujących linii

\vspace{13pt}\noindent Wyrażenia regularne\footnote{
	Podana składnia dotyczy ,,\emph{Extended Regular Expressions}'', przy BRE niektóre z znaków sterujących wymagają zabezpieczenia odwrotnym ukośnikiem.
} konstruuje się w oparciu o następujące znaki specjalne:
\vspace{-6pt}\begin{Verbatim}
.      - dowolny znak
[a-z]  - znak z zakresu
[^a-z] - znak z poza zakresu (aby mieć zakres z ^ należy dać go nie na początku)
^      - początek napisu/linii
$      - koniec napisu/linii

*      - dowolna ilość powtórzeń
?      - 0 lub jedno powtórzenie
+      - jedno lub więcej powtórzeń
{n,m}  - od n do m powtórzeń

()     - pod-wyrażenie (może być używane dla powtórzeń, a także referencji wstecznych)
\end{Verbatim}

\begin{teacherOnly}
Należy wspomnieć o historii, różnych formatach wyrażeń regularnych, kompatybilności wstecznej, czyli dlaczego
	\Verb#grep '^.\?$'# to to samo co \Verb#grep -E '^.?$'# i dlaczego w niektórych przypadkach stosujemy jedną a w innych inną notację.

Należy zwrócić uwagę na ,,pazerność'' dopasowań - na ogół dopasowawany najdłuższy możliwy fragment:\\
\Verb{echo '<a xx="oo" />bb<a yy="ii" />' | \grep -E --color '<a.*/>'} a:\\
\Verb{echo '<a xx="oo" />bb<a yy="ii" />' | \grep -E --color '<a[^>]*/>'} vs:\\
\Verb{echo '<a xx="oo" />bb<a yy="ii" />' | \grep -P --color '<a.*?/>'}

Wspomnieć także o opcji -x wymagającej dopasowania całej linii.
\end{teacherOnly}
% END: grep

\subsection{sed i inne narzędzia przetwarzania tekstów}
\begin{itemize}
	% BEGIN: sed
	\item \Verb{sed [opcje] [pliki]}
		edytuje plik zgodnie z podanymi poleceniami, przydatne opcje:\\
			\texttt{-e "polecenie"} - wykonuj na pliku polecenie (może wystąpić wielokrotnie celem podania wielu poleceń)\\
			\texttt{-f "plik"} - wczytaj polecenia z pliku plik\\
			\texttt{-E} - używaj rozszerzonych wyrażeń regularnych\\
			\texttt{-i} - modyfikuj podany plik zamiast wypisywać zmieniony na stdout\\
		przydatne polecenia:\\
			\texttt{s@regexp@napis@[g]} - wyszukaj dopasowania do wyrażenia regularnego regexp i zastąp je przez napis, podanie opcji g powoduje zastępowanie wszystkich wystąpień a nie tylko pierwszego, znak \texttt{@} pełni rolę separatora i może zostać zamiast niego użyty inny znak\\
			\texttt{y@zbiór1@zbiór2@} - zastąp znaki z zbiór1 znakami odpowiadającymi im pod względem kolejności znakami z zbiór2, znak \texttt{@} pełni rolę separatora i może zostać zamiast niego użyty inny znak\\
		możliwe jest też m.in. adresowanie linii na których ma być wykonywana operacja, np: \texttt{0,/regexp/ s@regexp@napis@} wykona polecenie s na liniach od początku pliku do linii pasującej do wyrażenia regularnego regexp, czyli zastąpi tylko pierwsze wystąpienie w pliku
	% END: sed
	
	\vspace{6pt}
	
	% BEGIN: tail head
	\item \Verb{tail [opcje] [plik]}
		wyświetla ostatnie linie pliku, przydatne opcje:\\
			\texttt{-n x} określa że ma zostać wyświetlone x ostatnich linii\\
			\texttt{-f} uruchamia dopisywania (gdy do pliku zostaną dopisane nowe linie tail je wyświetli)
	\item \Verb{head [opcje] [plik]}
		wyświetla początkowe linie pliku, przydatne opcje:\\
			\texttt{-n x} określa że ma zostać wyświetlone x pierwszych linii
	% END: tail head
	
	\vspace{6pt}
	
	% BEGIN: diff patch
	\item \Verb{diff ścieżka1 ścieżka2}
		porównuje pliki lub katalogi (w przypadku tych drugich porównuje ze sobą pliki o takich samych nazwach oraz zgłasza fakt występowania pliku tylko w jednym z katalogów), przydatne opcje:\\
			\texttt{-r} rekursywnie przetwarzaj podane katalogi\\
			\texttt{-u} wypisuje różnice w formacie "unified"\\
			\texttt{-c} wypisuje różnice w formacie "context"
	\item \Verb{patch}
	stosuje plik łaty (wynik diff'a) w celu zmodyfikowania plików, typowo:\\
		\texttt{patch -pn < plik.diff} co powoduje zastosowanie zmian opisanych w plik.diff na plikach w bieżącym katalogu,
		n określa ilość poziomów ścieżek podanych w pliku łaty które mają zostać zignorowane
	% END: diff patch
	% BEGIN: sort
	\item \Verb{sort [plik]}
		sortuje linie w wskazanym pliku, przydatne opcje:\\
			\texttt{-n} traktuj liczby jako wartości numeryczne a nie napisy\\
			\texttt{-i} ignoruj wielkość liter\\
			\texttt{-r} odwróć kolejność sortowania\\
			\texttt{-k n} sortuj wg kolumny n\\
			\texttt{-t sep} kolumny rozdzielane są przy pomocy separatora sep
	% END: sort
	
	\vspace{6pt}
	
	% BEGIN: cut
	\item \Verb{cut [opcje] [pliki]}
		wybiera z pliku zadany zestaw kolumn, przydatne opcje:\\
			\texttt{-f nnn} wypierz kolumny określone przez nnn (np. 1,3-4,6- oznacza kolumnę 1, kolumny od 3 do 4 i od 6, a -3 oznacza 3 pierwsze kolumny)\\
			\texttt{-d sep} kolumny rozdzielane są przy pomocy separatora sep (musi być pojedynczym jedno bajtowym znakiem, aby ominąć to ograniczenie należy skorzystać z awk)
	% END: cut
	% BEGIN: paste join comm uniq
	\item \Verb{paste}
		łączy (odpowiadające sobie pod względem numerów) linie z dwóch plików
	\item \Verb{join}
		łączy linie  z dwóch plików w oparciu o porównanie wskazanego pola
	\item \Verb{comm}
		porównuje dwa posortowane pliki pod względem unikalności linii (może wypisać wspólne lub występujące tylko w jednym z plików)
	\item \Verb{uniq}
		usuwa powtarzające się linie z posortowanego pliku, przydatne opcje:\\
			\texttt{-c} wypisz liczbę powtórzeń\\
			\texttt{-d} wypisz tylko linie z 2 lub więcej wystąpieniami\\
			\texttt{-u} wypisz tylko linie z 1 wystąpieniem
	% END: paste join comm uniq
\end{itemize}

\setcounter{subsection}{0} % \subsection{zadania}

% BEGIN: zadania - unix napisy 01
\begin{Zadanie}{}{upper_false}
Wyświetl plik \texttt{/etc/passwd} z zastąpionym \texttt{false} przez \texttt{FALSE}.
\end{Zadanie}

\begin{Zadanie}{}{ls_nazwy}
Polecenie \Verb#ls -1d /etc/p*# wyświetla pełne ścieżki do plików, znajdujących się (bezpośrednio) w \texttt{/etc/}, których nazwa zaczyna się literą \texttt{p}.
Przekieruj standardowe wyjście tej komendy do takiego ciągu poleceń aby uzyskać tylko nazwy tych plików (bez ścieżki).
\end{Zadanie}

\begin{Zadanie}{}{wyszukaj_napis}
Napisz polecenie które wyszuka wszystkie wystąpienia napisu \Verb{nameserver} w plikach znajdujących się w katalogu \Verb{/etc} (wraz z jego podkatalogami).
\end{Zadanie}
% END: zadania - unix napisy 01

% BEGIN: zadania - unix napisy 02
\begin{Zadanie}{}{wyszukaj_napis2}
Zmodyfikuj rozwiązanie zadania \ref{wyszukaj_napis} tak aby wyłącznie wypisywało nazwy plików (mogą być ze ścieżką) zawierających wyszukiwany napis.
\end{Zadanie}

\begin{Zadanie}{}{lsetc2}
Wyświetlić same nazwy (bez ścieżki) wszystkich plików i katalogów znajdujących się bezpośrednio w \texttt{/etc/} których druga litera to \texttt{a} natomiast trzecia to \texttt{p} lub \texttt{s}.
Przedstaw rozwiązanie z użyciem i bez użycia komendy \texttt{cd}.
\end{Zadanie}
% END: zadania - unix napisy 02


% BEGIN: Użytkownicy, uprawnienia i procesy
\section{Użytkownicy, uprawnienia i procesy}

%Systemy ,,unixowe'' tworzone były jako wielo-użytkownikowe i wielo-procesowe, w wyniku tego posiadają 

\subsection{Uprawnienia do plików}
Podstawowe unixowe uprawnienia do plików składają się z trzech członów: uprawnienia dla właściciela (u), grupy (g) i pozostałych użytkowników (o).
W każdym z członów mogą być przyznane uprawnienia do czytania (r), pisania (w) i wykonywania (x); w odniesieniu do plików jest to intuicyjne (uprawnienie do wykonywania jest potrzebne do uruchomienia programów), natomiast w stosunku do katalogów wygląda to następująco: uprawnienia do czytania pozwalają na listowanie zawartości, do wykonania pozwalają na dostęp, do zawartości katalogu (wejścia do niego) do pisania na tworzenie nowych obiektów wewnątrz niego i zmienianie nazw istniejących.

Rozszerzeniem podstawowych uprawnień opisanych powyżej jest mechanizm Filesystem Access Control List (ACL, fACL).\\
Jest on opcjonalnym mechanizmem który (na wspierających go systemach plików) pozwala na definiowanie indywidualnych uprawnień do pliku dla poszczególnych użytkowników i grup – plik ma nadal swojego właściciela, grupę i wszystkich pozostałych, ale przed prawami dla "others" wchodzą prawa użytkowników i grup definiowanych w ACL. Wypadkowe prawa obliczane są jako suma wynikła z praw użytkownika i grup do których należy.\\
ACL pozwala ponadto definiować uprawnienia domyślne dla nowo powstałych plików w katalogu (są one opcją katalogu).

Wszystkie poniższe komendy przyjmują opcję \texttt{-R} powodującą rekursywne wykonywanie zmian na drzewku katalogów/plików rozpoczynającym się w podanej ścieżce.
\begin{itemize}
	\item \Verb{chown [opcje] właściciel ścieżka}
		zmiana właściciela pliku
	\item \Verb{chgrp [opcje] grupa ścieżka}
		zmiana grupy do której należy plik pliku
	\item \Verb{chmod [opcje] uprawnienia ścieżka}
		zmiana prawa dostępu do pliku(ów)
	
	\item \Verb{getfacl [opcje] [ścieżka]}
		odczyt uprawnień związanych z listami kontroli dostępu fACL
	\item \Verb{setfacl [opcje] [ścieżka]}
		ustawianie uprawnień związanych z listami kontroli dostępu fACL
\end{itemize}

\noindent{\Symbola 🤔} Dodatkowo należy wspomnieć też o poleceniach takich jak:
\begin{itemize}
	\item \Verb{lsattr} / \Verb{chattr}
		wyświetla / modyfikuje atrybuty plików związanych z systemem plików (np. zabrania jakiejkolwiek modyfikacji pliku)
	\item \Verb{getcap} / \Verb{setcap}
		wyświetla / modyfikuje atrybuty plików związanych z właściwościami jądra (zasadniczo zwiększonymi uprawnieniami programów je posiadających, ale bardziej ograniczonymi niż wykonanie na prawach root przez SUID)
\end{itemize}

\subsection{Użytkownicy}
\begin{itemize}
	\item \Verb{id [użytkownik]}
		informacja o użytkowniku (m.in. grupy do których należy)
	\item \Verb{whoami}
		informacja o aktualnym użytkowniku
	\item \Verb{w lub who}
		informacja o zalogowanych użytkownikach
	
	\item \Verb{passwd [użytkownik]}
		zmiana hasła
		
	\item \Verb{su [użytkownik]}
		przełącza użytkownika (aby przełączony użytkownik miał dostęp do "naszego" x serwera wcześniej wydajemy \texttt{xhost LOCAL:użytkownik})
	\item \Verb{sudo}
		program pozwalający na wykonywanie uprzywilejowanych komend przez wyznaczonych użytkowników
\end{itemize}

\subsection{Procesy i zasoby}
\begin{itemize}
	\item \Verb{ps [opcje]}
		wyświetla aktualnie działające procesy i informacje o nich\\
			np. kombinacja opcji \texttt{-Alf} powoduje wyświetlenie wszystkich procesów, w długim, pełnym formacie wypisywania
		
	\item \Verb{top}
		monitorowanie procesów obciążających CPU, pamięć, itd
	\item \Verb{iotop}
		monitorowanie procesów obciążających I/O
	
	\item \Verb{kill [opcje] pid}
		przesyła sygnał do procesów o podanych PID
	\item \Verb{killall [opcje] nazwa}
		przesyła sygnał do procesów o pasującej nazwie
\end{itemize}

\begin{ProTip}{kill i zabijanie procesu}
Polecenie kill domyślnie wysyła sygnał SIGTERM, który jest prośbą o zakończenie procesu (proces może ją uszanować lub nie, np. zignorować). Więc sam kill nie zabija procesu.

Wiele sygnałów może zostać przechwyconych i obsłużonych (zignorowanych) przez proces do którego są adresowane. Istnieją także sygnały, które nie mogą zostać obsłużone bądź zignorowane są to m.in.:
	SIGKILL (zakończenie procesu bez dania mu jakiejkolwiek szansy zrobienia czegoś na „do widzenia”, wysyłany przez \Verb#kill -9#),
	SIGSTOP (wstrzymanie procesu).
\end{ProTip}

\begin{ProTip}{Ctrl+C / Ctrl+Z / Ctrl+D}
\textbf{Ctrl+C} wysyła sygnał SIGINT do procesu zajmującego terminal na którym został on wprowadzony. Sygnał ten jest prośbą o zakończenie procesu, którą proces może uszanować lub nie (np. może całkiem zignorować lub poprosić o potwierdzenie). Jest on podobny do SIGTERM, jednak jest innym sygnałem i może być inaczej obsłużony (np. w SIGTERM nie ma większego sensu pytać o potwierdzenie).

\vspace{6pt}\textbf{Ctrl+Z} wysyła sygnał SIGTSTP do procesu zajmującego terminal na którym został on wprowadzony. Sygnał ten jest prośbą o wstrzymanie procesu i oddanie terminala, prośba ta może być zignorowana przez proces. Proces przerwany w ten sposób może być wznowiony poleceniem \Verb#fg# (które wznowi go jako pierwszoplanowy – okupujący terminal) lub \Verb#bg# (które wznowi go jako jako proces w tle – oddając terminal, przodkowi który go posiadał wcześniej).

\vspace{6pt}\textbf{Ctrl+D} nie wysyła żadnego sygnału, działa tylko gdy proces czyta dane z terminala (podłączonego zazwyczaj do jego standardowego wejścia). Wysyła on do terminala znak EOT (End-of-Transmission), w efekcie czego:
\begin{itemize}
	\item (jeżeli bufor wejściowy jest niepusty) terminal wypycha bufor wejściowy do programu (tak jak po wprowadzeniu nowej linii), albo
	\item (jeżeli nie ma znaków w buforze) terminal zamyka strumień wprowadzanych danych do programu
\end{itemize}
Program nie otrzymuje w strumieniu znaku EOT (jest on przechwycony przez terminal).
Zamknięcie strumienia wejściowego na ogół prowadzi także do zakończenia działania programu, jednak (w odróżnieniu od Ctrl-C) pozwala programowi na normalne przetworzenie wprowadzonych danych.
\end{ProTip}

\begin{ProTip}{Ctrl+S / Ctrl+Q}
\textbf{Ctrl+S} wstrzymuje przewijanie (odświeżanie) terminala, aby wznowić należy użyć \textbf{Ctrl+Q}.
\end{ProTip}
% END: Użytkownicy, uprawnienia i procesy

% BEGIN: Planowanie zadań
\subsection{Planowanie zadań}
Typowo system zapewnia usługę uruchamiania zadań o zadanym czasie. Z usługi tej można skorzystać przy pomocy poleceń:
\begin{itemize}
	\item \Verb{crontab} pozwala oglądać i edytować tablice zaplanowanych zadań cyklicznych (dla cron'a)
	\item \Verb{at} pozwala jednorazowo zaplanować zadanie
\end{itemize}
	Pliki konfiguracyjne crona / obsługiwane crontab-em mają postać: \texttt{minuty godzina  dzienMiesiaca miesiac dzienTygodnia polecenie}.
	Wpis oznacza że polecenie ma zostać wykonane jeżeli wszystkie warunki będą spełnione, jeżeli jakiś warunek nie jest nam potrzebny można użyć gwiazdki \texttt{*},
	z kolei \texttt{*/n} oznacza wykonywanie jeżeli dana wartość jest podzielna przez n. Np.:
		\texttt{*/20 3  * * 1 ls} oznacza wykonanie komendy ls w każdy poniedziałek o godzinie 3:00 3:20 i 3:40
	
	Standardowe wyjście, wyjście błędu oraz powiadomienie o niezerowym kodzie powrotu domyślnie są wysyłane na lokalny adres mailowy użytkownika będącego właścicielem danego contaba.
	Niekiedy dostępny jest także \texttt{anacron} pozwalający na mniej precyzyjne planowanie zadań.
% END: Planowanie zadań

% BEGIN: System operacyjny - intro
\section{System operacyjny}
\begin{teacherOnly}
\begin{easylist}[itemize]
	& \textbf{proces startu}
		&& "co komputer zaczyna robić po włączeniu?"
		&& zasysanie instrukcji przez procesor
		&& załadowanie i uruchomienie bootloadera
		&& załadowanie i uruchomienie jądra
		&& opcja init
	& funkcje systemu operacyjnego
		&& procesy
			&&& co to jest proces
			&&& wątki (wątek vs proces)
			&&& \textbf{szeregowanie zadań}
			&&& drzewo procesów (rodzice)
			&&& ew. algorytmy szeregowania
			&&& fork()
			&&& sygnały
				&&&& kill
				&&&& czy proces może nie umrzeć? ... pokazać: wynik ps, wskazać pid bash'a, zrobić kill bash
				&&&& wiele różnych sygnałów ... Ctr+C ... Ctrl+Z ... info o zakończeniu potomka ...
		&& obsługa plików
			&&& wszystko jest plikiem
			&&& select(), czyli czekanie na dane ...
		&& \textbf{obsługa dostępu do pamięci}
			&&& pokazać rysując na tablicy stronnicowanie
			&&& pamięć współdzielona
				&&&& problem  if a==1: a=0
				&&&& semafory
		&& obsługa dostępu do urządzeń
			&&& interfejsy sieciowe, itd
		&& standardowe usługi
			&&& cron
			&&& mail
\end{easylist}
\end{teacherOnly}

System operacyjny jest programem uruchamianym po starcie komputera (co prawda nie jako pierwszym, ale zastępującym / usuwającym z pamięci uruchomione wcześniej, więc najstarszym z działających).
% END: System operacyjny - intro

% BEGIN: Proces uruchamiania komputera
\subsection{Proces startu}

Po otrzymaniu sygnału resetu (także przy uruchamianiu systemu - "Power-on Reset") procesor po inicjalizacji rejestrów zaczyna wykonywanie kodu znajdującego się pod jakimś ustalonym adresem (typowo w wbudowanej lub zewnętrznej pamięci typu ROM lub Flash). W zależności od danej architektury / procesrora może to być m.in.: bezpośrednio kod programu użytkownika, wbudowany bootloader danego procesora umożliwiający dalsze ładowanie np. z karty SD, zewnętrzny niskopoziomowy bootloader (np. u-boot).

W przypadku architektur zgodnych z x86 jest to BIOS, który po zakończeniu procesu inicjalizacji sprzętu i testów rozruchowych ładuje do pamięci kod znajdujący się w pierwszym sektorze dysku twardego (sektorze rozruchowym rozpoczynającym się od adresu zerowego) i uruchamia go (przekazuje do niego kontrolę). Znajduje się tam kod (lub tylko początek kodu) programu rozruchowego, którego zadaniem jest załadowanie systemu operacyjnego. W przypadku współczesnych systemów linuxowych jest to zazwyczaj GRUB.

Start systemu rozpoczyna się od załadowania do pamięci obrazu jądra wraz z parametrami oraz (opcjonalnie) initrd i przekazania kontroli do jądra przez program rozruchowy (np. GRUB). W przypadku jądra linuxowego i korzystania z initrd obraz ten przekształcany jest na RAM-dysk w trybie zapisu-odczytu i montowany jako rootfs z którego uruchamiany jest \Verb#/sbin/init# (którego podstawowym zadaniem jest zamontowanie właściwego rootfs). Po jego zakończeniu (lub od razu gdy nie używamy initrd) uruchamiany jest program wskazany w opcji \Verb#init=# jądra (domyślnie typowo \Verb#/sbin/init#) z rootfs wskazanego w opcji \Verb#root=# jądra. W opcji \Verb#init=# można wskazać dowolny program lub skrypt (uruchomiony zostanie z prawami root'a).
% END: Proces uruchamiania komputera

% BEGIN: Co robi system operacyjny
\subsection{Rola systemu operacyjnego}

System operacyjny jest oprogramowaniem odpowiedzialnym za zarządzanie zasobami systemu komputerowego (sprzętem, ale nie tylko) oraz uruchomionymi na nim aplikacjami. Do najistotniejszych zadań systemu operacyjnego zalicza się podział czasu procesora i szeregowanie zadań oraz zarządzanie pamięcią - w szczególności obsługa pamięci wirtualnej, najczęściej z wykorzystaniem mechanizmu stronicowania.

Oprócz tego system zajmuje się także zarządzaniem plikami, wejściem/wyjściem (najczęściej jest ono realizowane w oparciu o przerwania (IRQ), ale znane są także modele programowego we/wy polegającego na aktywnym czekaniu), obsługą urządzeń (wejście/wyjście, sterowniki, dostęp), obsługą sieci (stos protokołów sieciowych), itd.

Współczesne systemy korzystają z co najmniej dwóch poziomów pracy - uprzywilejowanego poziomu "nadzorcy" w którym działa jądro systemu operacyjnego oraz trybu użytkownika. Operacje I/O muszą odbywać się w trybie uprzywilejowanym. Również pamięć posiada obszar chroniony, w którym umieszczany jest m.in. tablica wektorów przerwań (inaczej zmiana adresu w tym wektorze mogłaby doprowadzić do przejęcia systemu w trybie uprzywilejowanym).
% END: Co robi system operacyjny

% BEGIN: Zarządzanie procesami
\subsubsection{Zarządzanie procesami}

Jednym z głównych zadań systemu operacyjnego jest zarządzanie procesami na nim uruchomionymi - obejmuje to zarówno czynności związane z ich tworzeniem oraz kończeniem, jak też szeregowanie zadań. To system operacyjny przejmuje okresowo procesor (z użyciem przerwania zegarowego), aby podjąć decyzję (w oparciu o jakiś algorytm szeregowania zadań) który/które z porcesów gotowych do działania (czyli takich, które aktualnie nie oczekują na "coś") ma dostać przydział czasu porcesora.
% END: Zarządzanie procesami

% BEGIN: Zarządzanie pamięcią
\subsubsection{Zarządzanie pamięcią}

Drugą podstawową funkcją systemu operacyjnego, wspomnianą na początku, jest zarządzanie pamięcią. Zarządzanie pamięcią polega na odpowiednim mapowaniu adresów logicznych (używanych przez procesy) na adresy fizyczne (używane przez procesor), korzysta ono z wsparcia sprzętowego ze strony procesora.

Jest to najczęściej realizowane w oparciu o wspomniany mechanizm stronicowania. Polega to na podziale pamięci dostępnej pamięci fizycznej na jednakowe bloki zwane ramkami oraz podziale pamięci logicznej na jednakowe bloki (o tej całej wielkości co ramki) zwane stronami. Strony które są wykorzystywane przez program są mapowane na dowolne ramki pamięci fizycznej (w przypadku gdy dana strona nie zamapowana - w zależności od okoliczności błąd braku strony lub błąd ochrony strony).

Rozwiązuje to problem fragmentacji zewnętrznej, polegającej na braku spójnego obszaru pamięci o żądanej długości pomimo iż łączna ilość wolnej pamięci jest dostateczna, jednak nie rozwiązuje problemu fragmentacji wewnętrznej, polegającej na przydzielaniu zbyt dużych fragmentów pamięci dla procesu (a wręcz można powiedzieć że go pogłębia).

Mechanizm ten wymaga trzymania tablicy wolnych ramek, tablicy stron dla każdego procesu (zawierającej przypisania mapowań stron danego procesu na ramki) oraz wykonywania tłumaczenia adresów logicznych (strona + przesunięcie na stronie). Także sama tablica stron procesu procesu może być stronicowania (mamy tablicę która informuje nas że przypisania stron w danym zakresie adresów są przechowywane w jakiejś ramce).

Strony i ramki mogą być współdzielone pomiędzy procesami (np. przy rozgałęzianiu procesu strony są kopiowane dopiero gdy zajdzie taka potrzeba). W przypadku braku miejsca w pamięci fizycznej wybrane strony nieaktywnego aktualnie procesu mogą być umieszczane na dysku (swap).
% END: Zarządzanie pamięcią

\section{Literatura dodatkowa}
 Więcej informacji o podstawach działania w systematach ,,unixowych'' oraz pełniejsza lista poleceń zamieszczona została pod adresem \url{http://vip.opcode.eu.org/#Systemy_unix-owate}.

\rozwiazania

\copyrightFooter{
	© Matematyka dla Ciekawych Świata, 2017-2020.\\
	© Robert Ryszard Paciorek <rrp@opcode.eu.org>, 2003-2020.\\
	Kopiowanie, modyfikowanie i redystrybucja dozwolone pod warunkiem zachowania informacji o autorach.
}
\end{document}

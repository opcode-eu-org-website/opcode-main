% Copyright (c) 2020 Matematyka dla Ciekawych Świata (http://ciekawi.icm.edu.pl/)
% Copyright (c) 2020 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% Copyright (c) 2020 Krzysztof Lasocki <krz.lasocki@gmail.com>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\documentclass{pdfBooklets}

\title{Programowanie mikrokontrolerów STM32}
\author{%
	Projekt ,,Matematyka dla Ciekawych Świata'',\\
	Krzysztof Lasocki\\\normalsize\ttfamily <krz.lasocki@gmail.com>
}
\date  {2020-05-26}

\makeatletter\hypersetup{
	pdftitle = {\@title}, pdfauthor = {\@author}
}\makeatother

\begin{document}

\maketitle

Skrypt opisuje podstawy programowania mikrokontrolerów STM32. Podczas kursu będziemy używać
popularnej, dostępnej i prostej płytki ``Blue Pill''. Programy będą pisane w języku
C z pomocą biblioteki \Verb$libopencm3$ (\url{https://github.com/libopencm3/libopencm3}).
Każde z ćwiczeń to oddzielny program, więc jego kod znajduje się w oddzielnym katalogu.

Kod przykładów znajduje się w \hyperref[repo]{repozytorium}. Można je sklonować do podkatalogu za pomocą:

\begin{CodeFrame*}[bash]{}
  git clone https://bitbucket.org/OpCode-eu-org/stm32-examples.git
\end{CodeFrame*}

Repozytorium zawiera link symboliczny \Verb$libopencm3$ wskazujący na \Verb$../libopencm3-master$.
Pliki wspomagające kompilację przykładów zakładają że w tym miejscu znajdą katalog z (skompilowaną wcześniej) biblioteką \Verb$libopencm3$.
Jeżeli bibliotekę tę masz w innej lokalizacji zastąp ten link wskazującym na poprawną lokalizację katalogu z skompilowaną biblioteką.


\section{Pierwszy program}
Odpowiednikiem programu ``Hello, world!'' w elektronice jest program migający diodą LED.
Przykładowy kod takiego programu znajdziesz w pliku \Verb$main.c$ znajdującym się w podkatalogu \Verb$00_blink$ repozytorium z przykładami.
Plik ten ma następującą postać:

\inputminted[frame=single,firstline=6]{c}{stm32-examples/00_blink/main.c}

Skompiluj i wgraj program za pomocą:

\begin{CodeFrame*}[bash]{}
cd 00_blink
make
make install
\end{CodeFrame*}

Jeśli \Verb$stm32flash$ wyszedł bez błędów, Twój program powinien się uruchomić. Zielona dioda na płytce powinna zacząć migać.

Jeżeli \Verb$stm32flash$ zgłosił błędy zrestartuj mikrokontroler przyciskiem reset i ponów polecenie \Verb$make install$.

\begin{ProTip}{\normalfont{\strong{Uwaga}}}
  Płytka BluePill której używamy posiada zworki kontrolujące tryb uruchomienia mikrokontrolera (piny \Verb$BOOT0$ i \Verb$BOOT1$).
  Zworka, którą przestawiłeś/aś (\Verb$BOOT0$) na ``1'' podczas przygotowywania mikronotrolera do pracy powoduje uruchomienie w
  trybie bootloadera. Po zaprogramowaniu, \Verb$stm32flash$ wydaje bootlaoderowi polecenie uruchomienia programu.\\
  
  Jeśli chcesz, aby mikrokontroler automatycznie uruchamiał program po podłączeniu zasilania, możesz ustawić obie zworki na ``0''. Nie zapomnij
  jednak ustawić ich z powrotem do trybu bootloadera, jeśli chcesz ponownie wgrać program.\\
  
  Możesz użyć polecenia \Verb$make run$ aby uruchomić program znajdujący się w pamięci mikrokontrolera po jego zrestartowaniu (bez potrzeby ponownego wgrywania lub zmieniania ustawień zworek).
\end{ProTip}

Przyjrzyjmy się powyższemu plikowi linia po linii, aby zrozumieć, dlaczego nasz program działa.

\begin{CodeFrame*}[c]{}
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/gpio.h>

\end{CodeFrame*}

Dołączamy dwa pliki nagłówkowe z biblioteki \Verb$libopencm3$ aby móc używać jej funkcji. Możliwe jest pisanie kodu w ``czystym'' C
(lub nawet w asemblerze), ale kod w ten sposób napisany będzie mniej czytelny i mniej przenośny.
\footnote{Oraz niewiele szybszy.}

\begin{CodeFrame*}[c]{}
int main() { 
\end{CodeFrame*}

Jak każdy program w C, funkcją początkową jest \verb$main$. W tym przypadku nie bierze ona żadnych argumentów. Mimo \Verb$int$ w
definicji, nie zwraca ona żadnej wartości. W elektronice, \Verb$main$ z reguły nigdy nie kończy pracy (powrót z niej najczęściej
kończy się skokiem do wektora resetu i zresetowaniem mikronontrolera)

\begin{CodeFrame*}[c]{}
  rcc_periph_clock_enable(RCC_GPIOC);
  gpio_set_mode(GPIOC, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO13);
\end{CodeFrame*}

Po rozpoczęciu programu konfigurujemy peryferia. W tym programie używamy portu C aby migać diodą, która jest podłączona do pinu C13
(13. bit portu C). Przed rozpoczęciem jakichkolwiek działań z tym peryferium musimy uruchomić jego zegar\footnotemark (wywołaniem makra
\Verb$rcc_periph_clock_enable$ z odpowiednim parametrem)
\footnotetext{Taka dowolność we włączaniu lub wyłączaniu sygnału zegara do peryferiów pozwala projektantom oszczędzać energię.
  Jest to bardzo ważne np. przy układach zasilanych bateriami. W układach CMOS, kiedy nie następują zmiany stanów, pobór energii
  jest praktycznie znikomy, więc to, czy sygnał zegara nieużywanego peryferium jest zatrzymany lub nie, znacznie wpływa na pobór prądu}

Następnie konfigurujemy pin C13 jako wyjście \textit{push-pull}. Domyślnie wszytkie piny GPIO są skonfigurowane jako wejścia.


\begin{CodeFrame*}[c]{}
  while(1){
    // Poczekaj chwilkę
    for (int i = 0; i < 150000; i++) __asm__("nop");
    // Przełącz stan pinu 13 w porcie C
    gpio_toggle(GPIOC, GPIO13); 
  }
\end{CodeFrame*}

Jak mówiłem wcześniej, procedura main z reguły nie wychodzi. Zamiast tego kończy się nieskończoną pętlą. W pętli, procesor najpierw
wykonuje \texttt{nop}, czyli tzw. pustą instrukcję 150000 razy\footnotemark. Następnie funkcja \Verb$gpio_toggle$ zmienia stan pinu 13
w porcie C na przeciwny, co powoduje zapalenie lub zgaszenie LEDa.
\footnotetext{W brew pozorom ta funkcja nie zabierze 150 tys. cykli procesora, tylko znacznie więcej. Zwiększenie wartości zmiennej,
  porównanie i skok warunkowy zajmują czas. Nie jest to precyzyjna metoda odmierzania czasu.
  
  Użycie wstawki asemblerowej - bo to oznacza \Verb$__asm__()$ z instrukcją \Verb$nop$ - zapobiega optymalizacji takiej pętli przez kompilator.
  Wstawek tego typu mozna też używać w celu umieszczenia w kodzie C lub C++ dowolnych innych instrukcji asemblerowych.}

\begin{Zadanie}{}{}
  Zmień ten program tak, aby dioda LED migała około dwa razy wolniej.
\end{Zadanie}



\section{Obsługa wejść}
W tym ćwiczeniu pokażę, jak odczytywać stany logiczne pinów GPIO procesora oraz jak na ich podstawie podejmować
decyzje. Skompiluj ten kod podobnie jak w poprzednim przykładzie (weź pod uwagę, że znajduje się on w innym katalogu: \Verb$01_di$).
Plik \Verb$main.c$ wygląda następująco:

\inputminted[frame=single,firstline=11]{c}{stm32-examples/01_di/main.c}

Na płytce stykowej zbuduj układ wg. poniższego schematu:

\begin{center}\includegraphics[width=0.8\textwidth]{img/elektronika/stm32_01_di}\end{center}

Po naciśnięciu przycisku na płytce stykowej, powinna zapalić się zielona dioda led. Omówmy teraz powyższy program krok po kroku.

Podobnie jak w poprzednim ćwiczeniu, musimy włączyć używane peryferia włączając ich sygnał zegara. Tym razem używamy
dwóch portów GPIO - portu C (do którego jest podłączona dioda) oraz portu A (do którego podłączony jest przycisk).
Z tego powodu trzeba uruchomić je oba (kolejność nie ma znaczenia):

\begin{CodeFrame*}[c]{}
  rcc_periph_clock_enable(RCC_GPIOA);
  rcc_periph_clock_enable(RCC_GPIOC);
\end{CodeFrame*}

Podobnie jak pin C13, pin A0 też należy skofigurować\footnotemark. Ustawiamy go jako wejście, bez podciągania
(wymuszania jakiegoś stanu, gdy nic nie jest podłączone - mówimy wtedy, że wejście jest pływające):

\begin{CodeFrame*}[c]{}
  gpio_set_mode(GPIOC, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO13);
  gpio_set_mode(GPIOA, GPIO_MODE_INPUT, GPIO_CNF_INPUT_FLOAT, GPIO0);
\end{CodeFrame*}

\footnotetext{Wejście pływające (\textit{Input, Input floating}) jest domyślną kofiguracją wejścia. To wywołanie
  funkcji nic nie zmienia, ale umieściliśmy je tutaj w ramach przykładu.
  Jeżeli chcielibyśmy ustawić wewnętrzne podciąganie to zamiast \Verb$GPIO_CNF_INPUT_FLOAT$ należałoby podać \Verb$GPIO_CNF_INPUT_PULL_UPDOWN$
  i ustawić pin w stanie wysokim lub niskim (w zależności czy chcemy podciągać do stanu wysokiego czy do masy) przy pomocy \Verb$gpio_set$ lub \Verb$gpio_clear$.
}

Same w sobie, wejścia pływające nie mają niczego, co mogło by wymusić na nich stabilny stan logiczny. Zjawiska indukcji
elektromagnetycznej (spowodowane m.in. stałym, 50Hz szumem od sieci elektrycznej) indukują na nich losowe napięcia
(w pewnym małym zakresie, lecz wystarczająco dużym, aby powodować nieustalone stany logiczne). Z tego powodu
nieużywane wejścia z reguły podłącza się do znanego potencjału (GND lub napięcia zasilania układu) aby zapobiegać
stanom nieustalonym. W mikrokontrolerach można też włączyć wbudowane rezystory podciągające.
%
Pływającego wejścia można użyć jako źródła liczb losowych\footnote{Jest to jedna z prostszych wersji takiego
  generatora, wcale nie pozbawiona innych wad}

Podobnie jak w poprzednim przykładzie, po zakończeniu inicjalizacji mikrokontrolera (ustawienia GPIO), program
wchodzi w nieskończoną pętlę. Za każdą iteracją wczytujemy do niej stan portu A do 16 bitowej zmiennej
(w przypadku STM32 port ma 16 bitów szerokości, więc użycie 16-bitowej liczby jest najsensowniejsze):

\begin{CodeFrame*}[c]{}
  int16_t stan_a;

  while(1){
    stan_a = gpio_port_read(GPIOA);
\end{CodeFrame*}

W instrukcji warunkowej program sprawdza, czy najmłodszy bit zmiennej jest równy 1. \texttt{0x01} to tzw. maska bitowa.
Zauważ, że wynik operacji \texttt{\Verb$stan_a & 0x01$} jest 1 jeden gdy najmłodszy bit jest równy 1. Tego typu
konstrukcje są powszechnie spotykane w programach mikrokontrolerowych.\footnote{
	Jeśli chcielibyśmy sprawdzić inny bit (np. bit na 5 miejscu), użylibyśmy maski, która składa się z samych zer oprócz piątego bitu.
	Można ją wyrazić jako \Verb$0x01 << 5$ (jedynka przesunięta o 5 miejsc w lewo). Kompilator zamieni to wyrażenie na stałą.
}
Jeśli warunek wynosi jeden, wykonuje się funkcja \Verb$gpio_set$, która gasi diodę. W przeciwnym wypadku, funkcja
\Verb$gpio_clear$ przełącza pin C13 w stan niski, powodując zapalenie diody.

\begin{CodeFrame*}[c]{}
    if(stan_a & 0x01){
      gpio_set(GPIOC, GPIO13);
    }else{
      gpio_clear(GPIOC, GPIO13);
    }
\end{CodeFrame*}

Następnie wymuszamy opóźnienie (zbyt szybko działający program mógłby mieć problem z drganiem styków):

\begin{CodeFrame*}[c]{}
    for (int i = 0; i < 150000; i++) __asm__("nop");
\end{CodeFrame*}

W ten sposób doszliśmy do końca programu. Pętla jest nieskończona, więc mikroprocesor będzie cyklicznie wykonywał
jej zawartość, sterując diodą LED odpowiednio do stanu na A0.


\begin{Zadanie}{}{}
  Jaką maską bitową można sprawdzić czy bit nr. 1 jest w stanie wysokim? A jaką można sprawdzić to samo, ale
  dla wszystkich bitów parzystych (na pozycjach 0, 2, 4 ... 14\footnote{16 bitowa liczba ma bity ``ponumerowane'' od 0 do 15})?
\end{Zadanie}

\begin{Zadanie}{}{}
  Zastanów się jakie zmiany należy wykonać w tym programie, aby zamiast dodawać zewnętrzny rezystor podciągający użyć wbudowanego podciągania wejść.
  Sprawdź swoje przypuszczenia odpowiednio modyfikując układ i program.
\end{Zadanie}

\begin{Zadanie}{}{}
  Zastanów się jakie zmiany należy wykonać w tym programie, aby reagował on na przycisk podłączony do pinu A1.
  Sprawdź swoje przypuszczenia odpowiednio modyfikując układ i program.
\end{Zadanie}

\begin{Zadanie}{}{}
  Zmodyfikuj ten program tak, aby dioda zapalała się tylko, gdy stan logiczny wejścia się zmienia.\\
  \textit{Wskazówka: co zawiera zmienna \texttt{\Verb$stan_a$} tuż przed załadowaniem jej nowym stanem? Pamiętaj
  o stanach nieustalonych.}
\end{Zadanie}



\section{UART}
UART to jeden z popularniejszych protokołów przesyłania danych. Jest podstawą wielu innych protokołów, i obecny praktycznie wszędzie
W tym ćwiczeniu dowiesz się jak zaprogramować peryferium UARTu w swoim mikrokontrolerze. Pokażemy też w jaki sposób ``połączyć'' znane Ci funkcje
wejścia/wyjścia w taki sposób aby odbywało się ono przez UART. Pliki źródłowe znajdują się w katalogu \Verb$02_uart$, pierwszy z nich (\Verb$main.c$) ma postać:

\inputminted[frame=single,firstline=6]{c}{stm32-examples/02_uart/main.c}

Na pierwszy rzut oka ten program wydaje się być bardzo podobny do ćwiczenia pierwszego. Pojawiły się jednak dwa nowe pliki nagłówkowe
oraz dwa wywołania nowych funkcji. Pierwszy plik nagłówkowy to znany Ci \Verb$stdio.h$, który definiuje funkcje wejścia/wyjścia. Drugi, \Verb$uart.h$
znajduje się w cudzysłowiach, co oznacza że jest to plik lokalny. Poniżej jest jego zawartość:

\inputminted[frame=single]{c}{stm32-examples/02_uart/uart.h}

W pliku zadeklarowane są dwie funkcje, \Verb$_write$ oraz \Verb$usart_setup$. Przyjrzyjmy się plikowi \Verb$uart.c$ zawierającemu definicje tych funkcji:

\inputminted[frame=single]{c}{stm32-examples/02_uart/uart.c}

Funkcja \Verb$usart_setup$ konfiguruje peryferium USART.
%
Najpierw należy ustawić pin A9 w trybie \Verb$GPIO_CNF_OUTPUT_ALTFN_PUSHPULL$, czyli włączyć go jako
pin wyjściowy w trybie jego drugiej funkcji (\emph{ALTFN - Alternative Function}). W STM32 większość z pinów pełni dwie funkcje - domyślną z nich jest
GPIO, a drugą odpowiednia funkcja peryferium. W celu użycia drugiej funkcji danego pinu, musimy go w taki sposób skonfigurować. W tym przypadku
TX znajduje się na pinie A9 (do którego podłączasz programator - ponieważ programowanie STM32 odbywa się przez UART\footnote{Można również przez
SWD lub JTAG, ale do tego potrzebne są inne programatory. Twoja przejściówka USB-UART pełni tutaj także drugą rolę jako programator}):

\begin{CodeFrame*}[c]{}
  gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,
                GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART1_TX);
\end{CodeFrame*}

Następnie konfigurowany jest sam UART. Tutaj ustawiamy typowe wartości - prędkość 9600 baud\footnotemark, 8 bitów danych, 1 bit stopu.
Ustawiamy USART w trybie nadawania (odbieranie jest wyłączone). Ustawiamy brak bitu parzystości i brak kontroli przepływu:

\begin{CodeFrame*}[c]{}
  /* Setup UART parameters. */
  usart_set_baudrate(USART1, 9600);
  usart_set_databits(USART1, 8);
  usart_set_stopbits(USART1, USART_STOPBITS_1);
  usart_set_mode(USART1, USART_MODE_TX);
  usart_set_parity(USART1, USART_PARITY_NONE);
  usart_set_flow_control(USART1, USART_FLOWCONTROL_NONE);
\end{CodeFrame*}

\footnotetext{\emph{baud} (czyt. bod) to określenie jednostki symbol/sek. Prędkość transmisji w tej jednostce nazywa się \emph{baudrate}. W naszym
  przypadku symbolem jest stan niski/wysoki (bit). Z reguły baudrate nie jest równy przepustowości łącza, ponieważ wlicza się do niego też symbole
  które nie przenoszą danych(w przypadku UARTa są to bity startu,
  stopu i ew. parzystości).}
  
Na końcu procedury uruchamiamy USART:

\begin{CodeFrame*}[c]{}
  usart_enable(USART1);
\end{CodeFrame*}

Przejdźmy teraz do funkcji \Verb$_write$. Ta funkcja to nasz STM-owy odpowiednik funkcji \Verb$write$ z jądra linuksa. Służy ona do wypisania ciągu
bajtów o podanej długości na podany deskryptor pliku.

W naszym przypadku ignoruje ona wszystkie deskryptory powyżej 2 (w normalnym środowisku do tych deskryptorów podłączone były by otwarte pliki w systemie
plików. Jeśli chcielibyśmy dodać w naszym programie obsługę plików, np. przez kartę SD albo jakiś wirtualny system plików, w tym miejscu
należało by wprowadzić pierwszą zmianę):

\begin{CodeFrame*}[c]{}
  if (fd > 2) {
    return -1;
  }
\end{CodeFrame*}

Następnie przy pomocy pętli while, która wykona się \Verb$len$ razy lub aż dojdzie do znaku zerowego w napisie\footnote{Prawdziwy \Verb$write$ nie
  sprawdza tego drugiego warunku, ale ta wersja będzie służyć tylko do wypisywania napisów na UART}, wywołujemy funkcję \Verb$usart_send_blocking$
z parametrem USART1 i kolejnymi znakami z wypisywanego napisu. W ten sposób napis podany jako parametr będzie wypisany znak po znaku.

\begin{CodeFrame*}[c]{}
  while (*ptr && (i < len)) {
    usart_send_blocking(USART1, *ptr);
    if (*ptr == '\n') {
      usart_send_blocking(USART1, '\r');
    }
    i++; 
    ptr++;
  }
\end{CodeFrame*}

Warunek porównujący znak ze znakiem nowej linii i wstawiający znak powrotu karetki jest potrzeby aby po znaku nowej linii kursor w terminalu powrócił
na początek linii.

Na końcu zwraca ilość wypisanych znaków (tak jak prawdziwa funkcja \Verb$write$):

\begin{CodeFrame*}[c]{}
  return i;
\end{CodeFrame*}

Ta funkcja jest potrzebna (mimo tego, że nigdzie jej bezpośrednio nie wywołujemy) do tego aby funkcje z \Verb$stdio.h$ mogły komunikować się ze światem.
Jak widać jest to ograniczona wersja prawdziwej funkcji write, która dostarcza ``sztuczną'' obsługę plików \Verb$stdin$, \Verb$stdout$, i \Verb$stderr$
w naszym środowisku. 

To właśnie tą funkcję będą wywoływać \Verb$printf$, \Verb$puts$ w ramach ostatecznego wypisania danych na wyjście.
\\

Wracając do pliku \Verb$main.c$:

\begin{CodeFrame*}[c]{}
  while(1){
    for (int i = 0; i < 150000; i++) __asm__("nop");
    gpio_toggle(GPIOC, GPIO13);
    printf("Hello, World!\n");
  }
\end{CodeFrame*}

Ta pętla oprócz znanego już migania diodą wypisuje ``Hello, World!'' na standardowe wyjście (teraz podłączone do UARTa) za każdą iteracją.


Upewnij się, że wszystkie 3 pliki są zapisane a następnie skompiluj i wgraj ten program za pomocą:

\begin{CodeFrame*}[bash]{}
  make
  make install
\end{CodeFrame*}

a następnie uruchom \Verb$picocom$ aby zobaczyć co dzieje się na porcie szeregowym:

\begin{CodeFrame*}[bash]{}
  picocom /dev/ttyUSB0
\end{CodeFrame*}

\begin{ProTip}{Porada}
  Możesz automatycznie uruchamiać picocom po udanym wgraniu programu łącząc te dwa polecenia w następujący sposób:
  \begin{minted}[frame=none]{bash}
  make install && picocom /dev/ttyUSB0
  \end{minted}
\end{ProTip}

\subsection{Odbieranie danych poprzez UART}

W ostatnim ćwiczeniu nauczyliśmy się wysyłać dane poprzez interfejs UART. Uruchomiliśmy także wygodny\footnote{
	Ta wygoda ma jednak swoją cenę.
	Jeżeli zauważyliście że ostatni program wgrywał się dłużej niż poprzednie to jest to efektem zwiększenia jego rozmiaru (a zatem i zapotrzebowania na pamięć flash) na skutek dodania funkcji \Verb$printf$.
	Nasz mikrokontroler posiada jej na tyle dużo iż nie jest to dla nas istotnym problemem, ale warto pamiętać iż użycie \Verb$printf$ na słabszych mikrokontrolerach może być praktycznie nie do zrealizowania.
}
sposób wypisywania informacji na port szeregowy poprzez standardową funkcję \Verb$printf$.

UART możemy wykorzystać także do odbierania danych. W tym ćwiczeniu uruchomimy odbiornik UART, a jako że jego działanie oprzemy na przerwaniach (a nie aktywnym czekaniu na dane w wyznaczonym punkcie programu) to zapoznamy się także z podstawą obsługi przerwań.

\begin{ProTip}{Przerwania}
  Przerwanie jest to (sprzętowy lub programowy) sygnał dla procesora, powodujący zmianę przepływu sterowania, polegającą na przerwaniu aktualnie wykonywanego kodu programu i rozpoczęcie wykonywania procedury obsługi przerwania.
  Zazwyczaj odbywa się to z użyciem wektora przerwań, czyli tablicy używanej do mapowania numeru przerwania na adres pod którym umieszczona jest procedura obsługi danego przerwania.
  
  Na wcześniejszych zajęciach wspomnieliśmy już o przerwaniu zegarowym, które jest używane przez system operacyjny m.in. do okresowego przerywania działania programów celem ustalenia który z czekających procesów powinien rozpocząć swoje (dalsze) wykonywanie.
  Mechanizm ten (z użyciem przerwania generowanego programowo) jest wykorzystywany także do wywoływania funkcji systemowych z poziomu kodu użytkownika.
\end{ProTip}

Kod źródłowy dla tego ćwiczenia znajduje się w katalogu \Verb$02b_uart2$. Pliki \Verb$uart.h$ i \Verb$uart.c$ mają postać dokładnie taką samą jak poprzednio i nie będziemy ich modyfikować (będą one nam dostarczały jednokierunkowy UART używany przez \Verb$printf$ w tym i w kolejnych ćwiczeniach). Zmianom uległ natomiast \Verb$main.c$ i wygląda następująco:

\inputminted[frame=single,firstline=6]{c}{stm32-examples/02b_uart2/main.c}

Pierwszą rzeczą konieczną do wykonania jest ustawienie adresu wektora przerwań na początkowy adres pamięci flash,
	gdyż nasz program wgrywany i uruchamiany jest właśnie z wbudowanej pamięci flash,
	a kompilator wektor przerwań umieszcza na początku kodu\footnote{
		W tablicy tej, na dobrze zdefiniowanej pozycji (bajty 4-7, odpowiadające wyjątkowi \textit{reset}), umieszczany jest także adres początku kodu związanego z naszym programem.
		To do tego adresu wykonywany jest skok gdy zrestartujemy nasz mikrokontroler z ustawioną zworkami BOOT opcją uruchamiania z pamięci flash
			lub wydamy wbudowanemu bootloaderowi polecenie uruchomienia od początku pamięci flash (opcja \Verb$-g 0x0$).
	}:
	
\begin{CodeFrame*}[c]{}
  SCB_VTOR = FLASH_BASE;
\end{CodeFrame*}

Następnie możemy i powinniśmy włączyć obsługę (odbieranie) przerwań związanych z USART1:

\begin{CodeFrame*}[c]{}
  nvic_enable_irq(NVIC_USART1_IRQ);
\end{CodeFrame*}
oraz aktywować generowanie przez układ interfejsu USART przerwań związanych z odebraniem bajtu:

\begin{CodeFrame*}[c]{}
  usart_enable_rx_interrupt(USART1);
\end{CodeFrame*}

W kolejnych krokach konfigurujemy UART tak jak w poprzednim ćwiczeniu, konfigurujemy pin A10 (UART1 RX) jako input oraz przełączamy tryb pracy naszego portu szeregowego na nadawanie i odbiór:

\begin{CodeFrame*}[c]{}
  usart_setup();
  gpio_set_mode(GPIOA, GPIO_MODE_INPUT, GPIO_CNF_INPUT_FLOAT, GPIO10);
  usart_set_mode(USART1, USART_MODE_TX_RX);
\end{CodeFrame*}

Po powitalnym odliczaniu funkcje \Verb$main$ kończymy nieskończoną, pustą (wykonującą \Verb$nop$) pętlą \Verb$while$:

\begin{CodeFrame*}[c]{}
  while(1)
      _asm__("nop");
\end{CodeFrame*}

Musimy dodać jeszcze jedną funkcję która będzie związana z obsługą przerwania od portu szeregowego.
Używana biblioteka wymaga aby funkcja ta nazywała się \Verb#usart1_isr#.
W ramach niej odczytujemy z bufora wejściowego odebrany bajt (przy użyciu funkcji \Verb$usart_recv()$) i w zależności od jego parzystości włączamy lub wyłączamy LED podłączony do pinu C13:

\begin{CodeFrame*}[c]{}
  void usart1_isr(void) {
    if ( USART_SR(USART1) & USART_SR_RXNE ) {
      uint8_t data = usart_recv(USART1);
      if (data%2)
        gpio_set(GPIOC, GPIO13);
      else
        gpio_clear(GPIOC, GPIO13);
    }
  }
\end{CodeFrame*}



\section{Przetwornik analogowo-cyfrowy}
Przetwornik analogowo-cyfrowy w STM32 należy do jednych z bardziej zaawansowanych. W tym ćwiczeniu pokażemy prosty przykład
użycia przetwornika ADC do odczytu napięcia z jednego z pinów mikrokontrolera.

Zbuduj układ zgodnie z poniższym schematem:

\begin{center}\includegraphics[width=0.8\textwidth]{img/elektronika/stm32_03_adc}\end{center}

Program będzie wysyłał wynik konwersji na UART. Do wysyłania komunikatów na uart użyjemy kodu z poprzedniego ćwiczenia.
Kod źródłowy znajduje się w katalogu \Verb$03_adc$ i wszystkie elementy związane z obsługą ADC umieszczone zostały w pliku \Verb$main.c$.

Najpierw musimy zainicjalizować peryferium ADC. W tym celu stworzyliśmy funkcję \Verb$adc_setup()$:

\inputminted[frame=single,firstline=13,lastline=35]{c}{stm32-examples/03_adc/main.c} % funkcja 

Powyższy fragment kodu ustawia pin A0 w tryb wejścia analogowego i konfiguruje ADC w sposób pozwalający na przeprowadzanie pojedynczych konwersji. Następnie włącza ADC, czeka pewien okres czasu aż ADC się ustabilizuje wykonuje procedurę kalibracji.\\

Teraz możemy zdefiniować funkcję, która zwróci nam wynik pojedynczej konwersji.

\inputminted[frame=single,firstline=36,lastline=48]{c}{stm32-examples/03_adc/main.c} % funkcja adc_read()

Peryferium ADC w mikrokontrolerach STM32 pobiera listę kanałów na których ma się odbyć konwersja. W naszym przypadku chcemy pobrać
wartość tylko z jedengo kanału. Pin A0 to kanał zerowy, więc umieszczemy zero w pierwszym elemencie tablicy którą przekażemy
funkcji ustawiąjącej kolejność konwersji. Do tej funkcji przekazujemy również ilość kanałów dla których przeprowadzana będzie
konwersja - w tym przypadku 1.

Następnie uruchamiamy konwersję i oczekujemy na jej zakończenie (\Verb$adc_eoc()$ zwraca fałsz dopóki trwa konwersja).
Na końcu naszej funkcji zwracamy wynik konwersji (wynik funkcji \Verb$adc_read_regular(ADC1)$.

Mając już gotowe funkcje obsługujące ADC pozostaje nam tylko włączyć jego zegar i użyć w jakiś sposób wyniku naszej konwersji:

\inputminted[frame=single,firstline=49]{c}{stm32-examples/03_adc/main.c} % funkcja main()

W \Verb$main$ pojawiło się wywołanie \Verb$rcc_periph_clock_enable$ uruchamiające zegar dla ADC, wywołanie naszej funkcji
konfigurującej ADC oraz wypisanie wyniku konwersji w pętli za pomocą \Verb$printf()$.

Po uruchomieniu programu powinien zacąć migać zielony LED, a po uruchomieniu \Verb$picocom$ powinniśmy widzieć wyniki konwersji
przesyłane przez UART. Obracająć potencjometr zmieniamy napięcie na pinie A0, co zmienia wynik konwersji ADC.


\section{Komunikacja $I^2C$}
$I^2C$ jest popularnym protokołem szeregowym wykorzystywanym do komunikacji między cyfrowymi układami scalonymi. Jego odmiana, SMBus, jest m. in.
stosowana do komunikacji z inteligentnymi bateriami. W tym ćwiczeniu zademonstrujemy implementację mastera oraz slave'a $I^2C$ na STM32.\\

W modelu STM32 używanym przez nas są dwa peryferia $I^2C$. Połączymy je ze sobą i oprogramujemy jedno jako master, a drugie jako slave.
Dzięki temu nasz mikrokontroler będzie mógł „rozmawiać” sam ze sobą\footnote{
	Oczywiście w realnych zastosowaniach nie stosuje się takiego połączenia, jednak jest to dobry przykład do pokazania obsługi $I^2C$
	zarówno od strony mastera jak i slave'a, bez konieczności używania jakichkolwiek innych układów.
} poprzez magistralę $I^2C$.
Nasz układ wygląda tak:

\begin{center}\includegraphics[width=0.8\textwidth]{img/elektronika/stm32_04_i2c}\end{center}

Rezystory podciągające powinny mieć wartość kilku k$\Omega$.

Kod do tego ćwiczenia znajduje się w katalogu \Verb$04_i2c$.
Pliki \Verb$uart.*$ nie uległy zmianie od kiedy zaczęliśmy ich używać i dostarczają obsługę wypisywania informacji na port szeregowy.
Całość obsługi $I^2C$ znajduje się w pliku \Verb$main.c$ - przyjrzyjmy mu się bliżej.

Zaczynamy od zdefiniowania adresu naszego slave'a - zdefiniujemy makro:

\begin{CodeFrame*}[c]{}
#define SLAVE_ADDR 0x0F
\end{CodeFrame*}

Następnie należy skonfigurować oba peryferia. Funkcja inicjalizująca może zostać zaimplementowana w taki sposób:

\begin{CodeFrame*}[c]{}
void i2c_setup(){
  rcc_periph_clock_enable(RCC_GPIOB);
  rcc_periph_clock_enable(RCC_I2C1);
  rcc_periph_clock_enable(RCC_I2C2);


  /* I2C1 - master; SDA=B7, SCL=B6 */
  i2c_reset(I2C1);
  i2c_peripheral_disable(I2C1);
  i2c_set_speed(I2C1, i2c_speed_sm_100k, 8);

  gpio_set_mode(GPIOB, GPIO_MODE_OUTPUT_2_MHZ,
		  GPIO_CNF_OUTPUT_ALTFN_OPENDRAIN, GPIO6 | GPIO7);
  
  i2c_peripheral_enable(I2C1);


  /* I2C2 - slave; SDA=B11, SCL=B10 */
  i2c_reset(I2C2);
  i2c_peripheral_disable(I2C2);
  i2c_set_speed(I2C2, i2c_speed_sm_100k, 8);

  i2c_set_own_7bit_slave_address(I2C2, SLAVE_ADDR);

  nvic_enable_irq(NVIC_I2C2_EV_IRQ);
  
  gpio_set_mode(GPIOB, GPIO_MODE_OUTPUT_2_MHZ,
		  GPIO_CNF_OUTPUT_ALTFN_OPENDRAIN, GPIO10 | GPIO11);

  i2c_enable_interrupt(I2C2, I2C_CR2_ITEVTEN );
  i2c_peripheral_enable(I2C2);

  
  i2c_enable_ack(I2C2);
}
\end{CodeFrame*}

Powyższa funkcja konfiguruje oba interfejsy. Konfigurację zaczynamy włączenia taktowania, resetu oraz wyłączenia peryferiów (konfiguracje wstępne
powinny odbywać się przy wyłączonych peryferiach). Pierwszy interfejs (I2C1) będzie masterem,
zaś drugi (I2C2) - slave'm.\\

W przypadku mastera ustawiamy tylko prędkość magistrali za pomocą funkcji
\Verb$i2c_set_speed(I2C1, i2c_speed_sm_100k, 8)$, która jako argumenty pobiera peryferium (I2C1), prędkość (jako wartość typu wyliczeniowego enum),
oraz prędkość zegara taktującego peryferium w MHz (domyślnie jest to \textit{HSI Clock}, wewnętrzny oscylator - w naszym przypadku 8MHz).\\

Dla I2C2 konfiguracja wymaga także ustawienia adresu (funkcja \Verb$i2c_set_own_7bit_slave_address(I2C2, SLAVE_ADDR)$), włączenia przerwania
\Verb$nvic_enable_irq(NVIC_I2C2_EV_IRQ)$ i skonfigurowania go (\Verb$i2c_enable_interrupt(I2C2, I2C_CR2_ITEVTEN )$, generowanie przerwania dla wszystkich wydarzeń na szynie danych) oraz włączenia odpowiedzi na własny adres (odsyłanie \textit{ACK}, funkcja \Verb$i2c_enable_ack(I2C2)$,
wywoływana po włączeniu peryferium).

Oprócz wymienionych kroków należy też skonfigurować piny GPIO na których (domyślnie) znajdują się sygnały $I^2C$, w trybie
\Verb$GPIO_CNF_OUTPUT_ALTFN_OPENDRAIN$ (\textit{open-drain}, alternatywna funkcja).

Ponieważ nasz procesor jest jednowątkowy, obsługa slave'a będzie odbywać się całkowicie w funkcji obsługi przerwania. W związku z tym musimy ją
zdefiniować. Nasza biblioteka oraz skrypty linkera oczekują, że będzie nazywać się \Verb$i2c2_ev_isr$.

\begin{CodeFrame*}[c]{}
void i2c2_ev_isr(void){
  
  uint32_t sr1, sr2;
  sr1 = I2C_SR1(I2C2);

  // Address matched (Slave)
  if (sr1 & I2C_SR1_ADDR){
    //Clear the ADDR sequence by reading SR2.
    sr2 = I2C_SR2(I2C2);
    (void) sr2;	
  }

  //Master write request
  else if(sr1 & I2C_SR1_RxNE){
    slavebyte = I2C_DR(I2C2);
    slavebyte *= 2;
    I2C_CR1(I2C2) = I2C_CR1(I2C2);
  }
  
  //Master read request
  if ((sr1 & I2C_SR1_TxE)){
    I2C_DR(I2C2) = slavebyte;
    I2C_CR1(I2C2) |= I2C_CR1_STOP;
  }
}
\end{CodeFrame*}

Ta procedura obsługi przerwania wykonuje się dla wszystkich wydarzeń na szynie danych. W związku z tym należy najpierw sprawdzić, jakie wydarzenie
spowodowało wystąpienie przerwania. Służy do tego rejestr \Verb$I2C_SR1$ (\textit{Status Register 1}). Jego adres zwraca makro \Verb$I2C_SR1(x)$,
które oblicza go na postawie adresu bazowego peryferium. W zależności od tego, które wydarzenie na szynie danych wygenerowało przerwanie, ustawiane
są odpowiednie bity w tym rejestrze.\\

Jeżeli przerwanie zostało wygenerowane poprzez odebranie własnego adresu, spełniony będzie warunek \Verb$sr1 & I2C_SR1_ADDR$ (w rejestrze ustawiony
będzie bit \Verb$I2C_SR1_ADDR$). W takim wypadku peryferium oczekuje od programu odczytania rejestru SR2.

\begin{ProTip}{\normalfont{\strong{Uwaga}}}
Odczytanie rejestru SR2 powoduje wysłanie ACK i przejście interfejsu do stanu gotowości do odebrania danych - inaczej peryferium będzie
trzymać linię SCL nisko, blokując szynę. Tego typu model programowy, w którym odczytanie lub zapisanie wartości rejestru powoduje
jakąś akcję peryferium jest często spotykany. Narzuca on pewnie ograniczenia ale ma też swoje zalety, m. in. pozwala na szybszą obsługę takich
interfejsów.

W przypadku interfejsu $I^2C$ trzeba odczytać i/lub zapisać pewne rejestry po większości operacji na szynie.
\end{ProTip}

Jeśli poprzednia instrukcja warunkowa się nie wykonała, procedura sprawdza, czy w przypadku żądania odczytu przez mastera, rejestr danych (DR) nie jest pusty (ustawiony bit \Verb$I2C_SR1_RxNE$
w SR1, \textit{Rx Not Empty}). Jeśli tak jest, to znaczy że odebrano bajt z szyny danych (od mastera). Należy wtedy wczytać ten bajt z DR oraz dokonać zapisu do rejestru
CR2. Wykonuje to linijka \Verb$I2C_CR1(I2C2) = I2C_CR1(I2C2)$. Mimo braku jej sensu z punktu widzenia programu, należy pamiętać, że makra rejestrów
definiują je jako \texttt{volatile}, więc nie zostanie ona usunięta w procesie optymalizacji kodu, a kompilator wygeneruje kod zapisujący wartość
do CR2.\footnote{tutaj podobnie, interfejs czeka na tę operację i trzyma linię SCL w stanie niskim aż do jej wystąpienia, brak tej linijki spowoduje
  zawieszenie szyny}

Tutaj także wykonujemy operację którą realizuje slave. W tym przypadku jest nią pomnożenie odebranego bajtu razy 2 i zachowanie go w pamięci.

Jeśli master wyśle żądanie odczytu ze slave'a, po otrzymaniu adresu, w SR1 ustawiony będzie bit \Verb$I2C_SR1_TxE$ (\textit{Tx Empty}) informujący
o tym, że takie żądanie nastąpiło a rejestr danych do wysłania jest pusty. Wtedy zapisanie bajtu danych do DR spowoduje wysłanie tych danych na szynę
do mastera. W naszym przypadku daną do wysłania jest poprzednio zachowana i pomnożona wartość.

Należy potem zasygnalizować interfejsowi gotowość do wysłania danych, zapisując CR1\footnote{tak samo tutaj interfejs oczekuje tego zapisu do rejestru i będzie wymuszał stan niski na SCL dopóki taki zapis nie nastąpi. }.\\

Oprogramowanie interfejsu mastera jest mniej skomplikowane, ponieważ odbywa się w zwykłej funkcji. Poniżej funkcja zapisu bajtu do slave'a (jako
argument pobiera interfejs oraz wartość bajtu):

\begin{CodeFrame*}[c]{}
void i2c_send_write(uint32_t peryf, uint8_t dane){
  i2c_send_start(peryf);
  // Czekaj na wysłanie startu
  while (!((I2C_SR1(peryf) & I2C_SR1_SB)
	   & (I2C_SR2(peryf) & (I2C_SR2_MSL | I2C_SR2_BUSY))));
  
  i2c_send_7bit_address(peryf, SLAVE_ADDR, I2C_WRITE);
  //Czekaj na wysłanie adresu
  while (!(I2C_SR1(peryf) & I2C_SR1_ADDR));
  (void) I2C_SR2(peryf); //Wyczyść EV6

  
  i2c_send_data(peryf, dane);

  while (!(I2C_SR1(peryf) & (I2C_SR1_BTF))); //Czekaj na wyslanie danych

  i2c_send_stop(peryf);
}
\end{CodeFrame*}

Transmisja danych rozpoczyna START, którego wysłanie powoduje funkcja \Verb$i2c_send_start(peryf)$. Następnie oczekujemy na zakończenie wysyłania
START wykonując pustą pętle dopóki bit \Verb$I2C_SR1_SB$ (\textit{Start Bit}) w SR1 oraz bity \Verb$I2C_SR1_MSL$ (\textit{Master/slave}) i
\Verb$I2C_SR1_BUSY$ (oznaczający, że na szynie odbywa się komunikacja) w SR2 nie zostaną ustawione na 1. Ponieważ funkcja \Verb$i2c_send_start(peryf)$
(oraz inne funkcje związane z kontrolą I2C) ustawia tylko bity rejestrach, zakończy się ona wcześniej niż na szynie pojawi się jej oczekiwany
efekt. Z tego powodu zawsze należy poczekać, aż żądane działanie rzeczywiście się zakończy.\\

Po wysłaniu warunku START, wysyłamy adres z flagą R/W ustawioną na zapis, za pomocą funkcji
\Verb$i2c_send_7bit_address(peryf, SLAVE_ADDR, I2C_WRITE)$. Po tej operacji należy poczekać aż bit \Verb$I2C_SR1_ADDR$ w SR1 zostanie ustawiony, a
następnie wykonać odczyt SR2\footnotemark (linijka \Verb$(void) I2C_SR2(peryf)$ odczytuje tę wartość a następnie ją porzuca. Jest to obowiązkowe).
Potem wysyłamy bajt za pomocą funkcji \Verb$i2c_send_data(peryf, dane)$ i oczekujemy na ustawienie bitu \Verb$I2C_SR1_BTF$ (\textit{Byte Transfer
  Finished} w SR1. Operację zapisu kończymy wysyłając STOP za pomocą \Verb$i2c_send_stop(peryf)$ (tutaj wyjątkowo nie trzeba czekać na ustawienie żadnych flag).\\

\footnotetext{Dokładna kolejność działań na rejestrach dla peryferium $I^2C$ jest opisana w rozdziałach 26.3.2 (oprogramowanie slave'a) i 26.3.3
  (oprogrwamowanie mastera) w \hyperref[refman]{\textit{Reference manual}}}
  


Podobnie możemy stworzyć funkcję odczytu bajtu ze slave'a:

\begin{CodeFrame*}[c]{}
uint8_t i2c_send_read(uint32_t peryf){
  uint8_t dane;
  
  i2c_send_start(peryf);
  // Czekaj na wysłanie startu
  while (!((I2C_SR1(peryf) & I2C_SR1_SB)
	   & (I2C_SR2(peryf) & (I2C_SR2_MSL | I2C_SR2_BUSY))));
  
  i2c_send_7bit_address(peryf, SLAVE_ADDR, I2C_READ);

  //Czekaj na wysłanie adresu
  while (!(I2C_SR1(peryf) & I2C_SR1_ADDR));
  (void) I2C_SR2(peryf); //Wyczyść EV6

  //Czekaj aż otrzymasz 1 bit danych
  while (!(I2C_SR1(peryf) & I2C_SR1_RxNE));
  dane = i2c_get_data(peryf);
  
 
  i2c_send_stop(peryf);

  return dane;
}
\end{CodeFrame*}

Z taka różnicą, że adres wysyłamy z flagą odczytu (\Verb$I2C_READ$), a po wysłaniu adresu czekamy na zapełnienie się rejestru danych bajtem od
slave'a (ustawienie bitu \Verb$I2C_SR1_RxNE$ w SR1). Funkcja \Verb$i2c_get_data(peryf)$ odczytuje rejestr DR. Operację kończymy wysyłając STOP. \\

Mając zdefiniowane funkcje - konfigurującą interfejsy, wysyłającą i odbierającą dane, oraz realizującą logikę slave'a (funkcja obsługi przerwania
I2C2) - możemy ich użyć do napisania programu testowego. Skorzystamy też z poprzednich funkcji do komunikacji po UART aby wyświetlić wyniki naszego
programu:

\begin{CodeFrame*}[c]{}
  uint8_t k = 0;
  i2c_setup();

  while(1){
    for (int i = 0; i < 500000; i++) __asm__("nop");
    
    printf("Wysylam %d\n", k);
    i2c_send_write(I2C1, k);    
    uint8_t wynik = i2c_send_read(I2C1);
    printf("Odebralem %d\n", wynik);
    k++;
  }
\end{CodeFrame*}

Ten kod wysyła kolejne liczby całkowite do slave'a i wypisuje jego odpowiedź na port szeregowy mikronotrolera.\\

Należy pamiętać, że wyjścia I2C są typu otwarty kolektor i potrzebują rezystorów podciągających!

%\section{Assembler}
%\textit{Co to \Verb$__asm__$ i kiedy się go używa. Pułapki oszukiwania kompilatora}


\section{Lektury uzupełniające}
\begin{itemize}

  % Link za długi
  %https://www.st.com/resource/en/reference_manual/cd00171190-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf
  \label{refman}
\item Tzw. \emph{reference manual} dla STM32F103 (\url{http://ln.opcode.eu.org/stm_rm0008}) - obszerny dokument opisujący w jaki sposób programować
  mikrokontroler. Zawiera szczegółowe opisy działania peryferiów, listę rejestrów i pól bitowych wraz ich funkcjami oraz
  adresami \footnotemark. Najważniejszy dokument przy programowaniu mikrokontrolera
  
  \footnotetext{W STM32 opis adresów rejestrów jest rozłożony pomiędzy \textit{reference manual} i kartę katalogową. Informacje dotyczące
    programowania mikrokontrolera są w \textit{Programming manual} (programowanie samego SCB - bloku głównego procesora) oraz
    \textit{Reference manual} (programowanie poszczególnych peryferiów)}

\item \emph{Karta katalogowa STM32F103} (\url{https://www.st.com/resource/en/datasheet/stm32f103c8.pdf}) opisująca pinout i
  parametry mikrokontrolera.

\item \emph{Dokumentacja \Verb$libopencm3$} (\url{http://libopencm3.org/docs/latest/html/}) opisująca funkcje i makra dostępne
  w bibliotece.
  
\item \emph{Przykładowy kod napisany z użyciem \Verb$libopencm3$}\\ (\url{https://github.com/libopencm3/libopencm3-examples}) 
  
\item \emph{Vademecum informatyki praktycznej} (\url{http://vip.opcode.eu.org/}) - zbiór materiałów na temat elektroniki i programowania.
  
\item \emph{Hacker's Delight} - Henry S. Warren, Jr. - książka opisująca dużą ilość algorytmów realizowalnych za pomocą operacji bitowych.
\end{itemize}

\section{Zadania}

\begin{Zadanie}{}{opeartory}
  W programowaniu mikrokontrolerów często zachodzi potrzeba ustawienia pojedynczego bitu rejestru na 0 lub 1, albo zmiany jego wartości.
  Sprawdź (np. rozpisując ich działanie), które wyrażenie w rejestrze \Verb$rejestr$, na podstawie maski \Verb$maska$:
  \begin{itemize}
  \item Ustawia te bity na 1,
  \item Ustawia te bity na 0,
  \item Odwraca wartości tych bitów.
  \end{itemize}

  \begin{CodeFrame*}[c]{}
    /* Wyrażenie 1 */
    rejestr |= maska;

    /* Wyrażenie 2 */
    rejestr ^= maska;

    /* Wyrażenie 3 */
    rejestr &= ~maska;
    \end{CodeFrame*}
\end{Zadanie}

\begin{Zadanie}{}{ustawienie_bitow}
  Napisz wyrażenia, które, nie znając poprzedniej wartości 8-bitowego rejestru \Verb$XYZZY$, wykona operacje:
  \begin{enumerate}
  \item Ustawi jego drugi najmłodszy bit jako 1
  \item Ustawi jego piąty najmłodszy bit jako 0
  \item Odwróci jego najstarszy bit
  \item Wyzeruje jego dolną połowę
  \end{enumerate}
  \textit{Wskazówka: Możesz wygenerować maskę z ustawionym bitem n za przesuwając jedynkę o n miejsc w lewo: \Verb$(1<<n)$}
\end{Zadanie}

\begin{Zadanie}{}{}
W jaki sposób zmienić częstotliwość migania LEDa w pierwszym programie? Zmień ten program tak aby LED migał (około) dwa razy szybciej.
\end{Zadanie}

\begin{Zadanie}{}{}
% Tutaj chodzi o użycie printf-a, putchar-a lub uart_send_blocking
Napisz program, który za pomocą zaimplementowanej w ćwiczeniu UART funkcji wejścia/wyjścia wypisze na UART
``trójkąt z gwiazdek'' jak poniżej

\begin{CodeFrame*}[text]{}
*
**
***
****
*****
******
*******
********
\end{CodeFrame*}
\end{Zadanie}

\begin{Zadanie}{}{}
Wiedząc, że wartość 4096 odpowiada napięciu 3.3V, a 0 napięciu 0V, zmień przykładowy program ADC tak, aby zamiast surowej
wartości wypisywał wartość napięcia.\\
\textit{Wskazówka: Aby uprościć obliczenia (uniknąć działań na liczbach zmiennoprzecinkowych), Twój program może podawać wartość w mV.}
\end{Zadanie}

\begin{Zadanie}{}{zmiana_i2c}
  Zmień funkcję realizującą logikę slave'a w przykładowym kodzie I2C tak, aby zamiast mnożyć otrzymaną liczbę przez 2, dodawał do niej jakąś
  (dowolną) stałą.
\end{Zadanie}

\copyrightFooter{
	© Matematyka dla Ciekawych Świata, 2020.\\
	© Robert Ryszard Paciorek <rrp@opcode.eu.org>, 2020.\\
	© Krzysztof Lasocki <krz.lasocki@gmail.com>, 2020.\\
	Kopiowanie, modyfikowanie i redystrybucja dozwolone pod warunkiem zachowania informacji o autorach.
}

\end{document}

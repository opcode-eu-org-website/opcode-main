% Copyright (c) 2017-2019 Matematyka dla Ciekawych Świata (http://ciekawi.icm.edu.pl/)
% Copyright (c) 2017-2019 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\documentclass{pdfBooklets}

\title {Linux i sieci: Bash jako narzędzie programowania}
\author{%
	Projekt ,,Matematyka dla Ciekawych Świata'',\\
	Robert Ryszard Paciorek\\\normalsize\ttfamily <rrp@opcode.eu.org>
}
\date  {2019-07-05}

\makeatletter\hypersetup{
	pdftitle = {\@title}, pdfauthor = {\@author}
}\makeatother


\usepackage{framed}

\begin{document}

\maketitle

\section{Zmienne}

Określanie typów zmiennych w bashu odbywa się na podstawie wartości znajdującej się w zmiennej.
Zasadniczo wszystkie zmienne są napisami, a interpretacja typu ma miejsce przy ich użyciu (a nie przy tworzeniu).
\teacher{Porównując do Pythona - jest to wyraźnie mniej silne typowanie. }
Obsługiwane są liczby całkowite oraz napisy, bash nie posiada wbudowanej obsługi liczb zmiennoprzecinkowych.

\begin{CodeFrame*}[bash]{}
zmiennaA=-91
zmiennaB="qa z"
zmiennaC=98.6 # to będzie traktowane jako napis a nie liczba
\end{CodeFrame*}
Zwróć uwagę na brak spacji pomiędzy nazwą zmiennej a znakiem równości w operacji przypisania - jest to wymóg składniowy.

Odwołanie do zmiennej odbywa się z użyciem znaku dolara, po którym występuje nazwa zmiennej. Nazwa może być ujęta w klamry, ale nie musi (jest to przydatne gdy nie chcemy dawać spacji pomiędzy nazwą zmiennej a np. fragmentem napisu). Rozwijaniu ulegają nazwy zmiennych znajdujące się w napisach umieszczonych w podwójnych cudzysłowach.
\begin{CodeFrame*}[bash]{}
echo  $zmiennaA ${zmiennaA}AA
echo "$zmiennaA ${zmiennaA}AA"
echo '$zmiennaA ${zmiennaA}AA'
\end{CodeFrame*}

\section{Podstawowe operacje}
Aby wykonać działania arytmetyczne należy umieścić je wewnątrz \Verb{$((} i \Verb{))}

Dodawanie, mnożenie, odejmowanie zapisuje się i działają one tak jak w normalnej matematyce, dzielenie zapisuje się przy pomocy ukośnika i jest ono zawsze dzieleniem całkowitym:

\begin{CodeFrame*}[bash]{}
a=12; b=3; x=5; y=6

e=$(( ($a + $b) * 4 - $y ))
c=$((  $x / $y ))

echo $e $c $z
\end{CodeFrame*}
Zauważ zachowanie przy odwołaniu do niezainicjalizowanej zmiennej \Verb{z}.

Operacje logiczne obsługiwane są komendą \Verb{test} lub operatorem \Verb{[ ]} wynik zwracany jest jako kod powrotu.
Należy zwrócić uwagę na escapowanie odwrotnym ukośnikiem nawiasów i na to że spacje mają znaczenie.
Negację realizuje \Verb{!}, należy pamiętać jednak że wynikiem negacji dowolnej liczby jest FALSE.

\begin{CodeFrame*}[bash]{}
[ \( $a -ge 0 -a $b -lt 2 \) -o $z -eq 5 ]; z=$?

echo $z
\end{CodeFrame*}
Wartość zmiennej \Verb{z} jest wynikiem warunku: \texttt{((a większe równe od zera) AND (b mniejsze od dwóch)) OR (z równe 5)}.
Bash stosuje logikę odwróconą 0 oznacza prawdę, coś nie zerowego to fałsz.

Jako operacje podstawowe powinniśmy patrzyć także na wykonanie innych programów i pobieranie ich standardowego wyjścia i/lub kodu powrotu.
Pobieranie standardowego wyjścia możemy realizować za pomocą ujęcia polecenia w \emph{backquotes} (\Verb{`}) lub operatora \Verb{$( )} (pozwala on na zagnieżdżanie takich operacji).
Natomiast kod powrotu ostatniej komendy znajduje się w zmiennej \Verb{$?} (używaliśmy tego już przy obliczaniu wyrażeń logicznych).

\begin{CodeFrame*}[bash]{}
a=`cat /etc/issuse`
b=$(cat /etc/issuse; cat /etc/resolv.conf)

echo  $a
echo  $b
echo "$b"
\end{CodeFrame*}
Zwróć uwagę na różnicę w wypisaniu zmiennej zawierającej znaki nowej linii objętej cudzysłowami i nie objętej nimi.

Bash nie obsługuje liczb zmiennoprzecinkowych ani operacji bitowych, nieobsługiwane operacje można wykonać za pomocą innego programu np:
\begin{CodeFrame*}[bash]{}
a=`echo 'print(3/2)' | python3`
b=$(echo '3/2' | bc -l)
echo $a $b
\end{CodeFrame*}


\section{Uruchamianie kodu z pliku}

Dłuższe fragmenty kodu bashowego często wygodniej jest pisać w pliku tekstowym niż bezpośrednio w linii poleceń.
Plik taki może zostać wykonany przy pomocy polecenia: \Verb{./nazwa_pliku} pod warunkiem że ma prawo wykonalności
(powinien także zawierać w pierwszą linii komentarz określający program używany do interpretacji tekstowego pliku wykonywalnego,
w postaci: \Verb{#!/bin/bash}).
Może też być wykonany za pomocą wywołania: \Verb{bash nazwa_pliku}.

Przydatną alternatywą dla powyższych metod wykonania kodu zawartego w pliku jest włączenie go do aktualnej sesji basha przy pomocy \Verb{. ./nazwa_pliku}.
W odróżnieniu od poprzednich metod pozwala to na korzystanie z funkcji i zmiennych zdefiniowanych w tym pliku w kolejnych poleceniach.

\section{Pętle i warunki}

\subsection{Pętla for}

W bashu możemy korzystać z kilku wariantów pętli for. Jednym z najczęściej używanych jest przypadek iterowania po plikach\footnote{
	Dokładniej: iteracja odbywa się po liście napisów rozdzielanej spacjami - zobacz rezultat \Verb{echo /tmp/*}
}:
\begin{CodeFrame*}[bash]{}
for nazwa in /tmp/* ; do
	echo $nazwa;
done
\end{CodeFrame*}

Możliwe jest też iterowanie po wartościach całkowitych zarówno w stylu ,,shellowym'' \teacher{(zwróć uwagę na podobieństwo do Pythona) } jak i w stylu C
\begin{CodeFrame*}[bash]{}
for i in `seq 0 20`; do
	echo $i;
done

for (( i=0 ; $i<=20 ; i++ )) ; do
	echo $i;
done
\end{CodeFrame*}

\subsection{Pętla while}

Często używana jest pętla while w połączeniu z instrukcją read co umożliwia przetwarzanie jakiegoś wejścia (wyniku komendy lub pliku) linia po linii (także z podziałem linii na słowa):
\begin{CodeFrame*}[bash]{}
cat /etc/fstab | while read slowo reszta; do
	echo $reszta;
done
\end{CodeFrame*}
Powyższa pętla wypisze po kolei wszystkie wiersze pliku \texttt{/etc/fstab} przekazanego przez stdin (przy pomocy komendy \texttt{cat})\footnote{
	Takie rozwiązanie nazywane jest \emph{martwym kotem} i powinno go się unikać.
	Lepszym rozwiązaniem jest przekazywanie pliku przez przekierowanie strumienia wejściowego przy pomocy \texttt{< plik},
	który w tym przypadku powinien znaleźć się za kończącym pętle słowem kluczowym \texttt{done}.
} z pominięciem pierwszego słowa (które wczytywane było do zmiennej slowo).

Słowa domyślnie rozdzielane są przy pomocy dowolnego ciągu spacji lub tabulatorów, separator można zmienić za pomocą zmiennej \texttt{IFS}, np:
\begin{CodeFrame*}[bash]{}
IFS=":"
while read a b; do echo $a; done < /etc/group
unset IFS # przywracamy domyślne zachowanie read poprzez usunięcie zmiennej IFS
\end{CodeFrame*}

\begin{Zadanie}{}{petla_linki_html}
Napisz pętle, która wypisze wszystkie pliki nieukryte z bieżącego katalogu w postaci linków HTML, czyli:
dla pliku o nazwie \Verb{ABC} powinna wypisać \Verb{<a href="ABC">ABC</a>}. Przedstaw zarówno rozwiązanie z użyciem pętli \Verb{for}, jak i pętli \Verb{while}.
\end{Zadanie}

\subsection{Instrukcja if}

Poznane wcześniej obliczanie wartości wyrażeń logicznych najczęściej stosowane jest w instrukcji warunkowej \Verb{if}\footnote{
	Może być też stosowane np. w pokazanej wcześniej pętli \Verb{while}
}.
\begin{CodeFrame*}[bash]{}
# instruikcja if - else
if [ "$xx" = "kot" -o "$xx" = "pies" ]; then
	echo  "kot lub pies";
elif [ "$xx" = "ryba" ];  then
	echo  "ryba"
else
	echo  "coś innego"
fi
\end{CodeFrame*}

Zauważ że spacje wokół i wewnątrz nawiasów kwadratowych przy warunku są istotne składniowo,
zawartość nawiasów kwadratowych to tak naprawdę argumenty dla komendy \Verb{test}.
Oprócz typowych warunków logicznych możemy sprawdzać np. istnienie plików, czy też ich typ (link, katalog, etc).
Szczegółowy opis dostępnych warunków które mogą być użyte w tej konstrukcji znajduje się w \Verb{man test}.
\teacher{Zwrócić szczególną uwagę na tą dokumentację.}

Jako warunek może wystąpić dowolne polecenie wtedy sprawdzany jest jego kod powrotu 0 oznacza prawdę / zakończenie sukcesem,
a wartość nie zerowa fałsz / błąd
\begin{CodeFrame*}[bash]{}
if grep '^root:' /etc/passwd > /dev/null; then
	echo /etc/passwd zawiera root-a;
fi
\end{CodeFrame*}

Istnieje możliwość skróconego zapisu warunków z użyciem łączenia instrukcji
przy pomocy \Verb{&&} (wykonaj gdy poprzednia zwróciła zero -- true)
lub \Verb{||} (wykonaj gdy poprzednia zwróciła nie zero -- false):
\begin{CodeFrame*}[bash]{}
[ -f /etc/issuse ] && echo "jest plik /etc/issuse"

grep '^root:' /etc/passwd > /dev/null && echo /etc/passwd zawiera root-a;
\end{CodeFrame*}

\begin{Zadanie}{}{warunek_istnienie_pliku}
Napisz warunek, który sprawdzi czy \Verb{/tmp/abc} istnieje i jest katalogiem.
\end{Zadanie}

\subsection{Instrukcja case}
Instrukcja \Verb{case} służy do rozważania wielu przypadków opartych na równości zmiennej z podanymi napisami.
\teacher{Zwróć uwagę na podobieństwo do switch z C/C++ oraz różnicę - operuje na napisach a nie liczbach}

\begin{CodeFrame*}[bash]{}
case $xx in
	kot | pies)
		echo  "kot lub pies"
		;;
	ryba)
		echo  "ryba"
		;;
	*)
		echo  "cos innego"
		;;
esac
\end{CodeFrame*}

\section{Definiowanie funkcji}

W bashu każda funkcja może przyjmować dowolną ilość parametrów pozycyjnych
(w identyczny sposób obsługiwane są argumenty linii poleceń dla całego skryptu).
Ilość parametrów znajduje się w zmiennej \Verb{$#}, lista wszystkich parametrów w \Verb{$@},
a do kolejnych parametrów możemy odwoływać się z użyciem \Verb{$1}, \Verb{$2}, itd.

\begin{CodeFrame*}[bash]{}
f1() {
	echo "wywołano z $# parametrami, parametry to: $@"
	
	[ $# -lt 2 ] && return;
	
	echo -e "drugi: $2\npierwszy: $1"
	
	# albo kolejnych w pętli
	for a in "$@"; do  echo $a;  done
	
	# lub z użyciem polecenia shift
	for i in `seq 1 $#`; do
		echo $1
		shift # powoduje zapomnienie $1
		      # i przenumerowanie argumentów pozycyjnych o 1
		      # wpływa na wartości $@ $# itp
	done
	
	# funkcja może zwracać tylko wartość numeryczną -- tzw kod powrotu
	return 83
}
\end{CodeFrame*}

Zwróć uwagę że w nawiasach po nazwie funkcji nie podajemy przyjmowanych argumentów, natomiast puste nawiasy te są elementem składniowym i muszą wystąpić. Jeżeli zapisujesz definicję funkcji w jednej linii, np. \Verb@abc() { echo "abc"; }@ to pamiętaj, że spacje po otwierającym i przed kończącym nawiasem klamrowym są obowiązkowe, podobnie jak średniki występujące po każdej instrukcji w ciele funkcji.

Wywołanie funkcji nie różni się niczym od wywołania programów czy instrukcji wbudowanych
(możemy używać przekierowań strumieni wejścia, wyjścia, czy też przechwycić wyjście do zmiennej). Powyższą funkcję możemy wywołać np. w następujący sposób: \Verb{f1 a "b c"   d}

\begin{Zadanie}{}{funkcja_n_razy_napis}
Napisać funkcję przyjmującą dwa argumenty - liczbę i napis; funkcja ma wypisać napis tyle razy ile wynosi podana liczba.
\end{Zadanie}

\begin{Zadanie}{}{funkcja_liczba_kotow}
Napisać funkcję przyjmującą jeden argument - liczbę kotów i wypisującą:
\begin{itemize}
	\item "Ala ma kota" dla ilości kotów równej 1
	\item "Ala ma x koty" lub "Ala ma x kotów" gdzie dobrana jest poprawna forma, a pod x podstawiona podana w argumencie ilość kotów.
\end{itemize}
Dla uproszczenia należy założyć że podana ilość kotów jest w zakresie od 1 do 9.
\end{Zadanie}


\section{Przetwarzanie napisów}

\subsection{Wbudowane}

Wbudowane przetwarzanie napisów w bashu opiera się na odwołaniach do zmiennych w postaci \Verb@${}@:

\begin{itemize}
	\item \shell@${zmienna:-"napis"}@ zwróci napis gdy zmienna nie jest zdefiniowana lub jest pusta
	\item \shell@${zmienna:="napis"}@ zwróci napis oraz wykona podstawienie zmienna="napis" gdy zmienna nie jest zdefiniowana lub jest pusta
	\item \shell@${zmienna:+"napis"}@ zwróci napis gdy zmienna jest zdefiniowana i nie pusta
	
	\vspace{6pt}
	
	\item \shell@${#str}@    zwróci długość napisu w zmiennej str
	\item \shell@${str:n}@   zwróci pod-napis zmiennej str od n do końca
	\item \shell@${str:n:m}@ zwróci pod-napis zmiennej str od n do m
	
	\vspace{6pt}
	
	\item \shell@${str/"n1"/"n2"}@  zwróci wartość str z zastąpionym pierwszym wystąpieniem n1 przez n2
	\item \shell@${str//"n1"/"n2"}@  zwróci wartość str z zastąpionymi wszystkimi wystąpieniami n1 przez n2
	
	\vspace{6pt}
	
	\item \shell@${str#"ab"}@ zwróci wartość str z obciętym "ab" z początku
	\item \shell@${str%"fg"}@ zwróci wartość str z obciętym "fg" z końca
\end{itemize}
W napisach do obcięcia możliwe jest stosowanie shellowych znaków uogólniających, czyli \Verb@*@, \Verb@?@, \Verb@[abc]@, itd operator \Verb@#@ i \Verb@%@ dopasowują minimalny napis do usunięcia, natomiast operatory \Verb@##@ i \Verb@%%@ dopasowują maksymalny napis do usunięcia.

\begin{teacherOnly}
Przykład do zademonstrowania:

\begin{CodeFrame*}[bash]{}
a=""; b=""; c=""
echo ${a:-"aa"} ${b:="bb"} ${c:+"cc"}
echo $a $b $c

a="x"; b="y"; c="z"
echo ${a:-"aa"} ${b:="bb"} ${c:+"cc"}
echo $a $b $c

x=abcdefg
echo ${#x} ${x:2} ${x:0:3} ${x:0:$((${#x}-2))}
echo ${x#"abc"} ${x%"efg"}
echo ${x#"ac"}  ${x%"eg"}

x=abcd.e.fg
echo ${x#*.} ${x##*.} ${x%.*} ${x%%.*}

y="aa bb cc bb dd bb ee"
echo ${y/"bb"/"XX"}
echo ${y//"bb"/"XX"}
\end{CodeFrame*}

\end{teacherOnly}
Możliwe jest także korzystanie z wyrażeń regularnych.
Polecenie \Verb@expr match $x 'wr1\(wr2\)wr3'@ zwróci na stdout (wypisze) część \Verb@$x@ pasującą do wyrażenia regularnego \Verb@wr2@,
wyrażenia regularne \Verb@wr1@ i \Verb@wr2@ pozwalają na określanie części napisu do odrzucenia.
Alternatywną składnią jest \Verb@expr $x : 'wr1\(wr2\)wr3'@

\begin{teacherOnly}
Przykład do zademonstrowania:

\begin{CodeFrame*}[bash]{}
z="ab=cd"
expr match $z '^\([^=]*\)='
expr $z : '^[^=]*=\(.*\)$'
\end{CodeFrame*}
\end{teacherOnly}

Możliwe jest też sprawdzanie dopasowań wyrażeń regularnych poprzez (zwróć uwagę na brak cytowania wyrażenia regularnego):

\begin{CodeFrame*}[bash]{}
[[ "$z" =~ ^([^=]*)= ]] && echo "OK"
\end{CodeFrame*}

Możliwe jest także zaawansowane formatowanie napisów, konwertowanie liczb na napisy,
w tym wypisywanie w różnych systemach liczbowych przy pomocy \Verb@printf@\footnote{
	Instrukcja \Verb@printf@ ma składnię opartą na tej funkcji z C, interpretuje ona także liczby zmiennoprzecinkowe.
}:

\begin{CodeFrame*}[bash]{}
printf "0o%o %d 0x%x\n" 0xf 010 3
\end{CodeFrame*}

\subsection{grep, cut, sed, ...}

Jako że większość operacji bashowych wiąże się z uruchamianiem zewnętrznych programów,
to także przetwarzanie napisów może być realizowane w ten sposób.
Opiera się na tym inne podejście do obsługi napisów w bashu,
którym jest korzystanie z standardowych komend POSIX, takich jak grep, cut, sed.

\begin{CodeFrame*}[bash]{}
a="aąbcć 123"

# obliczanie długości napisu w znakach, w bajtach i ilości słów w napisie
echo -n $a | wc -m
echo -n $a | wc -c
echo -n $a | wc -w

# obliczanie ilości linii (dokładniej ilości znaków nowej linii)
wc -l < /etc/passwd

# wypisanie 5 pola (rozdzielanego :) z pliku /etc/passwd  z eliminacją
# pustych linii oraz linii złożonych tylko ze spacji i przecinków
cut -f5 -d: /etc/passwd | grep -v '^[ ,]*$'
# komenda cut wybiera wskazane pola, opcja -d określa separator
\end{CodeFrame*}

Inną bardzo przydatną komendą jest sed pozwala ona m.in na zastępowanie
wyszukiwanego na podstawie wyrażenia regularnego tekstu innym:
\begin{CodeFrame*}[bash]{}
echo "aa bb cc bb dd bb ee" | sed -e 's@\([bc]\+\) \([bc]\+\)@X-\2-X@g'
\end{CodeFrame*}

Sedowe polecenie s przyjmuje 3 argumenty (oddzielane mogą być dowolnym znakiem który wystąpi za~\Verb@s@),
pierwszy to wyszukiwane wyrażenie, drugi tekst którym ma zostać zastąpione,
a trzeci gdy jest \Verb@g@ to powoduje zastępowanie wszystkich wystąpień a nie tylko pierwszego.

Należy zwrócić uwagę na różnicę w składni wyrażenia regularnego polegającą na poprzedzaniu
\Verb@(@, \Verb@)@ i \Verb@+@ odwrotnym ukośnikiem aby miały znaczenie specjalne
(jeżeli nie chcemy tego robić możemy włączyć obsługę ERE w sed poprzez opcję \Verb@-E@).

Sed z opcją \Verb@-i@ i wskazaniem pliku modyfikuje zawartości tego pliku pozwala to na łatwe stworzenie funkcji rekurencyjnego zastępowania:
\begin{CodeFrame*}[bash]{}
rreplace() {
	if [ $# -ne 2 ]; then
		echo USAGE: $1 str1 str2
		return
	fi
	grep -R "$1" . | cut -f 1 -d: | uniq | while read f; do
		[ -L $f ] || sed -e "s@$1@$2@g" -i $f;
	done;
}
\end{CodeFrame*}

Innymi przydatnymi komendami przetwarzającymi (specyficznej postaci) napisy są polecaenia \Verb@basename@ i \Verb@dirname@.
Służą one do uzyskania nazwy najgłębszego elementu ścieżki oraz ścieżki bez tego najglębszego elementu. Zobacz wynik działania:
\begin{CodeFrame*}[bash]{}
a=/proc/sys/net/core/
basename $a
dirname $a
\end{CodeFrame*}

\subsection{awk}

Awk jest interpreterem prostego skryptowego języka umożliwiający przetwarzanie tekstowych baz danych postaci \texttt{linia=rekord}, gdzie pola oddzielane ustalonym separatorem (można powiedzieć że łączy funkcjonalność komend takich jak grep, cut, sed z prostym językiem programowania).

\teacher{Około 30 minutowe wprowadzenie z pisaniem kodu na żywo}

Wyżej zaprezentowane wypisanie 5 pola (rozdzielanego :) z pliku \Verb@/etc/passwd@  z eliminacją pustych linii oraz
linii złożonych tylko ze spacji i przecinków, realizowane przy użyciu poleceń \Verb@cut@ i \Verb@grep@
może być zrealizowane za pomocą samego awk:
\begin{CodeFrame*}[bash]{}
awk -F: '$5 !~ "^[ ,]*$" {print $5}' /etc/passwd
\end{CodeFrame*}

Awk daje duże możliwości przy przetwarzaniu tego typu tekstowych baz danych -- możemy np.
wypisywać wypisywać pierwsze pole w oparciu o warunki nałożone na inne:
\begin{CodeFrame*}[bash]{}
awk -F: '$5 !~ "^[ ,]*$" && $3 >= 1000 {print $1}' /etc/passwd
\end{CodeFrame*}

Jak widać w powyższych przykładach do poszczególnych pól odwołujemy się poprzez \Verb@$n@,
gdzie \Verb@n@ jest numerem pola, \Verb@$0@ oznacza cały rekord

Program dla każdego rekordu przetwarza kolejne instrukcje postaci \Verb@warunek { komendy }@,
instrukcji takich może być wiele w programie (przetwarzane są kolejno),
komenda \Verb@next@ kończy przetwarzanie danego rekordu.

Separator pola ustawiamy opcją \Verb@-F@ (lub zmienną \Verb@FS@),
domyślnym separatorem pola jest dowolny ciąg spacji i tabulatorów
(w odróżnieniu od cut separator może być wieloznakowym napisem lub wyrażeniem regularnym).
Domyślnym separatorem rekordu jest znak nowej linii (można go zmienić zmienną RS).

Awk jest prostym językiem programowania obsługującym podstawowe pętle i instrukcje warunkowe
oraz funkcje wyszukujące i modyfikujące napisy:

\begin{oframed}\noindent\shell{echo "aba aab bab baa bba bba" | awk}\Verb@ '{@\vspace{-0.95em}
\begin{minted}{awk}
	# dla każdego pola w rekordzie
	for (i=1; i<=NF; ++i) {
		# jeżeli jego numer jest parzysty
		# to zastąp wszystkie ciągi b pojedynczym B
		if (i%2==0)
			gsub("b+", "B", $i);
		
		# wyszukaj pozycję pod-napisu B
		ii = index($i, "B")
		# jeżeli znalazł
		# to wypisz pozycję i pod-napis od tej pozycji do końca
		if (ii)
			printf("# %d %s\n", ii, substr($i, ii))
	}
	print $0
\end{minted}
\vspace{-0.95em}\Verb@}'@\end{oframed}

\noindent
AWK obsługuje także tablice asocjacyjne pozwala to np. policzyć powtórzenia słów:

\begin{oframed}\noindent\shell{echo "aa bb aa ee dd aa dd" | awk }\Verb@ '{@\vspace{-0.95em}
\begin{minted}{awk}
	BEGIN {RS="[ \t\n]+"; FS=""}
	{slowa[$0]++}
	{printf("rekord: %d done\n", NR)}
	END {for (s in slowa) printf("%s: %s\n", s, slowa[s])}
\end{minted}
\vspace{-0.95em}\Verb@}'@\end{oframed}

Podobny efekt możemy uzyskać stosując "uniq -c" (który wypisuje unikalne wiersze wraz z ich ilością)
na odpowiednio przygotowanym napisie (spacje zastąpione nową linią, a linie posortowane):
\begin{CodeFrame*}[bash]{}
echo "aa bb aa ee dd aa dd" | tr ' ' '\n' | sort | uniq -c
\end{CodeFrame*}
Jednak rozwiązanie awk można łatwo zmodyfikować aby wypisywało pierwsze wystąpienie linii bez sortowania pliku.


\subsection{Zadania dodatkowe}

\vspace{6pt}

\begin{Zadanie}{}{passwd_warunek_na_uid}
wyświetlić z /etc/passwd linie w których UID (3 pole) ma warość >= 1000 ... jeżeli ktoś ma pomysł to na dwa lub trzy sposoby
\end{Zadanie}

\begin{Zadanie}{}{pliki_zawierajace_napis} %[1pkt]
Napisz polecenie które wyszuka i przekopiuje do katalogu \Verb{/tmp} pliki z katalogu \Verb{/etc} (wraz z jego podkatalogami), które (w swojej treści) zawierają napis \Verb{nameserver}.
\end{Zadanie}

\begin{Zadanie}{}{zmiana_rozszerzenia} %[2pkt]
Napisz polecenie które dla wszystkich plików z rozszerzeniem \Verb{.TXT}  w bierzącym katalogu (bez podkatalogów) dokona zmiany ich nazwy zmieniając rozszerzenie na \Verb{.txt} i zachowując podstawową część nazwy bez modyfikacji.
\end{Zadanie}

\begin{Zadanie}{}{kopiowanie_tylko_plikow} % [2pkt]
Napisz polecenie które skopiuje wszystkie pliki (nie katalogi ani linki symboliczne) z katalogu \Verb{/etc} do \Verb{/tmp}
% wyłączamy linki symboliczne aby uniknąć: cp /etc/* /tmp
\end{Zadanie}

\begin{Zadanie}{}{parsowanie_cmdline} % [3pkt]\ \\
Plik \Verb{/proc/cmdline} zawiera informację o opcjach przekazanych do jądra podczas startu. Kolejne opcje rozdzielane są spacją, a nazwę opcji od jej argumentu rozdziela znak rówwności.
Napisz polecenie które wypisze argument opcji root. Dla pliku \Verb{/proc/cmdline} postaci:\\
 \Verb{BOOT_IMAGE=/vmlinuz-4.9-amd64 root=UUID=cad866ab-aabd-4686-8376-e4b9f1c2ae9e rw}\\
polecenie powinno wypisać:\\
 \Verb{UUID=cad866ab-aabd-4686-8376-e4b9f1c2ae9e}
\end{Zadanie}

\rozwiazania

\copyrightFooter{
	© Matematyka dla Ciekawych Świata, 2017-2019.\\
	© Robert Ryszard Paciorek <rrp@opcode.eu.org>, 2003-2019.\\
	Kopiowanie, modyfikowanie i redystrybucja dozwolone pod warunkiem zachowania informacji o autorach.
}
\end{document}

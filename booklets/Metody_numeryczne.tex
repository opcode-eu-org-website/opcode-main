% Copyright (c) 2018 Robert Ryszard Paciorek <rrp@opcode.eu.org>
% 
% MIT License
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\ifdefined\inputOnlyContent\else
\documentclass{pdfBooklets}

\title{Laboratorium programistyczne: metody numeryczne (interpolacja, r贸偶niczkowanie i cakowanie)}
\author{%
	Projekt ,,Matematyka dla Ciekawych wiata'',\\
	Robert Ryszard Paciorek\\\normalsize\ttfamily <rrp@opcode.eu.org>
}
\date  {2018-05-23}

\makeatletter\hypersetup{
	pdftitle = {\@title}, pdfauthor = {\@author}
}\makeatother


\begin{document}

\maketitle
\fi

\teacher{Skrypt przeznaczony do realizacji na dw贸ch ostatnich labach programistycznych. W przypadku braku czasu mo偶na pomin wybrane zagadnienia. W przypadku przedwczesnego skoczenia skryptu mo偶na pokaza inne algorytmy numeryczne lub wr贸ci do materia贸w dodatkowych z pierwszego skryptu.}

\teacher{\todo{u偶ywanie dx w argumentach cakowania (co powoduje problem z granic) wymaga dopracyzowania zada (bo obecnie gdy (a-b)\%dx !=0 nie istnieje rozwizanie) ... mo偶e jednak lepiej dawa ilo punkt贸w i dx oblicza wewntrznie}}

\section{Wielomiany}

Najczciej spotykanym zapisem wielomianu jest posta sumy jednomain贸w:
$$w(x) = \sum_{i=0}^na_ix^i = a_0 + a_1x + \ldots + a_nx^n$$
呕eby wiedzie, o jaki wielomian chodzi, wystarczy 偶e okreslimy list jego wsp贸czynnik贸w $a_0 \ldots a_n$. 
\teacher{Zanim przejdziemy dalej, mo偶na zapyta, jak obliczalibymy np. warto wielomianu $[1,1,\ldots,1]$, gdzie $n=2, \, 10$ lub $100$, w jakim wybranym punkcie. Jak zapisalibymy algorytm tego obliczenia?}


\subsection{Obliczanie wartoci wielomianu}

Niech  \Verb{a} bdzie list kolejnych wsp贸czynnik贸w wielomianu $a_0 \ldots a_n$.
Do obliczenia wartoci wielomianu w zadanym punkcie $x$ naturalne wydaje si zastosowanie powy偶szego wzoru w nastpujcy spos贸b:

\begin{CodeFrame*}[python]{}
def oblicz(a, x):
    w = 0
    for i in range(len(a)):
        w += a[i] * (x**i)
    return w
\end{CodeFrame*}
Niestety podejcie takie jest bardzo nieefektywne, gdy偶 w ka偶dym kolejnym kroku sumy musimy wykona coraz wicej mno偶e. W og贸lnoci w kroku $n$-tym musimy wykona $n$ mno偶e, co przekada si na czasow zo偶ono obliczeniow rzdu $\mathcal{O}(n^2)$, co oznacza 偶e czas wykonania ronie z kwadratem iloci wsp贸czynnik贸w wielomianu (czyli, og贸lnie rzecz biorc, ze stopniem wielomianu). Innymi sowy, jeli zwikszymy 10 razy stopie wielomianu, to czas liczenia zwikszy si nam $100=10^2$ razy. 
Poniewa偶 bdziemy czasem potrzebowali wielomian贸w wysokiego stopnia  --- o czym za chwil --- nie jest to dla nas najlepsza sytuacja. 

Je偶eli zauwa偶ymy, 偶e potrzebujemy policzy kolejno wszystkie potgi wartoci $x$, a偶 do $n$ to algorytm ten mo偶emy znacznie przyspieszy implementujc liczenie potgi w tej samej ptli co sumowanie:
\begin{CodeFrame*}[python]{}
def oblicz(a, x):
    p = 1
    w = a[0]
    for i in range(1, len(a)):
        p = p * x
        w += a[i] * p
    return w
\end{CodeFrame*}
Zauwa偶, 偶e dodatkowo wyrzucilimy $a_0$ poza ptl. W ten spos贸b potrzebujemy ju偶 tylko $n$ sumowa i $2n$ mno偶e (pomijajc narzut zwizany z obsug ptli itp).

Je偶eli chcemy jeszcze szybciej obliczy warto wielomianu w punkcie $x$ mo偶emy skorzysta z \emph{schematu Hornera}, co pozwoli nam zredukowa o poow liczb mno偶e.
Wymaga on przeksztacenia postaci w kt贸rej zapisujemy wielomian poprzez powyciganie $x$-贸w przed nawias:
$$a_0 + x(a_1 + x(a_2 + \ldots + x(a_{n-1} + xa_n)))$$
i rozpoczcia oblicze od $a_n$.

\begin{CodeFrame*}[python]{}
def oblicz(a, x):
    w = 0
    for i in range(len(a)-1, 0, -1):
        w = x * (a[i] + w)
    w += a[0]
    return w
\end{CodeFrame*}

\subsection{Posta Newtona}

Wielomian mo偶emy przedstawi tak偶e w innych postaciach. Jedn z takich postaci jest \emph{posta Newtona}:
$$w(x) = b_0 + b_1(x-x_0) + b_2(x-x_1)(x-x_0) + \ldots + b_n(x-x_{n-1})\ldots(x-x_0)$$
w kt贸rej wielomian stopnia $n$ okrelony jest przez $n+1$ wsp贸czynnik贸w $b_i$ oraz $n$ punkt贸w $x_i$.

\begin{Zadanie}{}{}
Napisz funkcj \Verb{oblicz_wart(xx, x, b)} obliczajc warto wielomianu w postaci Newtona.
Funkcja powinna otrzymywa argumenty: \Verb{xx} - punkt w kt贸rym ma zosta obliczona warto, \Verb{x} - lista wsp贸czynnik贸w $x_i$, \Verb{b} - lista wsp贸czynnik贸w $b_i$.\\
\\
Wskaz贸wka: do testowania funkcji mo偶esz u偶y wielomianu $w(x)$ zdefiniowanego przez
\Verb{x = [-1, 1]} i \Verb{b = [2, 1, -3]}, kt贸ry przyjmuje nastpujce wartoci:
$w(-2) = -8$, $w(-1) = 2$, $w(0) = 6$, $w(1) = 4$, $w(2) = -4$.

\begin{rozwiazanie}{python}
def oblicz_wart(xx, x, b):
	xxx = 1
	wyn = b[0]
	
	for i in range(1, len(b)):
		xxx *= (xx-x[i-1])
		wyn += b[i] * xxx
	
	return wyn
\end{rozwiazanie}
\end{Zadanie}

\section{Interpolacja}

Interpolacja to zgadywanie wartoci nieznanych na podstawie znanych. 
Dokadniej, jest to wyznaczanie przybli偶onych wartoci nieznanej funkcji, 
w oparciu o znane wartoci w tzw. punktach wzowych, kt贸re te偶 znamy. 
Realizujemy  to wyznaczajc tzw. funkcj interpolacyjn,  
kt贸ra  w punktach wzowych przyjmuje ustalone wartoci. 
Innymi sowy, wybieramy sobie pewn posta funkcji (np. decydujemy, 偶e nasza szukana 
funkcja interpolacyjna bdzie wielomianem pewnego stopnia) 
i dopasowujemy j tak, by przechodzia przez znane wartoci w znanych punktach. 

\subsection{Interpolacja wielomianowa}

Bardzo czsto jako funkcje interpolacyjne stosowane s funkcje wielomianowe. W tym wypadku zadanie interpolacji to po  prostu zadanie znalezienia wielomianu przechodzcego przez dane punkty.
\begin{teacherOnly}
Warto zwr贸ci uwag 偶e:
\begin{itemize}
	\item w przypadku gdybymy wiedzieli, 偶e przybli偶ana funkcja jest wielomianem $n$-tego stopnia oraz dysponowani $n+1$ punktami wzowymi, to uzyskane rozwizanie byoby dokadne;
	\item parzysto stopnia wielomianu drastycznie wpywa na zachowanie uzyskanej funkcji (zwaszcza poza zakresem dla kt贸rego mamy dane wejciowe)
\end{itemize}
\end{teacherOnly}

\subsubsection{Obliczanie wsp贸czynnik贸w interpolacyjnych}

Mo偶liwe jest obliczanie wsp贸czynnik贸w $a_i$ interpolowanego wielomianu zapisanego w postaci potgowej, jednak ze wzgld贸w obliczeniowych bardziej praktyczne jest posu偶enie si postaci Newtona.
Realizowane jest to przy pomocy nastpujcego algorytmu:
\begin{teacherOnly}
Uwaga! ten algorytm mo偶emy potraktowa jako czarn skrzynk, kt贸rej uczymy si u偶ywa.
\end{teacherOnly}
\begin{CodeFrame*}[python]{}
j = 0
while j <= n:
	b[j] = f[j]
	j += 1

j = 1
while j <= n:
	k = n
	while k >= j:
		b[k] = (b[k] - b[k-1]) / (x[k] - x[k-j])
		k -= 1
	j += 1
\end{CodeFrame*}
gdzie \Verb{n} jest stopniem wielomianu interpolacyjnego (obliczanego dla $n+1$ punkt贸w wzowych), \Verb{x[i]} jest wartoci $x$ dla $i$-tego punktu, a \Verb{f[i]} wartoci funkcji w $i$-tym punkcie wzowym.

\begin{Zadanie}{}{}
Napisz funkcj \Verb{oblicz_wsp(x, y)} obliczajc wsp贸czynniki wielomianu interpolacyjnego dla danego zbioru punkt贸w wzowych (okrelonych przez listy \Verb{x, y}).
Wykorzystaj j do narysowania wykresu wielomianu interpolujcego nastpujc funkcj:

\begin{center}\begin{tabular}{|c|c|}
\hline\hspace{.75cm}$x$\hspace{.75cm}~&\hspace{.75cm}$f(x)$\hspace{.75cm}~\\\hline 
1 &  8\\
3 & -5\\
6 &  3\\
7 &  9\\
\hline
\end{tabular}\end{center}

\begin{rozwiazanie}{python}
def oblicz_wsp(x, y):
	n = len(y)-1
	b = [0]*(n+1)
	
	j = 0
	while j <= n:
		b[j] = y[j]
		j += 1
	
	j = 1
	while j <= n:
		k = n
		while k >= j:
			b[k] = (b[k] - b[k-1]) / (x[k] - x[k-j])
			k -= 1
		j += 1
	
	return b

x = [1, 3, 6, 7]
y = [8, -5, 3, 9]
b = oblicz_wsp(x, y)

xx, yy = [], []
for w in range(-5, 13):
	xx.append(w)
	yy.append(oblicz_wart(w, x, b))

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
plt.plot(x, y, ".r")
plt.savefig('wykres.png')
\end{rozwiazanie}
\end{Zadanie}

\subsection{Interpolacja trygonometryczna {\Symbola }}

Interpolacja wielomianowa, ze wzgldu na swoj natur, nie za bardzo sprawdza si w przypadku funkcji okresowych. Stosowana jest wtedy czsto interpolacja trygonometryczna, w kt贸rej funkcja interpolujca ma posta:
$$f(x) = a_0 + \sum_{k=1}^m a_k \cos(kx) + \sum_{k=1}^m b_k \sin(kx)$$
W szczeg贸lnym przypadku nieparzystej liczby $n$ r贸wnoodlegych\footnote{
	W przypadku punkt贸w r贸wnoodlegych rozwizaniem jest dyskretna transformata Fouriera
} punkt贸w $x_i = i \cdot \frac{2\pi}{n}$ ta funkcja jest okrelona przez nastpujce wzory:
\begin{itemize}
\item $m = \frac{n-1}{2}$
\item $a_0 = \frac{1}{n} \sum_{k=0}^{n-1} f(x _{k})$
\item $a_j = \frac{1}{n} \sum_{k=0}^{n-1} f(x _{k}) \cdot \cos(j \cdot x _{k} )$
\item $b_j = \frac{1}{n} \sum_{k=0}^{n-1} f(x _{k}) \cdot \sin(j \cdot x _{k} )$
\end{itemize}

\section{Cakowanie}

Najprostsz podejciem do numerycznego obliczania caki oznaczonej z danej funkcji byoby liczenie sumy p贸l prostokt贸w pod wykresem funkcji dla odpowiednio maego boku $dx$ takiego prostokta w wsp贸rzdnej X.
Za wysoko prostokta mo偶emy przyjmowa warto funkcji w pocztku, rodku lub kocu danego przedziau.
Prostym usprawnieniem tej metody, nie wymagajcym znacznie wikszej iloci oblicze ani nie powodujcej znacznego wzrostu skomplikowania programu, jest zastosowanie trapez贸w zamiast prostokt贸w.

\begin{Zadanie}{}{}
Napisz funkcj \Verb{calka(f, a, b, dx = 0.3)} obliczajc warto caki okrelonej na odcinku od \Verb{a} do \Verb{b} z funkcji \Verb{f}, korzystajc z metody trapez贸w.\\
Wskaz贸wka, zauwa偶 偶e dodajc do \Verb{a} kolejne wartoci \Verb{dx} mo偶emy przekroczy \Verb{b}.

\begin{rozwiazanie}{python}
def calka(f, a, b, dx = 0.3):
	x = a
	fb = f(x)
	pole = 0
	while x < b:
		x += dx
		if x > b:
			dx -= x-b
			x = b
		
		fa, fb = fb, f(x)
		pole += (fa + .5 * (fb-fa)) * dx
	return pole

calka(f, 0, 1, 0.3)
\end{rozwiazanie}
\end{Zadanie}

\section{R贸偶niczkowanie}

Najprostsz metod obliczania (przybli偶ania) wartoci pochodnej funkcji w danym punkcie jest obliczenie jej jako: $f'_x=  \frac{f(x+dx) - f(x)}{dx}$, gdzie $dx$ jest odpowiednio ma odlegoci pomidzy dwoma punktami.

\begin{Zadanie}{}{}
Napisz funkcj obliczajc pochodn funkcji $sin(x)$, w oparciu o powy偶sz zale偶no. Funkcja powinna posiada argumenty pozwalajce na wskazanie punktu $x$ oraz wartoci $dx$ u偶ywanej do oblicze. Zobacz jak obliczane przybli偶enie pochodnej zalezy od wartoci $dx$.

\begin{rozwiazanie}{python}
import math

def pochodnaSin(x, dx):
	return (math.sin(x+dx) - math.sin(x)) / dx

for d in range(1,10):
	print(pochodnaSin(0.5, 0.1/d))
\end{rozwiazanie}
\end{Zadanie}

G贸wny problem takiego podejcia polega na znalezieniu odpowiednio maego $dx$. Mo偶na go jednak omin traktujc $f'_x$ jako funkcj zale偶n od $dx$, obliczajc jej wartoci dla kilku $dx$ i interpolujc jej warto w zerze.

\begin{Zadanie}{}{pochodna_funkcj_z_interpolacja}
Napisz funkcj \Verb{pochodna(f, x, d = 0.3)} obliczajc warto pochodnej funkcji $f(x)$ (przekazanej w argumencie \Verb{f}) w zadanym punkcie \Verb{x}.
Funkcja powinna oblicza pochodn interpolujc wartoci $f'_x(dx)$ obliczonej dla $dx = -2d$, $dx = -d$, $dx = d$ i $dx = 2d$.
\end{Zadanie}

\section{Regulator PID {\Symbola }}

Regulator PID jest to algorytm regulacji parametru procesu dziaajcy w ptli sprz偶enia zwrotnego posiadajcy czony: proporcjonalny (P), cakujcy (I) i r贸偶niczkujcy (D).

Wejciem algorytmu jest warto mierzona (bd藕 od razu r贸偶nica wartoci zadanej i mierzonej). Je偶eli kierunek zmiany sterowania jest zgodny ze zmian wartoci mierzonej (zwikszenie wartoci sygnau sterujcego powoduje zwikszenie wartoci mierzonej) to nale偶y odejmowa warto mierzon od zadanej, w przeciwnym razie od zadanej mierzon.

Wyjciem algorytmu jest warto zmiany jakiego sygnau sterujcego - mo偶e by wykorzystana bezporednio przy sterowaniu krokowym lub akumulowana celem uzyskania staej wartoci sygnau sterujcego.

Typowa algorytm ten dziaa w nieskoczonej ptli, czsto z dodatkowym krokiem czasowym (odstpem pomidzy wykonaniami kolejnych obieg贸w ptli) - deklarowanym jawnie lub wynikym z kostrukcji ukadu sterujcego.

Przykadowa implementacja algorytmu:
\begin{CodeFrame*}[python]{}
class PID:
  # nastawa - warto zadana
  setPoint = 0
  
  # warto wyjcia dla sterowania krokowego
  # (gdy akumulacja w ukadzie realizujcym)
  outStep = 0
  
  # warto wyjcia dla sterowania sygnaem
  outValue = 0
  
  # parametry regulatora PID
  Kp, Ki, Kd = 0, 0, 0
  
  # limity wartoci sterowanej
  outValueMin, outValueMax = 0, 0
  
  # poprzednia r贸偶nica midzy wartoci zadan a otrzyman
  # (poprzedni bd regulacji / uchyb)
  lastDiff = 0
  
  # poprzednia warto otrzymana (zmienna procesu)
  lastVal = 0
  
  # cz cakujca, akumulowana pomidzy krokami
  integral = 0
  
  def doStep(self, inputVal, stepTime):
    # obliczmy aktualny bd regulacji
    # (na podstawie odczytanej wartoci wejciowej)
    diff = self.setPoint - inputVal
    
    # wyczamy regulacj gdy prowadziby do przesterowania
    if (self.outValue > self.outValueMax and diff > 0):
      return 1
    if (self.outValue < self.outValueMin and diff < 0):
      return -1
    
    # cakowanie przybli偶amy jako jako suma p贸l trapez贸w
    self.integral += (diff + self.lastDiff) / 2 * stepTime
    
    # r贸偶niczkowanie przybli偶amy jako tangens nachylenia
    # prostej pomidzy poprzednim krokiem a obecnym
    # celem zagodzenia odpowiedzi na zmiany wartoci zadanej
    # r贸偶niczkujemy sygna wejciowy a nie bd regulacji
    derivative = -(inputVal - self.lastVal) / stepTime
    
    # obliczenie wartoci sygnau sterujcego na podstawie tego kroku
    self.outStep   = self.Kp*diff + self.Ki*self.integral + \
                     self.Kd*derivative
    
    # akumulacja sygnau sterujcego
    self.outValue += self.outStep
    
    # zapamitanie aktualnego bdu regulacji
    # jako poprzedni dla nastpnego kroku
    self.lastDiff = diff
    
    # zapamitanie aktualnej wartoci wejciowej
    # jako poprzedniej dla nastpnego kroku
    self.lastVal  = inputVal
    
    return 0
\end{CodeFrame*}

Implementacja ta wymaga ustawienia parametr贸w pracy algorytmu takich jak \Verb{setPoint}, \Verb{outValueMin}, \Verb{outValueMax}, wsp贸czynniki \Verb{Kp}, \Verb{Ki}, \Verb{Kd}.
Przydatne mo偶e by te偶 zainicjowanie \Verb{lastVal} na obecny stan wejcia. Nastpnie dziaanie odbywa si w ptli:
\begin{enumerate}
\item odczyt wejcia
\item obliczenie wartoci sterujcej z u偶yciem PID (wywoanie metody \Verb{doStep})
\item wystawienie wartoci sterujcej
\item opcjonalne odczekanie jakiego czasu
\end{enumerate}

Do testowania algorytmu posu偶y nam prosty model zbiornika, w kt贸rym chcemy utrzyma zadany poziom wody, a z kt贸rego cay czas odpywa jaka jej ilo:
\begin{CodeFrame*}[python]{}
poziom = 15
wyplyw = 2

def getInput():
	global poziom
	return poziom;

def setOutput(doplyw):
	global poziom
	poziom -= wyplyw
	
	if poziom < 0:
		poziom = 0
	
	if doplyw > 100:
		doplyw = 100
	if doplyw < 0:
		doplyw = 0
	
	poziom += 0.3 * doplyw
\end{CodeFrame*}

\begin{Zadanie}{}{testuj_pid}
Napisz funkcj \Verb{testuj(steps, kp, ki, kd)} testujc dziaanie algorytmu PID. Funkcja powinna wykona \Verb{steps} iteracji algorytmu dla zadanych parametr贸w \Verb{kp}, \Verb{ki}, \Verb{kd} i narysowa wykres zmian wartoci poziomu wody w zbiorniku (zwracanej przez \Verb{getInput()} w danym kroku) oraz wartoci sterujcej zaworem dopywowym (przekazywanej do \Verb{setOutput()} w danym kroku).
\end{Zadanie}

\begin{Zadanie}{}{}
Korzystajc z funkcji \Verb{testuj(steps, kp, ki, kd)} poeksperymentuj z doborem wartoci wsp贸czynnik贸w algorytmu.

\begin{teacherOnly}
Pokaza r贸znic pomidzy:
\begin{CodeFrame*}[python]{}
testuj(200, 0.01, 0.00, 0.00)
testuj(200, 0.1, 0.00, 0.00)
testuj(200, 0.3, 0.00, 0.00)
\end{CodeFrame*}
i om贸wi znaczenie czonu proporcjonalnego (wskaza kiedy algorytm zaczyna zamykanie dolewania wody oraz jaki jest skutek trwania tego procesu)

Wspomnie o znaczeniu kroku czasowego algorytmu w stosunku co do szybkoci procesu.

Pokaza r贸znic pomidzy:
\begin{CodeFrame*}[python]{}
testuj(200, 0.3, 0.00, 0.01)
testuj(200, 0.3, 0.00, 0.1)
\end{CodeFrame*}
i om贸wi znaczenie oraz wpyw czonu r贸偶niczkujcego (teraz prdko sterowania zaworem dopywu zale偶y od prdkoci zmiany poziomu wody w zbiorniku)

Mo偶na te偶 zasugerowa zmodyfikowanie zachowania zbiornika w taki spos贸b aby od pewnego kroku zmianie ulega ilo wypywajcej wody.
\end{teacherOnly}
\end{Zadanie}

\section{Zadania dodatkowe}

\begin{Zadanie}{}{}
Napisz funkcj \Verb{oblicz_wart_tryg (xx, a, b)} obliczajc warto interpolacji trygonometrycznej w punkcie \Verb{xx}, dla podanych list wsp贸czynnik贸w \Verb{a} i \Verb{b}.
\end{Zadanie}

\begin{Zadanie}{}{}
Napisz funkcj \Verb{oblicz_wsp_tryg (y)} obliczajc i zwracajc wsp贸czynniki \Verb{a} i \Verb{b} interpolacji trygonometrycznej  dla podanego w skrypcie przypadku.\\
Wskaz贸wka: zauwa偶 偶e nie obliczany i nie wykorzystywany jest wsp贸czynnik \Verb{b[0]}
\end{Zadanie}

\begin{Zadanie}{\domowe{1}}{calka_z_prostokatow}
Napisz funkcje obliczajc cak jako sum p贸l prostokt贸w o wysokoci okrelonej przez prawy koniec przedziau o dugoci dx.
\end{Zadanie}

\begin{Zadanie}{\domowe{2}}{interpolacja_zbioru_punktow}
Napisz program dokonujcy interpolacji nastpujcego zbioru punkt贸w:
\begin{center}\begin{tabular}{|c|c|}
\hline\hspace{.75cm}$x$\hspace{.75cm}~&\hspace{.75cm}$f(x)$\hspace{.75cm}~\\\hline 
-3 & 58 \\
-2 & 39 \\
-1 & -4 \\
1  & 6 \\
2  & -37 \\
3  & -56 \\
\hline
\end{tabular}\end{center}
Narysuj wykres funkcji interpolacyjnej w przedziale [-3.7 3.7] oraz podaj wz贸r wielomianu interpolacyjnego w postaci potgowej.
\end{Zadanie}

\begin{Zadanie}{\domowe{3}}{interpolacja_cos}
Napisz program kt贸ry bdzie dokonywa interpolacji wielomianowej funkcji $cos(x)$ opierajc si kolejno na: 3, 6, 13 i 16 wybranych punktach z przedziau $[0, 4\pi]$
Program powinien narysowa wykresy kolejnych funkcji interpolujcyh oraz wykres $cos(x)$ na wsp贸lnym wykresie.
\end{Zadanie}


\begin{Zadanie}{\domowe{1}}{pochodna_dwustronna}
Na zajciach pisalimy funckj przybli偶ajc warto pochodnej w oparciu o zale偶no $f'_x=  \frac{f(x+dx) - f(x)}{dx}$, innym podejciem jest obliczanie jej jako $f'_x=  \frac{f(x+dx) - f(x-dx)}{2 \cdot dx}$.
Napisz funkcj obliczajc przybli偶enie pochodnej funkcji $cos(x)$ obliczane jako $f'_x=  \frac{f(x+dx) - f(x-dx)}{2 \cdot dx}$. Kt贸ra z tych metod wydaje si lepsza.
\end{Zadanie}

\begin{Zadanie}{\domowe{2}}{wykres_pochodnej}
Napisz program kt贸ra oblicza numerycznie warto pochodnej danej funkcji (np. $cos(x)$) w danym przedziale (z jakim ustalonym krokiem) i rysuje wykres funcji oraz tej pochodnej w zadanym przedziale.
Do obliczania pochodnej mo偶esz u偶y dowolnej metody omawianej na zajciach.
\end{Zadanie}

\begin{Zadanie}{\domowe{3}}{wykres_sin_ze_styczna}
Narysuj wykres funkcji $sin(x)$ dla x z przedziau [1,2] oraz styczne w punkcie $x=1.4$ obliczone jako krzywe o nacyleniu odpowiadajcemu przybli偶eniu pochodnej obliczonemu jako: $f'_x=  \frac{f(x+dx) - f(x)}{dx}$ i jako $f'_x=  \frac{f(x+dx) - f(x-dx)}{2 \cdot dx}$ dla dx=0.13.
\end{Zadanie}

\ifdefined\inputOnlyContent\else
\rozwiazania

\copyrightFooter{
	漏 Matematyka dla Ciekawych wiata, 2018.\\
	漏 Robert Ryszard Paciorek <rrp@opcode.eu.org>, 2003-2018.\\
	Kopiowanie, modyfikowanie i redystrybucja dozwolone pod warunkiem zachowania informacji o autorach.
}
\end{document}
\fi
